-- PL/SQL Blocks for usesComponent Generation (V3 - Query Max Batch/Lot) --
-- Creates required child instances on-demand and links them --
-- Assigns Batch/Lot for new children based on MAX existing + 1 for that Product --
commit;
SET SERVEROUTPUT ON;

DECLARE
  v_new_child_instance_id productInstance.Instance_ID%TYPE;
  v_child_category        product.Category%TYPE := 'Commodity'; -- Pass category
  v_max_existing_batch_lot NUMBER;
  v_next_batch_lot_num   NUMBER;
  v_serial_number        serialized.Serial_Number%TYPE;
  v_batch_number         serialized.Batch_Number%TYPE; -- Shared batch for serialized children of *this* parent
  v_expiration_date      commodity.Expiration_Date%TYPE;
  v_quantity_to_create   commodity.Quantity%TYPE; -- Quantity for the new child instance

BEGIN
  -- Step 1: Create the new child productInstance
  INSERT INTO productInstance (Product_ID, Date_Manufactured, Is_Recalled)
  VALUES (131.0, TIMESTAMP '2024-05-02 23:21:41', 0)
  RETURNING Instance_ID INTO v_new_child_instance_id;

  -- Step 2: Create the corresponding subtype record
  IF v_child_category = 'Commodity' THEN
    -- Find max existing Batch_Number for this specific Child_PID
    SELECT NVL(MAX(c.Batch_Number), 0) INTO v_max_existing_batch_lot
    FROM commodity c JOIN productInstance pi ON c.Instance_ID = pi.Instance_ID
    WHERE pi.Product_ID = 131.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next batch

    v_expiration_date := TIMESTAMP '2024-05-02 23:21:41' + INTERVAL '387' DAY;
    v_quantity_to_create := ROUND(0.5, 1);

    INSERT INTO commodity (Instance_ID, Batch_Number, Expiration_Date, Quantity)
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Packaged' THEN
    -- Find max existing Lot_Number for this specific Child_PID
    SELECT NVL(MAX(p.Lot_Number), 0) INTO v_max_existing_batch_lot
    FROM packaged p JOIN productInstance pi ON p.Instance_ID = pi.Instance_ID -- Assuming 'packaged' table name
    WHERE pi.Product_ID = 131.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next lot

    v_expiration_date := TIMESTAMP '2024-05-02 23:21:41' + INTERVAL '300' DAY;
    v_quantity_to_create := ROUND(0.5, 1);

    INSERT INTO packaged (Instance_ID, Lot_Number, Expiration_Date, Quantity) -- Assuming 'packaged' table name
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Serialized' THEN
    -- Assign a unique serial number
    -- Using Instance ID guarantees uniqueness within this context
    v_serial_number := 'SN-' || TO_CHAR(131.0) || '-' || TO_CHAR(v_new_child_instance_id) || '-' || SUBSTR(SYS_GUID(),1,8);
    -- Assign a batch number - use Product_ID of the *parent* instance as the batch for simplicity? Or a sequence?
    -- Let's use the Parent_IID itself as a simple batch identifier for this run.
    v_batch_number := 12.0; -- All children created FOR this parent get same batch number

    INSERT INTO serialized (Instance_ID, Serial_Number, Batch_Number)
    VALUES (v_new_child_instance_id, v_serial_number, v_batch_number);

    -- Quantity for usesComponent link for serialized is typically 1
    v_quantity_to_create := 1;

  END IF;

  -- Step 3: Create the usesComponent link
  -- Quantity_Used is the Quantity_Needed from needsComponent (which matches child quantity for non-serialized)
  IF v_child_category IN ('Commodity', 'Packaged', 'Serialized') THEN -- Only insert if subtype was handled
      INSERT INTO usesComponent (Parent_IID, Child_IID, Quantity_Used)
      VALUES (12.0, v_new_child_instance_id, ROUND(0.5, 1)); -- Use rounded quantity needed
  END IF;

EXCEPTION
  WHEN OTHERS THEN
    DBMS_OUTPUT.PUT_LINE('Error processing Parent_IID=' || 12.0 || ', Child_PID=' || 131.0 || ': ' || SQLERRM);
    -- Decide if you want to rollback just this block or let the main exception handler catch it
END;
/
DECLARE
  v_new_child_instance_id productInstance.Instance_ID%TYPE;
  v_child_category        product.Category%TYPE := 'Commodity'; -- Pass category
  v_max_existing_batch_lot NUMBER;
  v_next_batch_lot_num   NUMBER;
  v_serial_number        serialized.Serial_Number%TYPE;
  v_batch_number         serialized.Batch_Number%TYPE; -- Shared batch for serialized children of *this* parent
  v_expiration_date      commodity.Expiration_Date%TYPE;
  v_quantity_to_create   commodity.Quantity%TYPE; -- Quantity for the new child instance

BEGIN
  -- Step 1: Create the new child productInstance
  INSERT INTO productInstance (Product_ID, Date_Manufactured, Is_Recalled)
  VALUES (122.0, TIMESTAMP '2025-03-05 01:37:54', 0)
  RETURNING Instance_ID INTO v_new_child_instance_id;

  -- Step 2: Create the corresponding subtype record
  IF v_child_category = 'Commodity' THEN
    -- Find max existing Batch_Number for this specific Child_PID
    SELECT NVL(MAX(c.Batch_Number), 0) INTO v_max_existing_batch_lot
    FROM commodity c JOIN productInstance pi ON c.Instance_ID = pi.Instance_ID
    WHERE pi.Product_ID = 122.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next batch

    v_expiration_date := TIMESTAMP '2025-03-05 01:37:54' + INTERVAL '451' DAY;
    v_quantity_to_create := ROUND(0.3, 1);

    INSERT INTO commodity (Instance_ID, Batch_Number, Expiration_Date, Quantity)
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Packaged' THEN
    -- Find max existing Lot_Number for this specific Child_PID
    SELECT NVL(MAX(p.Lot_Number), 0) INTO v_max_existing_batch_lot
    FROM packaged p JOIN productInstance pi ON p.Instance_ID = pi.Instance_ID -- Assuming 'packaged' table name
    WHERE pi.Product_ID = 122.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next lot

    v_expiration_date := TIMESTAMP '2025-03-05 01:37:54' + INTERVAL '587' DAY;
    v_quantity_to_create := ROUND(0.3, 1);

    INSERT INTO packaged (Instance_ID, Lot_Number, Expiration_Date, Quantity) -- Assuming 'packaged' table name
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Serialized' THEN
    -- Assign a unique serial number
    -- Using Instance ID guarantees uniqueness within this context
    v_serial_number := 'SN-' || TO_CHAR(122.0) || '-' || TO_CHAR(v_new_child_instance_id) || '-' || SUBSTR(SYS_GUID(),1,8);
    -- Assign a batch number - use Product_ID of the *parent* instance as the batch for simplicity? Or a sequence?
    -- Let's use the Parent_IID itself as a simple batch identifier for this run.
    v_batch_number := 16.0; -- All children created FOR this parent get same batch number

    INSERT INTO serialized (Instance_ID, Serial_Number, Batch_Number)
    VALUES (v_new_child_instance_id, v_serial_number, v_batch_number);

    -- Quantity for usesComponent link for serialized is typically 1
    v_quantity_to_create := 1;

  END IF;

  -- Step 3: Create the usesComponent link
  -- Quantity_Used is the Quantity_Needed from needsComponent (which matches child quantity for non-serialized)
  IF v_child_category IN ('Commodity', 'Packaged', 'Serialized') THEN -- Only insert if subtype was handled
      INSERT INTO usesComponent (Parent_IID, Child_IID, Quantity_Used)
      VALUES (16.0, v_new_child_instance_id, ROUND(0.3, 1)); -- Use rounded quantity needed
  END IF;

EXCEPTION
  WHEN OTHERS THEN
    DBMS_OUTPUT.PUT_LINE('Error processing Parent_IID=' || 16.0 || ', Child_PID=' || 122.0 || ': ' || SQLERRM);
    -- Decide if you want to rollback just this block or let the main exception handler catch it
END;
/
DECLARE
  v_new_child_instance_id productInstance.Instance_ID%TYPE;
  v_child_category        product.Category%TYPE := 'Commodity'; -- Pass category
  v_max_existing_batch_lot NUMBER;
  v_next_batch_lot_num   NUMBER;
  v_serial_number        serialized.Serial_Number%TYPE;
  v_batch_number         serialized.Batch_Number%TYPE; -- Shared batch for serialized children of *this* parent
  v_expiration_date      commodity.Expiration_Date%TYPE;
  v_quantity_to_create   commodity.Quantity%TYPE; -- Quantity for the new child instance

BEGIN
  -- Step 1: Create the new child productInstance
  INSERT INTO productInstance (Product_ID, Date_Manufactured, Is_Recalled)
  VALUES (193.0, TIMESTAMP '2024-08-24 23:21:35', 0)
  RETURNING Instance_ID INTO v_new_child_instance_id;

  -- Step 2: Create the corresponding subtype record
  IF v_child_category = 'Commodity' THEN
    -- Find max existing Batch_Number for this specific Child_PID
    SELECT NVL(MAX(c.Batch_Number), 0) INTO v_max_existing_batch_lot
    FROM commodity c JOIN productInstance pi ON c.Instance_ID = pi.Instance_ID
    WHERE pi.Product_ID = 193.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next batch

    v_expiration_date := TIMESTAMP '2024-08-24 23:21:35' + INTERVAL '185' DAY;
    v_quantity_to_create := ROUND(1.4, 1);

    INSERT INTO commodity (Instance_ID, Batch_Number, Expiration_Date, Quantity)
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Packaged' THEN
    -- Find max existing Lot_Number for this specific Child_PID
    SELECT NVL(MAX(p.Lot_Number), 0) INTO v_max_existing_batch_lot
    FROM packaged p JOIN productInstance pi ON p.Instance_ID = pi.Instance_ID -- Assuming 'packaged' table name
    WHERE pi.Product_ID = 193.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next lot

    v_expiration_date := TIMESTAMP '2024-08-24 23:21:35' + INTERVAL '503' DAY;
    v_quantity_to_create := ROUND(1.4, 1);

    INSERT INTO packaged (Instance_ID, Lot_Number, Expiration_Date, Quantity) -- Assuming 'packaged' table name
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Serialized' THEN
    -- Assign a unique serial number
    -- Using Instance ID guarantees uniqueness within this context
    v_serial_number := 'SN-' || TO_CHAR(193.0) || '-' || TO_CHAR(v_new_child_instance_id) || '-' || SUBSTR(SYS_GUID(),1,8);
    -- Assign a batch number - use Product_ID of the *parent* instance as the batch for simplicity? Or a sequence?
    -- Let's use the Parent_IID itself as a simple batch identifier for this run.
    v_batch_number := 16.0; -- All children created FOR this parent get same batch number

    INSERT INTO serialized (Instance_ID, Serial_Number, Batch_Number)
    VALUES (v_new_child_instance_id, v_serial_number, v_batch_number);

    -- Quantity for usesComponent link for serialized is typically 1
    v_quantity_to_create := 1;

  END IF;

  -- Step 3: Create the usesComponent link
  -- Quantity_Used is the Quantity_Needed from needsComponent (which matches child quantity for non-serialized)
  IF v_child_category IN ('Commodity', 'Packaged', 'Serialized') THEN -- Only insert if subtype was handled
      INSERT INTO usesComponent (Parent_IID, Child_IID, Quantity_Used)
      VALUES (16.0, v_new_child_instance_id, ROUND(1.4, 1)); -- Use rounded quantity needed
  END IF;

EXCEPTION
  WHEN OTHERS THEN
    DBMS_OUTPUT.PUT_LINE('Error processing Parent_IID=' || 16.0 || ', Child_PID=' || 193.0 || ': ' || SQLERRM);
    -- Decide if you want to rollback just this block or let the main exception handler catch it
END;
/
DECLARE
  v_new_child_instance_id productInstance.Instance_ID%TYPE;
  v_child_category        product.Category%TYPE := 'Commodity'; -- Pass category
  v_max_existing_batch_lot NUMBER;
  v_next_batch_lot_num   NUMBER;
  v_serial_number        serialized.Serial_Number%TYPE;
  v_batch_number         serialized.Batch_Number%TYPE; -- Shared batch for serialized children of *this* parent
  v_expiration_date      commodity.Expiration_Date%TYPE;
  v_quantity_to_create   commodity.Quantity%TYPE; -- Quantity for the new child instance

BEGIN
  -- Step 1: Create the new child productInstance
  INSERT INTO productInstance (Product_ID, Date_Manufactured, Is_Recalled)
  VALUES (242.0, TIMESTAMP '2025-03-18 12:51:12', 0)
  RETURNING Instance_ID INTO v_new_child_instance_id;

  -- Step 2: Create the corresponding subtype record
  IF v_child_category = 'Commodity' THEN
    -- Find max existing Batch_Number for this specific Child_PID
    SELECT NVL(MAX(c.Batch_Number), 0) INTO v_max_existing_batch_lot
    FROM commodity c JOIN productInstance pi ON c.Instance_ID = pi.Instance_ID
    WHERE pi.Product_ID = 242.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next batch

    v_expiration_date := TIMESTAMP '2025-03-18 12:51:12' + INTERVAL '295' DAY;
    v_quantity_to_create := ROUND(0.3, 1);

    INSERT INTO commodity (Instance_ID, Batch_Number, Expiration_Date, Quantity)
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Packaged' THEN
    -- Find max existing Lot_Number for this specific Child_PID
    SELECT NVL(MAX(p.Lot_Number), 0) INTO v_max_existing_batch_lot
    FROM packaged p JOIN productInstance pi ON p.Instance_ID = pi.Instance_ID -- Assuming 'packaged' table name
    WHERE pi.Product_ID = 242.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next lot

    v_expiration_date := TIMESTAMP '2025-03-18 12:51:12' + INTERVAL '526' DAY;
    v_quantity_to_create := ROUND(0.3, 1);

    INSERT INTO packaged (Instance_ID, Lot_Number, Expiration_Date, Quantity) -- Assuming 'packaged' table name
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Serialized' THEN
    -- Assign a unique serial number
    -- Using Instance ID guarantees uniqueness within this context
    v_serial_number := 'SN-' || TO_CHAR(242.0) || '-' || TO_CHAR(v_new_child_instance_id) || '-' || SUBSTR(SYS_GUID(),1,8);
    -- Assign a batch number - use Product_ID of the *parent* instance as the batch for simplicity? Or a sequence?
    -- Let's use the Parent_IID itself as a simple batch identifier for this run.
    v_batch_number := 16.0; -- All children created FOR this parent get same batch number

    INSERT INTO serialized (Instance_ID, Serial_Number, Batch_Number)
    VALUES (v_new_child_instance_id, v_serial_number, v_batch_number);

    -- Quantity for usesComponent link for serialized is typically 1
    v_quantity_to_create := 1;

  END IF;

  -- Step 3: Create the usesComponent link
  -- Quantity_Used is the Quantity_Needed from needsComponent (which matches child quantity for non-serialized)
  IF v_child_category IN ('Commodity', 'Packaged', 'Serialized') THEN -- Only insert if subtype was handled
      INSERT INTO usesComponent (Parent_IID, Child_IID, Quantity_Used)
      VALUES (16.0, v_new_child_instance_id, ROUND(0.3, 1)); -- Use rounded quantity needed
  END IF;

EXCEPTION
  WHEN OTHERS THEN
    DBMS_OUTPUT.PUT_LINE('Error processing Parent_IID=' || 16.0 || ', Child_PID=' || 242.0 || ': ' || SQLERRM);
    -- Decide if you want to rollback just this block or let the main exception handler catch it
END;
/
DECLARE
  v_new_child_instance_id productInstance.Instance_ID%TYPE;
  v_child_category        product.Category%TYPE := 'Commodity'; -- Pass category
  v_max_existing_batch_lot NUMBER;
  v_next_batch_lot_num   NUMBER;
  v_serial_number        serialized.Serial_Number%TYPE;
  v_batch_number         serialized.Batch_Number%TYPE; -- Shared batch for serialized children of *this* parent
  v_expiration_date      commodity.Expiration_Date%TYPE;
  v_quantity_to_create   commodity.Quantity%TYPE; -- Quantity for the new child instance

BEGIN
  -- Step 1: Create the new child productInstance
  INSERT INTO productInstance (Product_ID, Date_Manufactured, Is_Recalled)
  VALUES (122.0, TIMESTAMP '2024-07-03 21:57:06', 0)
  RETURNING Instance_ID INTO v_new_child_instance_id;

  -- Step 2: Create the corresponding subtype record
  IF v_child_category = 'Commodity' THEN
    -- Find max existing Batch_Number for this specific Child_PID
    SELECT NVL(MAX(c.Batch_Number), 0) INTO v_max_existing_batch_lot
    FROM commodity c JOIN productInstance pi ON c.Instance_ID = pi.Instance_ID
    WHERE pi.Product_ID = 122.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next batch

    v_expiration_date := TIMESTAMP '2024-07-03 21:57:06' + INTERVAL '508' DAY;
    v_quantity_to_create := ROUND(0.3, 1);

    INSERT INTO commodity (Instance_ID, Batch_Number, Expiration_Date, Quantity)
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Packaged' THEN
    -- Find max existing Lot_Number for this specific Child_PID
    SELECT NVL(MAX(p.Lot_Number), 0) INTO v_max_existing_batch_lot
    FROM packaged p JOIN productInstance pi ON p.Instance_ID = pi.Instance_ID -- Assuming 'packaged' table name
    WHERE pi.Product_ID = 122.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next lot

    v_expiration_date := TIMESTAMP '2024-07-03 21:57:06' + INTERVAL '552' DAY;
    v_quantity_to_create := ROUND(0.3, 1);

    INSERT INTO packaged (Instance_ID, Lot_Number, Expiration_Date, Quantity) -- Assuming 'packaged' table name
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Serialized' THEN
    -- Assign a unique serial number
    -- Using Instance ID guarantees uniqueness within this context
    v_serial_number := 'SN-' || TO_CHAR(122.0) || '-' || TO_CHAR(v_new_child_instance_id) || '-' || SUBSTR(SYS_GUID(),1,8);
    -- Assign a batch number - use Product_ID of the *parent* instance as the batch for simplicity? Or a sequence?
    -- Let's use the Parent_IID itself as a simple batch identifier for this run.
    v_batch_number := 17.0; -- All children created FOR this parent get same batch number

    INSERT INTO serialized (Instance_ID, Serial_Number, Batch_Number)
    VALUES (v_new_child_instance_id, v_serial_number, v_batch_number);

    -- Quantity for usesComponent link for serialized is typically 1
    v_quantity_to_create := 1;

  END IF;

  -- Step 3: Create the usesComponent link
  -- Quantity_Used is the Quantity_Needed from needsComponent (which matches child quantity for non-serialized)
  IF v_child_category IN ('Commodity', 'Packaged', 'Serialized') THEN -- Only insert if subtype was handled
      INSERT INTO usesComponent (Parent_IID, Child_IID, Quantity_Used)
      VALUES (17.0, v_new_child_instance_id, ROUND(0.3, 1)); -- Use rounded quantity needed
  END IF;

EXCEPTION
  WHEN OTHERS THEN
    DBMS_OUTPUT.PUT_LINE('Error processing Parent_IID=' || 17.0 || ', Child_PID=' || 122.0 || ': ' || SQLERRM);
    -- Decide if you want to rollback just this block or let the main exception handler catch it
END;
/
DECLARE
  v_new_child_instance_id productInstance.Instance_ID%TYPE;
  v_child_category        product.Category%TYPE := 'Commodity'; -- Pass category
  v_max_existing_batch_lot NUMBER;
  v_next_batch_lot_num   NUMBER;
  v_serial_number        serialized.Serial_Number%TYPE;
  v_batch_number         serialized.Batch_Number%TYPE; -- Shared batch for serialized children of *this* parent
  v_expiration_date      commodity.Expiration_Date%TYPE;
  v_quantity_to_create   commodity.Quantity%TYPE; -- Quantity for the new child instance

BEGIN
  -- Step 1: Create the new child productInstance
  INSERT INTO productInstance (Product_ID, Date_Manufactured, Is_Recalled)
  VALUES (193.0, TIMESTAMP '2024-05-16 16:00:30', 0)
  RETURNING Instance_ID INTO v_new_child_instance_id;

  -- Step 2: Create the corresponding subtype record
  IF v_child_category = 'Commodity' THEN
    -- Find max existing Batch_Number for this specific Child_PID
    SELECT NVL(MAX(c.Batch_Number), 0) INTO v_max_existing_batch_lot
    FROM commodity c JOIN productInstance pi ON c.Instance_ID = pi.Instance_ID
    WHERE pi.Product_ID = 193.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next batch

    v_expiration_date := TIMESTAMP '2024-05-16 16:00:30' + INTERVAL '307' DAY;
    v_quantity_to_create := ROUND(1.4, 1);

    INSERT INTO commodity (Instance_ID, Batch_Number, Expiration_Date, Quantity)
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Packaged' THEN
    -- Find max existing Lot_Number for this specific Child_PID
    SELECT NVL(MAX(p.Lot_Number), 0) INTO v_max_existing_batch_lot
    FROM packaged p JOIN productInstance pi ON p.Instance_ID = pi.Instance_ID -- Assuming 'packaged' table name
    WHERE pi.Product_ID = 193.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next lot

    v_expiration_date := TIMESTAMP '2024-05-16 16:00:30' + INTERVAL '552' DAY;
    v_quantity_to_create := ROUND(1.4, 1);

    INSERT INTO packaged (Instance_ID, Lot_Number, Expiration_Date, Quantity) -- Assuming 'packaged' table name
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Serialized' THEN
    -- Assign a unique serial number
    -- Using Instance ID guarantees uniqueness within this context
    v_serial_number := 'SN-' || TO_CHAR(193.0) || '-' || TO_CHAR(v_new_child_instance_id) || '-' || SUBSTR(SYS_GUID(),1,8);
    -- Assign a batch number - use Product_ID of the *parent* instance as the batch for simplicity? Or a sequence?
    -- Let's use the Parent_IID itself as a simple batch identifier for this run.
    v_batch_number := 17.0; -- All children created FOR this parent get same batch number

    INSERT INTO serialized (Instance_ID, Serial_Number, Batch_Number)
    VALUES (v_new_child_instance_id, v_serial_number, v_batch_number);

    -- Quantity for usesComponent link for serialized is typically 1
    v_quantity_to_create := 1;

  END IF;

  -- Step 3: Create the usesComponent link
  -- Quantity_Used is the Quantity_Needed from needsComponent (which matches child quantity for non-serialized)
  IF v_child_category IN ('Commodity', 'Packaged', 'Serialized') THEN -- Only insert if subtype was handled
      INSERT INTO usesComponent (Parent_IID, Child_IID, Quantity_Used)
      VALUES (17.0, v_new_child_instance_id, ROUND(1.4, 1)); -- Use rounded quantity needed
  END IF;

EXCEPTION
  WHEN OTHERS THEN
    DBMS_OUTPUT.PUT_LINE('Error processing Parent_IID=' || 17.0 || ', Child_PID=' || 193.0 || ': ' || SQLERRM);
    -- Decide if you want to rollback just this block or let the main exception handler catch it
END;
/
DECLARE
  v_new_child_instance_id productInstance.Instance_ID%TYPE;
  v_child_category        product.Category%TYPE := 'Commodity'; -- Pass category
  v_max_existing_batch_lot NUMBER;
  v_next_batch_lot_num   NUMBER;
  v_serial_number        serialized.Serial_Number%TYPE;
  v_batch_number         serialized.Batch_Number%TYPE; -- Shared batch for serialized children of *this* parent
  v_expiration_date      commodity.Expiration_Date%TYPE;
  v_quantity_to_create   commodity.Quantity%TYPE; -- Quantity for the new child instance

BEGIN
  -- Step 1: Create the new child productInstance
  INSERT INTO productInstance (Product_ID, Date_Manufactured, Is_Recalled)
  VALUES (242.0, TIMESTAMP '2024-06-06 08:15:36', 0)
  RETURNING Instance_ID INTO v_new_child_instance_id;

  -- Step 2: Create the corresponding subtype record
  IF v_child_category = 'Commodity' THEN
    -- Find max existing Batch_Number for this specific Child_PID
    SELECT NVL(MAX(c.Batch_Number), 0) INTO v_max_existing_batch_lot
    FROM commodity c JOIN productInstance pi ON c.Instance_ID = pi.Instance_ID
    WHERE pi.Product_ID = 242.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next batch

    v_expiration_date := TIMESTAMP '2024-06-06 08:15:36' + INTERVAL '634' DAY;
    v_quantity_to_create := ROUND(0.3, 1);

    INSERT INTO commodity (Instance_ID, Batch_Number, Expiration_Date, Quantity)
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Packaged' THEN
    -- Find max existing Lot_Number for this specific Child_PID
    SELECT NVL(MAX(p.Lot_Number), 0) INTO v_max_existing_batch_lot
    FROM packaged p JOIN productInstance pi ON p.Instance_ID = pi.Instance_ID -- Assuming 'packaged' table name
    WHERE pi.Product_ID = 242.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next lot

    v_expiration_date := TIMESTAMP '2024-06-06 08:15:36' + INTERVAL '462' DAY;
    v_quantity_to_create := ROUND(0.3, 1);

    INSERT INTO packaged (Instance_ID, Lot_Number, Expiration_Date, Quantity) -- Assuming 'packaged' table name
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Serialized' THEN
    -- Assign a unique serial number
    -- Using Instance ID guarantees uniqueness within this context
    v_serial_number := 'SN-' || TO_CHAR(242.0) || '-' || TO_CHAR(v_new_child_instance_id) || '-' || SUBSTR(SYS_GUID(),1,8);
    -- Assign a batch number - use Product_ID of the *parent* instance as the batch for simplicity? Or a sequence?
    -- Let's use the Parent_IID itself as a simple batch identifier for this run.
    v_batch_number := 17.0; -- All children created FOR this parent get same batch number

    INSERT INTO serialized (Instance_ID, Serial_Number, Batch_Number)
    VALUES (v_new_child_instance_id, v_serial_number, v_batch_number);

    -- Quantity for usesComponent link for serialized is typically 1
    v_quantity_to_create := 1;

  END IF;

  -- Step 3: Create the usesComponent link
  -- Quantity_Used is the Quantity_Needed from needsComponent (which matches child quantity for non-serialized)
  IF v_child_category IN ('Commodity', 'Packaged', 'Serialized') THEN -- Only insert if subtype was handled
      INSERT INTO usesComponent (Parent_IID, Child_IID, Quantity_Used)
      VALUES (17.0, v_new_child_instance_id, ROUND(0.3, 1)); -- Use rounded quantity needed
  END IF;

EXCEPTION
  WHEN OTHERS THEN
    DBMS_OUTPUT.PUT_LINE('Error processing Parent_IID=' || 17.0 || ', Child_PID=' || 242.0 || ': ' || SQLERRM);
    -- Decide if you want to rollback just this block or let the main exception handler catch it
END;
/
DECLARE
  v_new_child_instance_id productInstance.Instance_ID%TYPE;
  v_child_category        product.Category%TYPE := 'Commodity'; -- Pass category
  v_max_existing_batch_lot NUMBER;
  v_next_batch_lot_num   NUMBER;
  v_serial_number        serialized.Serial_Number%TYPE;
  v_batch_number         serialized.Batch_Number%TYPE; -- Shared batch for serialized children of *this* parent
  v_expiration_date      commodity.Expiration_Date%TYPE;
  v_quantity_to_create   commodity.Quantity%TYPE; -- Quantity for the new child instance

BEGIN
  -- Step 1: Create the new child productInstance
  INSERT INTO productInstance (Product_ID, Date_Manufactured, Is_Recalled)
  VALUES (122.0, TIMESTAMP '2024-05-26 03:07:05', 0)
  RETURNING Instance_ID INTO v_new_child_instance_id;

  -- Step 2: Create the corresponding subtype record
  IF v_child_category = 'Commodity' THEN
    -- Find max existing Batch_Number for this specific Child_PID
    SELECT NVL(MAX(c.Batch_Number), 0) INTO v_max_existing_batch_lot
    FROM commodity c JOIN productInstance pi ON c.Instance_ID = pi.Instance_ID
    WHERE pi.Product_ID = 122.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next batch

    v_expiration_date := TIMESTAMP '2024-05-26 03:07:05' + INTERVAL '393' DAY;
    v_quantity_to_create := ROUND(0.3, 1);

    INSERT INTO commodity (Instance_ID, Batch_Number, Expiration_Date, Quantity)
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Packaged' THEN
    -- Find max existing Lot_Number for this specific Child_PID
    SELECT NVL(MAX(p.Lot_Number), 0) INTO v_max_existing_batch_lot
    FROM packaged p JOIN productInstance pi ON p.Instance_ID = pi.Instance_ID -- Assuming 'packaged' table name
    WHERE pi.Product_ID = 122.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next lot

    v_expiration_date := TIMESTAMP '2024-05-26 03:07:05' + INTERVAL '98' DAY;
    v_quantity_to_create := ROUND(0.3, 1);

    INSERT INTO packaged (Instance_ID, Lot_Number, Expiration_Date, Quantity) -- Assuming 'packaged' table name
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Serialized' THEN
    -- Assign a unique serial number
    -- Using Instance ID guarantees uniqueness within this context
    v_serial_number := 'SN-' || TO_CHAR(122.0) || '-' || TO_CHAR(v_new_child_instance_id) || '-' || SUBSTR(SYS_GUID(),1,8);
    -- Assign a batch number - use Product_ID of the *parent* instance as the batch for simplicity? Or a sequence?
    -- Let's use the Parent_IID itself as a simple batch identifier for this run.
    v_batch_number := 18.0; -- All children created FOR this parent get same batch number

    INSERT INTO serialized (Instance_ID, Serial_Number, Batch_Number)
    VALUES (v_new_child_instance_id, v_serial_number, v_batch_number);

    -- Quantity for usesComponent link for serialized is typically 1
    v_quantity_to_create := 1;

  END IF;

  -- Step 3: Create the usesComponent link
  -- Quantity_Used is the Quantity_Needed from needsComponent (which matches child quantity for non-serialized)
  IF v_child_category IN ('Commodity', 'Packaged', 'Serialized') THEN -- Only insert if subtype was handled
      INSERT INTO usesComponent (Parent_IID, Child_IID, Quantity_Used)
      VALUES (18.0, v_new_child_instance_id, ROUND(0.3, 1)); -- Use rounded quantity needed
  END IF;

EXCEPTION
  WHEN OTHERS THEN
    DBMS_OUTPUT.PUT_LINE('Error processing Parent_IID=' || 18.0 || ', Child_PID=' || 122.0 || ': ' || SQLERRM);
    -- Decide if you want to rollback just this block or let the main exception handler catch it
END;
/
DECLARE
  v_new_child_instance_id productInstance.Instance_ID%TYPE;
  v_child_category        product.Category%TYPE := 'Commodity'; -- Pass category
  v_max_existing_batch_lot NUMBER;
  v_next_batch_lot_num   NUMBER;
  v_serial_number        serialized.Serial_Number%TYPE;
  v_batch_number         serialized.Batch_Number%TYPE; -- Shared batch for serialized children of *this* parent
  v_expiration_date      commodity.Expiration_Date%TYPE;
  v_quantity_to_create   commodity.Quantity%TYPE; -- Quantity for the new child instance

BEGIN
  -- Step 1: Create the new child productInstance
  INSERT INTO productInstance (Product_ID, Date_Manufactured, Is_Recalled)
  VALUES (193.0, TIMESTAMP '2025-01-09 03:11:11', 0)
  RETURNING Instance_ID INTO v_new_child_instance_id;

  -- Step 2: Create the corresponding subtype record
  IF v_child_category = 'Commodity' THEN
    -- Find max existing Batch_Number for this specific Child_PID
    SELECT NVL(MAX(c.Batch_Number), 0) INTO v_max_existing_batch_lot
    FROM commodity c JOIN productInstance pi ON c.Instance_ID = pi.Instance_ID
    WHERE pi.Product_ID = 193.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next batch

    v_expiration_date := TIMESTAMP '2025-01-09 03:11:11' + INTERVAL '483' DAY;
    v_quantity_to_create := ROUND(1.4, 1);

    INSERT INTO commodity (Instance_ID, Batch_Number, Expiration_Date, Quantity)
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Packaged' THEN
    -- Find max existing Lot_Number for this specific Child_PID
    SELECT NVL(MAX(p.Lot_Number), 0) INTO v_max_existing_batch_lot
    FROM packaged p JOIN productInstance pi ON p.Instance_ID = pi.Instance_ID -- Assuming 'packaged' table name
    WHERE pi.Product_ID = 193.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next lot

    v_expiration_date := TIMESTAMP '2025-01-09 03:11:11' + INTERVAL '50' DAY;
    v_quantity_to_create := ROUND(1.4, 1);

    INSERT INTO packaged (Instance_ID, Lot_Number, Expiration_Date, Quantity) -- Assuming 'packaged' table name
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Serialized' THEN
    -- Assign a unique serial number
    -- Using Instance ID guarantees uniqueness within this context
    v_serial_number := 'SN-' || TO_CHAR(193.0) || '-' || TO_CHAR(v_new_child_instance_id) || '-' || SUBSTR(SYS_GUID(),1,8);
    -- Assign a batch number - use Product_ID of the *parent* instance as the batch for simplicity? Or a sequence?
    -- Let's use the Parent_IID itself as a simple batch identifier for this run.
    v_batch_number := 18.0; -- All children created FOR this parent get same batch number

    INSERT INTO serialized (Instance_ID, Serial_Number, Batch_Number)
    VALUES (v_new_child_instance_id, v_serial_number, v_batch_number);

    -- Quantity for usesComponent link for serialized is typically 1
    v_quantity_to_create := 1;

  END IF;

  -- Step 3: Create the usesComponent link
  -- Quantity_Used is the Quantity_Needed from needsComponent (which matches child quantity for non-serialized)
  IF v_child_category IN ('Commodity', 'Packaged', 'Serialized') THEN -- Only insert if subtype was handled
      INSERT INTO usesComponent (Parent_IID, Child_IID, Quantity_Used)
      VALUES (18.0, v_new_child_instance_id, ROUND(1.4, 1)); -- Use rounded quantity needed
  END IF;

EXCEPTION
  WHEN OTHERS THEN
    DBMS_OUTPUT.PUT_LINE('Error processing Parent_IID=' || 18.0 || ', Child_PID=' || 193.0 || ': ' || SQLERRM);
    -- Decide if you want to rollback just this block or let the main exception handler catch it
END;
/
DECLARE
  v_new_child_instance_id productInstance.Instance_ID%TYPE;
  v_child_category        product.Category%TYPE := 'Commodity'; -- Pass category
  v_max_existing_batch_lot NUMBER;
  v_next_batch_lot_num   NUMBER;
  v_serial_number        serialized.Serial_Number%TYPE;
  v_batch_number         serialized.Batch_Number%TYPE; -- Shared batch for serialized children of *this* parent
  v_expiration_date      commodity.Expiration_Date%TYPE;
  v_quantity_to_create   commodity.Quantity%TYPE; -- Quantity for the new child instance

BEGIN
  -- Step 1: Create the new child productInstance
  INSERT INTO productInstance (Product_ID, Date_Manufactured, Is_Recalled)
  VALUES (242.0, TIMESTAMP '2024-07-01 18:50:42', 0)
  RETURNING Instance_ID INTO v_new_child_instance_id;

  -- Step 2: Create the corresponding subtype record
  IF v_child_category = 'Commodity' THEN
    -- Find max existing Batch_Number for this specific Child_PID
    SELECT NVL(MAX(c.Batch_Number), 0) INTO v_max_existing_batch_lot
    FROM commodity c JOIN productInstance pi ON c.Instance_ID = pi.Instance_ID
    WHERE pi.Product_ID = 242.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next batch

    v_expiration_date := TIMESTAMP '2024-07-01 18:50:42' + INTERVAL '549' DAY;
    v_quantity_to_create := ROUND(0.3, 1);

    INSERT INTO commodity (Instance_ID, Batch_Number, Expiration_Date, Quantity)
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Packaged' THEN
    -- Find max existing Lot_Number for this specific Child_PID
    SELECT NVL(MAX(p.Lot_Number), 0) INTO v_max_existing_batch_lot
    FROM packaged p JOIN productInstance pi ON p.Instance_ID = pi.Instance_ID -- Assuming 'packaged' table name
    WHERE pi.Product_ID = 242.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next lot

    v_expiration_date := TIMESTAMP '2024-07-01 18:50:42' + INTERVAL '195' DAY;
    v_quantity_to_create := ROUND(0.3, 1);

    INSERT INTO packaged (Instance_ID, Lot_Number, Expiration_Date, Quantity) -- Assuming 'packaged' table name
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Serialized' THEN
    -- Assign a unique serial number
    -- Using Instance ID guarantees uniqueness within this context
    v_serial_number := 'SN-' || TO_CHAR(242.0) || '-' || TO_CHAR(v_new_child_instance_id) || '-' || SUBSTR(SYS_GUID(),1,8);
    -- Assign a batch number - use Product_ID of the *parent* instance as the batch for simplicity? Or a sequence?
    -- Let's use the Parent_IID itself as a simple batch identifier for this run.
    v_batch_number := 18.0; -- All children created FOR this parent get same batch number

    INSERT INTO serialized (Instance_ID, Serial_Number, Batch_Number)
    VALUES (v_new_child_instance_id, v_serial_number, v_batch_number);

    -- Quantity for usesComponent link for serialized is typically 1
    v_quantity_to_create := 1;

  END IF;

  -- Step 3: Create the usesComponent link
  -- Quantity_Used is the Quantity_Needed from needsComponent (which matches child quantity for non-serialized)
  IF v_child_category IN ('Commodity', 'Packaged', 'Serialized') THEN -- Only insert if subtype was handled
      INSERT INTO usesComponent (Parent_IID, Child_IID, Quantity_Used)
      VALUES (18.0, v_new_child_instance_id, ROUND(0.3, 1)); -- Use rounded quantity needed
  END IF;

EXCEPTION
  WHEN OTHERS THEN
    DBMS_OUTPUT.PUT_LINE('Error processing Parent_IID=' || 18.0 || ', Child_PID=' || 242.0 || ': ' || SQLERRM);
    -- Decide if you want to rollback just this block or let the main exception handler catch it
END;
/
DECLARE
  v_new_child_instance_id productInstance.Instance_ID%TYPE;
  v_child_category        product.Category%TYPE := 'Commodity'; -- Pass category
  v_max_existing_batch_lot NUMBER;
  v_next_batch_lot_num   NUMBER;
  v_serial_number        serialized.Serial_Number%TYPE;
  v_batch_number         serialized.Batch_Number%TYPE; -- Shared batch for serialized children of *this* parent
  v_expiration_date      commodity.Expiration_Date%TYPE;
  v_quantity_to_create   commodity.Quantity%TYPE; -- Quantity for the new child instance

BEGIN
  -- Step 1: Create the new child productInstance
  INSERT INTO productInstance (Product_ID, Date_Manufactured, Is_Recalled)
  VALUES (122.0, TIMESTAMP '2025-01-22 04:23:56', 0)
  RETURNING Instance_ID INTO v_new_child_instance_id;

  -- Step 2: Create the corresponding subtype record
  IF v_child_category = 'Commodity' THEN
    -- Find max existing Batch_Number for this specific Child_PID
    SELECT NVL(MAX(c.Batch_Number), 0) INTO v_max_existing_batch_lot
    FROM commodity c JOIN productInstance pi ON c.Instance_ID = pi.Instance_ID
    WHERE pi.Product_ID = 122.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next batch

    v_expiration_date := TIMESTAMP '2025-01-22 04:23:56' + INTERVAL '125' DAY;
    v_quantity_to_create := ROUND(0.3, 1);

    INSERT INTO commodity (Instance_ID, Batch_Number, Expiration_Date, Quantity)
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Packaged' THEN
    -- Find max existing Lot_Number for this specific Child_PID
    SELECT NVL(MAX(p.Lot_Number), 0) INTO v_max_existing_batch_lot
    FROM packaged p JOIN productInstance pi ON p.Instance_ID = pi.Instance_ID -- Assuming 'packaged' table name
    WHERE pi.Product_ID = 122.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next lot

    v_expiration_date := TIMESTAMP '2025-01-22 04:23:56' + INTERVAL '441' DAY;
    v_quantity_to_create := ROUND(0.3, 1);

    INSERT INTO packaged (Instance_ID, Lot_Number, Expiration_Date, Quantity) -- Assuming 'packaged' table name
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Serialized' THEN
    -- Assign a unique serial number
    -- Using Instance ID guarantees uniqueness within this context
    v_serial_number := 'SN-' || TO_CHAR(122.0) || '-' || TO_CHAR(v_new_child_instance_id) || '-' || SUBSTR(SYS_GUID(),1,8);
    -- Assign a batch number - use Product_ID of the *parent* instance as the batch for simplicity? Or a sequence?
    -- Let's use the Parent_IID itself as a simple batch identifier for this run.
    v_batch_number := 19.0; -- All children created FOR this parent get same batch number

    INSERT INTO serialized (Instance_ID, Serial_Number, Batch_Number)
    VALUES (v_new_child_instance_id, v_serial_number, v_batch_number);

    -- Quantity for usesComponent link for serialized is typically 1
    v_quantity_to_create := 1;

  END IF;

  -- Step 3: Create the usesComponent link
  -- Quantity_Used is the Quantity_Needed from needsComponent (which matches child quantity for non-serialized)
  IF v_child_category IN ('Commodity', 'Packaged', 'Serialized') THEN -- Only insert if subtype was handled
      INSERT INTO usesComponent (Parent_IID, Child_IID, Quantity_Used)
      VALUES (19.0, v_new_child_instance_id, ROUND(0.3, 1)); -- Use rounded quantity needed
  END IF;

EXCEPTION
  WHEN OTHERS THEN
    DBMS_OUTPUT.PUT_LINE('Error processing Parent_IID=' || 19.0 || ', Child_PID=' || 122.0 || ': ' || SQLERRM);
    -- Decide if you want to rollback just this block or let the main exception handler catch it
END;
/
DECLARE
  v_new_child_instance_id productInstance.Instance_ID%TYPE;
  v_child_category        product.Category%TYPE := 'Commodity'; -- Pass category
  v_max_existing_batch_lot NUMBER;
  v_next_batch_lot_num   NUMBER;
  v_serial_number        serialized.Serial_Number%TYPE;
  v_batch_number         serialized.Batch_Number%TYPE; -- Shared batch for serialized children of *this* parent
  v_expiration_date      commodity.Expiration_Date%TYPE;
  v_quantity_to_create   commodity.Quantity%TYPE; -- Quantity for the new child instance

BEGIN
  -- Step 1: Create the new child productInstance
  INSERT INTO productInstance (Product_ID, Date_Manufactured, Is_Recalled)
  VALUES (193.0, TIMESTAMP '2025-01-01 00:39:15', 0)
  RETURNING Instance_ID INTO v_new_child_instance_id;

  -- Step 2: Create the corresponding subtype record
  IF v_child_category = 'Commodity' THEN
    -- Find max existing Batch_Number for this specific Child_PID
    SELECT NVL(MAX(c.Batch_Number), 0) INTO v_max_existing_batch_lot
    FROM commodity c JOIN productInstance pi ON c.Instance_ID = pi.Instance_ID
    WHERE pi.Product_ID = 193.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next batch

    v_expiration_date := TIMESTAMP '2025-01-01 00:39:15' + INTERVAL '312' DAY;
    v_quantity_to_create := ROUND(1.4, 1);

    INSERT INTO commodity (Instance_ID, Batch_Number, Expiration_Date, Quantity)
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Packaged' THEN
    -- Find max existing Lot_Number for this specific Child_PID
    SELECT NVL(MAX(p.Lot_Number), 0) INTO v_max_existing_batch_lot
    FROM packaged p JOIN productInstance pi ON p.Instance_ID = pi.Instance_ID -- Assuming 'packaged' table name
    WHERE pi.Product_ID = 193.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next lot

    v_expiration_date := TIMESTAMP '2025-01-01 00:39:15' + INTERVAL '649' DAY;
    v_quantity_to_create := ROUND(1.4, 1);

    INSERT INTO packaged (Instance_ID, Lot_Number, Expiration_Date, Quantity) -- Assuming 'packaged' table name
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Serialized' THEN
    -- Assign a unique serial number
    -- Using Instance ID guarantees uniqueness within this context
    v_serial_number := 'SN-' || TO_CHAR(193.0) || '-' || TO_CHAR(v_new_child_instance_id) || '-' || SUBSTR(SYS_GUID(),1,8);
    -- Assign a batch number - use Product_ID of the *parent* instance as the batch for simplicity? Or a sequence?
    -- Let's use the Parent_IID itself as a simple batch identifier for this run.
    v_batch_number := 19.0; -- All children created FOR this parent get same batch number

    INSERT INTO serialized (Instance_ID, Serial_Number, Batch_Number)
    VALUES (v_new_child_instance_id, v_serial_number, v_batch_number);

    -- Quantity for usesComponent link for serialized is typically 1
    v_quantity_to_create := 1;

  END IF;

  -- Step 3: Create the usesComponent link
  -- Quantity_Used is the Quantity_Needed from needsComponent (which matches child quantity for non-serialized)
  IF v_child_category IN ('Commodity', 'Packaged', 'Serialized') THEN -- Only insert if subtype was handled
      INSERT INTO usesComponent (Parent_IID, Child_IID, Quantity_Used)
      VALUES (19.0, v_new_child_instance_id, ROUND(1.4, 1)); -- Use rounded quantity needed
  END IF;

EXCEPTION
  WHEN OTHERS THEN
    DBMS_OUTPUT.PUT_LINE('Error processing Parent_IID=' || 19.0 || ', Child_PID=' || 193.0 || ': ' || SQLERRM);
    -- Decide if you want to rollback just this block or let the main exception handler catch it
END;
/
DECLARE
  v_new_child_instance_id productInstance.Instance_ID%TYPE;
  v_child_category        product.Category%TYPE := 'Commodity'; -- Pass category
  v_max_existing_batch_lot NUMBER;
  v_next_batch_lot_num   NUMBER;
  v_serial_number        serialized.Serial_Number%TYPE;
  v_batch_number         serialized.Batch_Number%TYPE; -- Shared batch for serialized children of *this* parent
  v_expiration_date      commodity.Expiration_Date%TYPE;
  v_quantity_to_create   commodity.Quantity%TYPE; -- Quantity for the new child instance

BEGIN
  -- Step 1: Create the new child productInstance
  INSERT INTO productInstance (Product_ID, Date_Manufactured, Is_Recalled)
  VALUES (242.0, TIMESTAMP '2024-08-25 06:12:19', 0)
  RETURNING Instance_ID INTO v_new_child_instance_id;

  -- Step 2: Create the corresponding subtype record
  IF v_child_category = 'Commodity' THEN
    -- Find max existing Batch_Number for this specific Child_PID
    SELECT NVL(MAX(c.Batch_Number), 0) INTO v_max_existing_batch_lot
    FROM commodity c JOIN productInstance pi ON c.Instance_ID = pi.Instance_ID
    WHERE pi.Product_ID = 242.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next batch

    v_expiration_date := TIMESTAMP '2024-08-25 06:12:19' + INTERVAL '243' DAY;
    v_quantity_to_create := ROUND(0.3, 1);

    INSERT INTO commodity (Instance_ID, Batch_Number, Expiration_Date, Quantity)
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Packaged' THEN
    -- Find max existing Lot_Number for this specific Child_PID
    SELECT NVL(MAX(p.Lot_Number), 0) INTO v_max_existing_batch_lot
    FROM packaged p JOIN productInstance pi ON p.Instance_ID = pi.Instance_ID -- Assuming 'packaged' table name
    WHERE pi.Product_ID = 242.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next lot

    v_expiration_date := TIMESTAMP '2024-08-25 06:12:19' + INTERVAL '570' DAY;
    v_quantity_to_create := ROUND(0.3, 1);

    INSERT INTO packaged (Instance_ID, Lot_Number, Expiration_Date, Quantity) -- Assuming 'packaged' table name
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Serialized' THEN
    -- Assign a unique serial number
    -- Using Instance ID guarantees uniqueness within this context
    v_serial_number := 'SN-' || TO_CHAR(242.0) || '-' || TO_CHAR(v_new_child_instance_id) || '-' || SUBSTR(SYS_GUID(),1,8);
    -- Assign a batch number - use Product_ID of the *parent* instance as the batch for simplicity? Or a sequence?
    -- Let's use the Parent_IID itself as a simple batch identifier for this run.
    v_batch_number := 19.0; -- All children created FOR this parent get same batch number

    INSERT INTO serialized (Instance_ID, Serial_Number, Batch_Number)
    VALUES (v_new_child_instance_id, v_serial_number, v_batch_number);

    -- Quantity for usesComponent link for serialized is typically 1
    v_quantity_to_create := 1;

  END IF;

  -- Step 3: Create the usesComponent link
  -- Quantity_Used is the Quantity_Needed from needsComponent (which matches child quantity for non-serialized)
  IF v_child_category IN ('Commodity', 'Packaged', 'Serialized') THEN -- Only insert if subtype was handled
      INSERT INTO usesComponent (Parent_IID, Child_IID, Quantity_Used)
      VALUES (19.0, v_new_child_instance_id, ROUND(0.3, 1)); -- Use rounded quantity needed
  END IF;

EXCEPTION
  WHEN OTHERS THEN
    DBMS_OUTPUT.PUT_LINE('Error processing Parent_IID=' || 19.0 || ', Child_PID=' || 242.0 || ': ' || SQLERRM);
    -- Decide if you want to rollback just this block or let the main exception handler catch it
END;
/
DECLARE
  v_new_child_instance_id productInstance.Instance_ID%TYPE;
  v_child_category        product.Category%TYPE := 'Commodity'; -- Pass category
  v_max_existing_batch_lot NUMBER;
  v_next_batch_lot_num   NUMBER;
  v_serial_number        serialized.Serial_Number%TYPE;
  v_batch_number         serialized.Batch_Number%TYPE; -- Shared batch for serialized children of *this* parent
  v_expiration_date      commodity.Expiration_Date%TYPE;
  v_quantity_to_create   commodity.Quantity%TYPE; -- Quantity for the new child instance

BEGIN
  -- Step 1: Create the new child productInstance
  INSERT INTO productInstance (Product_ID, Date_Manufactured, Is_Recalled)
  VALUES (102.0, TIMESTAMP '2024-07-18 16:56:35', 0)
  RETURNING Instance_ID INTO v_new_child_instance_id;

  -- Step 2: Create the corresponding subtype record
  IF v_child_category = 'Commodity' THEN
    -- Find max existing Batch_Number for this specific Child_PID
    SELECT NVL(MAX(c.Batch_Number), 0) INTO v_max_existing_batch_lot
    FROM commodity c JOIN productInstance pi ON c.Instance_ID = pi.Instance_ID
    WHERE pi.Product_ID = 102.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next batch

    v_expiration_date := TIMESTAMP '2024-07-18 16:56:35' + INTERVAL '272' DAY;
    v_quantity_to_create := ROUND(1.1, 1);

    INSERT INTO commodity (Instance_ID, Batch_Number, Expiration_Date, Quantity)
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Packaged' THEN
    -- Find max existing Lot_Number for this specific Child_PID
    SELECT NVL(MAX(p.Lot_Number), 0) INTO v_max_existing_batch_lot
    FROM packaged p JOIN productInstance pi ON p.Instance_ID = pi.Instance_ID -- Assuming 'packaged' table name
    WHERE pi.Product_ID = 102.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next lot

    v_expiration_date := TIMESTAMP '2024-07-18 16:56:35' + INTERVAL '371' DAY;
    v_quantity_to_create := ROUND(1.1, 1);

    INSERT INTO packaged (Instance_ID, Lot_Number, Expiration_Date, Quantity) -- Assuming 'packaged' table name
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Serialized' THEN
    -- Assign a unique serial number
    -- Using Instance ID guarantees uniqueness within this context
    v_serial_number := 'SN-' || TO_CHAR(102.0) || '-' || TO_CHAR(v_new_child_instance_id) || '-' || SUBSTR(SYS_GUID(),1,8);
    -- Assign a batch number - use Product_ID of the *parent* instance as the batch for simplicity? Or a sequence?
    -- Let's use the Parent_IID itself as a simple batch identifier for this run.
    v_batch_number := 23.0; -- All children created FOR this parent get same batch number

    INSERT INTO serialized (Instance_ID, Serial_Number, Batch_Number)
    VALUES (v_new_child_instance_id, v_serial_number, v_batch_number);

    -- Quantity for usesComponent link for serialized is typically 1
    v_quantity_to_create := 1;

  END IF;

  -- Step 3: Create the usesComponent link
  -- Quantity_Used is the Quantity_Needed from needsComponent (which matches child quantity for non-serialized)
  IF v_child_category IN ('Commodity', 'Packaged', 'Serialized') THEN -- Only insert if subtype was handled
      INSERT INTO usesComponent (Parent_IID, Child_IID, Quantity_Used)
      VALUES (23.0, v_new_child_instance_id, ROUND(1.1, 1)); -- Use rounded quantity needed
  END IF;

EXCEPTION
  WHEN OTHERS THEN
    DBMS_OUTPUT.PUT_LINE('Error processing Parent_IID=' || 23.0 || ', Child_PID=' || 102.0 || ': ' || SQLERRM);
    -- Decide if you want to rollback just this block or let the main exception handler catch it
END;
/
DECLARE
  v_new_child_instance_id productInstance.Instance_ID%TYPE;
  v_child_category        product.Category%TYPE := 'Commodity'; -- Pass category
  v_max_existing_batch_lot NUMBER;
  v_next_batch_lot_num   NUMBER;
  v_serial_number        serialized.Serial_Number%TYPE;
  v_batch_number         serialized.Batch_Number%TYPE; -- Shared batch for serialized children of *this* parent
  v_expiration_date      commodity.Expiration_Date%TYPE;
  v_quantity_to_create   commodity.Quantity%TYPE; -- Quantity for the new child instance

BEGIN
  -- Step 1: Create the new child productInstance
  INSERT INTO productInstance (Product_ID, Date_Manufactured, Is_Recalled)
  VALUES (189.0, TIMESTAMP '2024-08-11 12:52:04', 0)
  RETURNING Instance_ID INTO v_new_child_instance_id;

  -- Step 2: Create the corresponding subtype record
  IF v_child_category = 'Commodity' THEN
    -- Find max existing Batch_Number for this specific Child_PID
    SELECT NVL(MAX(c.Batch_Number), 0) INTO v_max_existing_batch_lot
    FROM commodity c JOIN productInstance pi ON c.Instance_ID = pi.Instance_ID
    WHERE pi.Product_ID = 189.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next batch

    v_expiration_date := TIMESTAMP '2024-08-11 12:52:04' + INTERVAL '100' DAY;
    v_quantity_to_create := ROUND(0.5, 1);

    INSERT INTO commodity (Instance_ID, Batch_Number, Expiration_Date, Quantity)
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Packaged' THEN
    -- Find max existing Lot_Number for this specific Child_PID
    SELECT NVL(MAX(p.Lot_Number), 0) INTO v_max_existing_batch_lot
    FROM packaged p JOIN productInstance pi ON p.Instance_ID = pi.Instance_ID -- Assuming 'packaged' table name
    WHERE pi.Product_ID = 189.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next lot

    v_expiration_date := TIMESTAMP '2024-08-11 12:52:04' + INTERVAL '106' DAY;
    v_quantity_to_create := ROUND(0.5, 1);

    INSERT INTO packaged (Instance_ID, Lot_Number, Expiration_Date, Quantity) -- Assuming 'packaged' table name
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Serialized' THEN
    -- Assign a unique serial number
    -- Using Instance ID guarantees uniqueness within this context
    v_serial_number := 'SN-' || TO_CHAR(189.0) || '-' || TO_CHAR(v_new_child_instance_id) || '-' || SUBSTR(SYS_GUID(),1,8);
    -- Assign a batch number - use Product_ID of the *parent* instance as the batch for simplicity? Or a sequence?
    -- Let's use the Parent_IID itself as a simple batch identifier for this run.
    v_batch_number := 23.0; -- All children created FOR this parent get same batch number

    INSERT INTO serialized (Instance_ID, Serial_Number, Batch_Number)
    VALUES (v_new_child_instance_id, v_serial_number, v_batch_number);

    -- Quantity for usesComponent link for serialized is typically 1
    v_quantity_to_create := 1;

  END IF;

  -- Step 3: Create the usesComponent link
  -- Quantity_Used is the Quantity_Needed from needsComponent (which matches child quantity for non-serialized)
  IF v_child_category IN ('Commodity', 'Packaged', 'Serialized') THEN -- Only insert if subtype was handled
      INSERT INTO usesComponent (Parent_IID, Child_IID, Quantity_Used)
      VALUES (23.0, v_new_child_instance_id, ROUND(0.5, 1)); -- Use rounded quantity needed
  END IF;

EXCEPTION
  WHEN OTHERS THEN
    DBMS_OUTPUT.PUT_LINE('Error processing Parent_IID=' || 23.0 || ', Child_PID=' || 189.0 || ': ' || SQLERRM);
    -- Decide if you want to rollback just this block or let the main exception handler catch it
END;
/
DECLARE
  v_new_child_instance_id productInstance.Instance_ID%TYPE;
  v_child_category        product.Category%TYPE := 'Commodity'; -- Pass category
  v_max_existing_batch_lot NUMBER;
  v_next_batch_lot_num   NUMBER;
  v_serial_number        serialized.Serial_Number%TYPE;
  v_batch_number         serialized.Batch_Number%TYPE; -- Shared batch for serialized children of *this* parent
  v_expiration_date      commodity.Expiration_Date%TYPE;
  v_quantity_to_create   commodity.Quantity%TYPE; -- Quantity for the new child instance

BEGIN
  -- Step 1: Create the new child productInstance
  INSERT INTO productInstance (Product_ID, Date_Manufactured, Is_Recalled)
  VALUES (158.0, TIMESTAMP '2025-01-25 13:55:52', 0)
  RETURNING Instance_ID INTO v_new_child_instance_id;

  -- Step 2: Create the corresponding subtype record
  IF v_child_category = 'Commodity' THEN
    -- Find max existing Batch_Number for this specific Child_PID
    SELECT NVL(MAX(c.Batch_Number), 0) INTO v_max_existing_batch_lot
    FROM commodity c JOIN productInstance pi ON c.Instance_ID = pi.Instance_ID
    WHERE pi.Product_ID = 158.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next batch

    v_expiration_date := TIMESTAMP '2025-01-25 13:55:52' + INTERVAL '565' DAY;
    v_quantity_to_create := ROUND(2.0, 1);

    INSERT INTO commodity (Instance_ID, Batch_Number, Expiration_Date, Quantity)
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Packaged' THEN
    -- Find max existing Lot_Number for this specific Child_PID
    SELECT NVL(MAX(p.Lot_Number), 0) INTO v_max_existing_batch_lot
    FROM packaged p JOIN productInstance pi ON p.Instance_ID = pi.Instance_ID -- Assuming 'packaged' table name
    WHERE pi.Product_ID = 158.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next lot

    v_expiration_date := TIMESTAMP '2025-01-25 13:55:52' + INTERVAL '704' DAY;
    v_quantity_to_create := ROUND(2.0, 1);

    INSERT INTO packaged (Instance_ID, Lot_Number, Expiration_Date, Quantity) -- Assuming 'packaged' table name
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Serialized' THEN
    -- Assign a unique serial number
    -- Using Instance ID guarantees uniqueness within this context
    v_serial_number := 'SN-' || TO_CHAR(158.0) || '-' || TO_CHAR(v_new_child_instance_id) || '-' || SUBSTR(SYS_GUID(),1,8);
    -- Assign a batch number - use Product_ID of the *parent* instance as the batch for simplicity? Or a sequence?
    -- Let's use the Parent_IID itself as a simple batch identifier for this run.
    v_batch_number := 23.0; -- All children created FOR this parent get same batch number

    INSERT INTO serialized (Instance_ID, Serial_Number, Batch_Number)
    VALUES (v_new_child_instance_id, v_serial_number, v_batch_number);

    -- Quantity for usesComponent link for serialized is typically 1
    v_quantity_to_create := 1;

  END IF;

  -- Step 3: Create the usesComponent link
  -- Quantity_Used is the Quantity_Needed from needsComponent (which matches child quantity for non-serialized)
  IF v_child_category IN ('Commodity', 'Packaged', 'Serialized') THEN -- Only insert if subtype was handled
      INSERT INTO usesComponent (Parent_IID, Child_IID, Quantity_Used)
      VALUES (23.0, v_new_child_instance_id, ROUND(2.0, 1)); -- Use rounded quantity needed
  END IF;

EXCEPTION
  WHEN OTHERS THEN
    DBMS_OUTPUT.PUT_LINE('Error processing Parent_IID=' || 23.0 || ', Child_PID=' || 158.0 || ': ' || SQLERRM);
    -- Decide if you want to rollback just this block or let the main exception handler catch it
END;
/
DECLARE
  v_new_child_instance_id productInstance.Instance_ID%TYPE;
  v_child_category        product.Category%TYPE := 'Commodity'; -- Pass category
  v_max_existing_batch_lot NUMBER;
  v_next_batch_lot_num   NUMBER;
  v_serial_number        serialized.Serial_Number%TYPE;
  v_batch_number         serialized.Batch_Number%TYPE; -- Shared batch for serialized children of *this* parent
  v_expiration_date      commodity.Expiration_Date%TYPE;
  v_quantity_to_create   commodity.Quantity%TYPE; -- Quantity for the new child instance

BEGIN
  -- Step 1: Create the new child productInstance
  INSERT INTO productInstance (Product_ID, Date_Manufactured, Is_Recalled)
  VALUES (130.0, TIMESTAMP '2024-09-19 00:54:35', 0)
  RETURNING Instance_ID INTO v_new_child_instance_id;

  -- Step 2: Create the corresponding subtype record
  IF v_child_category = 'Commodity' THEN
    -- Find max existing Batch_Number for this specific Child_PID
    SELECT NVL(MAX(c.Batch_Number), 0) INTO v_max_existing_batch_lot
    FROM commodity c JOIN productInstance pi ON c.Instance_ID = pi.Instance_ID
    WHERE pi.Product_ID = 130.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next batch

    v_expiration_date := TIMESTAMP '2024-09-19 00:54:35' + INTERVAL '509' DAY;
    v_quantity_to_create := ROUND(1.6, 1);

    INSERT INTO commodity (Instance_ID, Batch_Number, Expiration_Date, Quantity)
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Packaged' THEN
    -- Find max existing Lot_Number for this specific Child_PID
    SELECT NVL(MAX(p.Lot_Number), 0) INTO v_max_existing_batch_lot
    FROM packaged p JOIN productInstance pi ON p.Instance_ID = pi.Instance_ID -- Assuming 'packaged' table name
    WHERE pi.Product_ID = 130.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next lot

    v_expiration_date := TIMESTAMP '2024-09-19 00:54:35' + INTERVAL '553' DAY;
    v_quantity_to_create := ROUND(1.6, 1);

    INSERT INTO packaged (Instance_ID, Lot_Number, Expiration_Date, Quantity) -- Assuming 'packaged' table name
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Serialized' THEN
    -- Assign a unique serial number
    -- Using Instance ID guarantees uniqueness within this context
    v_serial_number := 'SN-' || TO_CHAR(130.0) || '-' || TO_CHAR(v_new_child_instance_id) || '-' || SUBSTR(SYS_GUID(),1,8);
    -- Assign a batch number - use Product_ID of the *parent* instance as the batch for simplicity? Or a sequence?
    -- Let's use the Parent_IID itself as a simple batch identifier for this run.
    v_batch_number := 23.0; -- All children created FOR this parent get same batch number

    INSERT INTO serialized (Instance_ID, Serial_Number, Batch_Number)
    VALUES (v_new_child_instance_id, v_serial_number, v_batch_number);

    -- Quantity for usesComponent link for serialized is typically 1
    v_quantity_to_create := 1;

  END IF;

  -- Step 3: Create the usesComponent link
  -- Quantity_Used is the Quantity_Needed from needsComponent (which matches child quantity for non-serialized)
  IF v_child_category IN ('Commodity', 'Packaged', 'Serialized') THEN -- Only insert if subtype was handled
      INSERT INTO usesComponent (Parent_IID, Child_IID, Quantity_Used)
      VALUES (23.0, v_new_child_instance_id, ROUND(1.6, 1)); -- Use rounded quantity needed
  END IF;

EXCEPTION
  WHEN OTHERS THEN
    DBMS_OUTPUT.PUT_LINE('Error processing Parent_IID=' || 23.0 || ', Child_PID=' || 130.0 || ': ' || SQLERRM);
    -- Decide if you want to rollback just this block or let the main exception handler catch it
END;
/
DECLARE
  v_new_child_instance_id productInstance.Instance_ID%TYPE;
  v_child_category        product.Category%TYPE := 'Commodity'; -- Pass category
  v_max_existing_batch_lot NUMBER;
  v_next_batch_lot_num   NUMBER;
  v_serial_number        serialized.Serial_Number%TYPE;
  v_batch_number         serialized.Batch_Number%TYPE; -- Shared batch for serialized children of *this* parent
  v_expiration_date      commodity.Expiration_Date%TYPE;
  v_quantity_to_create   commodity.Quantity%TYPE; -- Quantity for the new child instance

BEGIN
  -- Step 1: Create the new child productInstance
  INSERT INTO productInstance (Product_ID, Date_Manufactured, Is_Recalled)
  VALUES (109.0, TIMESTAMP '2024-12-01 14:38:40', 0)
  RETURNING Instance_ID INTO v_new_child_instance_id;

  -- Step 2: Create the corresponding subtype record
  IF v_child_category = 'Commodity' THEN
    -- Find max existing Batch_Number for this specific Child_PID
    SELECT NVL(MAX(c.Batch_Number), 0) INTO v_max_existing_batch_lot
    FROM commodity c JOIN productInstance pi ON c.Instance_ID = pi.Instance_ID
    WHERE pi.Product_ID = 109.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next batch

    v_expiration_date := TIMESTAMP '2024-12-01 14:38:40' + INTERVAL '80' DAY;
    v_quantity_to_create := ROUND(0.5, 1);

    INSERT INTO commodity (Instance_ID, Batch_Number, Expiration_Date, Quantity)
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Packaged' THEN
    -- Find max existing Lot_Number for this specific Child_PID
    SELECT NVL(MAX(p.Lot_Number), 0) INTO v_max_existing_batch_lot
    FROM packaged p JOIN productInstance pi ON p.Instance_ID = pi.Instance_ID -- Assuming 'packaged' table name
    WHERE pi.Product_ID = 109.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next lot

    v_expiration_date := TIMESTAMP '2024-12-01 14:38:40' + INTERVAL '202' DAY;
    v_quantity_to_create := ROUND(0.5, 1);

    INSERT INTO packaged (Instance_ID, Lot_Number, Expiration_Date, Quantity) -- Assuming 'packaged' table name
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Serialized' THEN
    -- Assign a unique serial number
    -- Using Instance ID guarantees uniqueness within this context
    v_serial_number := 'SN-' || TO_CHAR(109.0) || '-' || TO_CHAR(v_new_child_instance_id) || '-' || SUBSTR(SYS_GUID(),1,8);
    -- Assign a batch number - use Product_ID of the *parent* instance as the batch for simplicity? Or a sequence?
    -- Let's use the Parent_IID itself as a simple batch identifier for this run.
    v_batch_number := 70.0; -- All children created FOR this parent get same batch number

    INSERT INTO serialized (Instance_ID, Serial_Number, Batch_Number)
    VALUES (v_new_child_instance_id, v_serial_number, v_batch_number);

    -- Quantity for usesComponent link for serialized is typically 1
    v_quantity_to_create := 1;

  END IF;

  -- Step 3: Create the usesComponent link
  -- Quantity_Used is the Quantity_Needed from needsComponent (which matches child quantity for non-serialized)
  IF v_child_category IN ('Commodity', 'Packaged', 'Serialized') THEN -- Only insert if subtype was handled
      INSERT INTO usesComponent (Parent_IID, Child_IID, Quantity_Used)
      VALUES (70.0, v_new_child_instance_id, ROUND(0.5, 1)); -- Use rounded quantity needed
  END IF;

EXCEPTION
  WHEN OTHERS THEN
    DBMS_OUTPUT.PUT_LINE('Error processing Parent_IID=' || 70.0 || ', Child_PID=' || 109.0 || ': ' || SQLERRM);
    -- Decide if you want to rollback just this block or let the main exception handler catch it
END;
/
DECLARE
  v_new_child_instance_id productInstance.Instance_ID%TYPE;
  v_child_category        product.Category%TYPE := 'Commodity'; -- Pass category
  v_max_existing_batch_lot NUMBER;
  v_next_batch_lot_num   NUMBER;
  v_serial_number        serialized.Serial_Number%TYPE;
  v_batch_number         serialized.Batch_Number%TYPE; -- Shared batch for serialized children of *this* parent
  v_expiration_date      commodity.Expiration_Date%TYPE;
  v_quantity_to_create   commodity.Quantity%TYPE; -- Quantity for the new child instance

BEGIN
  -- Step 1: Create the new child productInstance
  INSERT INTO productInstance (Product_ID, Date_Manufactured, Is_Recalled)
  VALUES (232.0, TIMESTAMP '2024-08-22 08:02:54', 0)
  RETURNING Instance_ID INTO v_new_child_instance_id;

  -- Step 2: Create the corresponding subtype record
  IF v_child_category = 'Commodity' THEN
    -- Find max existing Batch_Number for this specific Child_PID
    SELECT NVL(MAX(c.Batch_Number), 0) INTO v_max_existing_batch_lot
    FROM commodity c JOIN productInstance pi ON c.Instance_ID = pi.Instance_ID
    WHERE pi.Product_ID = 232.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next batch

    v_expiration_date := TIMESTAMP '2024-08-22 08:02:54' + INTERVAL '698' DAY;
    v_quantity_to_create := ROUND(1.3, 1);

    INSERT INTO commodity (Instance_ID, Batch_Number, Expiration_Date, Quantity)
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Packaged' THEN
    -- Find max existing Lot_Number for this specific Child_PID
    SELECT NVL(MAX(p.Lot_Number), 0) INTO v_max_existing_batch_lot
    FROM packaged p JOIN productInstance pi ON p.Instance_ID = pi.Instance_ID -- Assuming 'packaged' table name
    WHERE pi.Product_ID = 232.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next lot

    v_expiration_date := TIMESTAMP '2024-08-22 08:02:54' + INTERVAL '599' DAY;
    v_quantity_to_create := ROUND(1.3, 1);

    INSERT INTO packaged (Instance_ID, Lot_Number, Expiration_Date, Quantity) -- Assuming 'packaged' table name
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Serialized' THEN
    -- Assign a unique serial number
    -- Using Instance ID guarantees uniqueness within this context
    v_serial_number := 'SN-' || TO_CHAR(232.0) || '-' || TO_CHAR(v_new_child_instance_id) || '-' || SUBSTR(SYS_GUID(),1,8);
    -- Assign a batch number - use Product_ID of the *parent* instance as the batch for simplicity? Or a sequence?
    -- Let's use the Parent_IID itself as a simple batch identifier for this run.
    v_batch_number := 70.0; -- All children created FOR this parent get same batch number

    INSERT INTO serialized (Instance_ID, Serial_Number, Batch_Number)
    VALUES (v_new_child_instance_id, v_serial_number, v_batch_number);

    -- Quantity for usesComponent link for serialized is typically 1
    v_quantity_to_create := 1;

  END IF;

  -- Step 3: Create the usesComponent link
  -- Quantity_Used is the Quantity_Needed from needsComponent (which matches child quantity for non-serialized)
  IF v_child_category IN ('Commodity', 'Packaged', 'Serialized') THEN -- Only insert if subtype was handled
      INSERT INTO usesComponent (Parent_IID, Child_IID, Quantity_Used)
      VALUES (70.0, v_new_child_instance_id, ROUND(1.3, 1)); -- Use rounded quantity needed
  END IF;

EXCEPTION
  WHEN OTHERS THEN
    DBMS_OUTPUT.PUT_LINE('Error processing Parent_IID=' || 70.0 || ', Child_PID=' || 232.0 || ': ' || SQLERRM);
    -- Decide if you want to rollback just this block or let the main exception handler catch it
END;
/
DECLARE
  v_new_child_instance_id productInstance.Instance_ID%TYPE;
  v_child_category        product.Category%TYPE := 'Commodity'; -- Pass category
  v_max_existing_batch_lot NUMBER;
  v_next_batch_lot_num   NUMBER;
  v_serial_number        serialized.Serial_Number%TYPE;
  v_batch_number         serialized.Batch_Number%TYPE; -- Shared batch for serialized children of *this* parent
  v_expiration_date      commodity.Expiration_Date%TYPE;
  v_quantity_to_create   commodity.Quantity%TYPE; -- Quantity for the new child instance

BEGIN
  -- Step 1: Create the new child productInstance
  INSERT INTO productInstance (Product_ID, Date_Manufactured, Is_Recalled)
  VALUES (106.0, TIMESTAMP '2024-08-11 19:18:44', 0)
  RETURNING Instance_ID INTO v_new_child_instance_id;

  -- Step 2: Create the corresponding subtype record
  IF v_child_category = 'Commodity' THEN
    -- Find max existing Batch_Number for this specific Child_PID
    SELECT NVL(MAX(c.Batch_Number), 0) INTO v_max_existing_batch_lot
    FROM commodity c JOIN productInstance pi ON c.Instance_ID = pi.Instance_ID
    WHERE pi.Product_ID = 106.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next batch

    v_expiration_date := TIMESTAMP '2024-08-11 19:18:44' + INTERVAL '394' DAY;
    v_quantity_to_create := ROUND(0.9, 1);

    INSERT INTO commodity (Instance_ID, Batch_Number, Expiration_Date, Quantity)
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Packaged' THEN
    -- Find max existing Lot_Number for this specific Child_PID
    SELECT NVL(MAX(p.Lot_Number), 0) INTO v_max_existing_batch_lot
    FROM packaged p JOIN productInstance pi ON p.Instance_ID = pi.Instance_ID -- Assuming 'packaged' table name
    WHERE pi.Product_ID = 106.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next lot

    v_expiration_date := TIMESTAMP '2024-08-11 19:18:44' + INTERVAL '654' DAY;
    v_quantity_to_create := ROUND(0.9, 1);

    INSERT INTO packaged (Instance_ID, Lot_Number, Expiration_Date, Quantity) -- Assuming 'packaged' table name
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Serialized' THEN
    -- Assign a unique serial number
    -- Using Instance ID guarantees uniqueness within this context
    v_serial_number := 'SN-' || TO_CHAR(106.0) || '-' || TO_CHAR(v_new_child_instance_id) || '-' || SUBSTR(SYS_GUID(),1,8);
    -- Assign a batch number - use Product_ID of the *parent* instance as the batch for simplicity? Or a sequence?
    -- Let's use the Parent_IID itself as a simple batch identifier for this run.
    v_batch_number := 70.0; -- All children created FOR this parent get same batch number

    INSERT INTO serialized (Instance_ID, Serial_Number, Batch_Number)
    VALUES (v_new_child_instance_id, v_serial_number, v_batch_number);

    -- Quantity for usesComponent link for serialized is typically 1
    v_quantity_to_create := 1;

  END IF;

  -- Step 3: Create the usesComponent link
  -- Quantity_Used is the Quantity_Needed from needsComponent (which matches child quantity for non-serialized)
  IF v_child_category IN ('Commodity', 'Packaged', 'Serialized') THEN -- Only insert if subtype was handled
      INSERT INTO usesComponent (Parent_IID, Child_IID, Quantity_Used)
      VALUES (70.0, v_new_child_instance_id, ROUND(0.9, 1)); -- Use rounded quantity needed
  END IF;

EXCEPTION
  WHEN OTHERS THEN
    DBMS_OUTPUT.PUT_LINE('Error processing Parent_IID=' || 70.0 || ', Child_PID=' || 106.0 || ': ' || SQLERRM);
    -- Decide if you want to rollback just this block or let the main exception handler catch it
END;
/
DECLARE
  v_new_child_instance_id productInstance.Instance_ID%TYPE;
  v_child_category        product.Category%TYPE := 'Commodity'; -- Pass category
  v_max_existing_batch_lot NUMBER;
  v_next_batch_lot_num   NUMBER;
  v_serial_number        serialized.Serial_Number%TYPE;
  v_batch_number         serialized.Batch_Number%TYPE; -- Shared batch for serialized children of *this* parent
  v_expiration_date      commodity.Expiration_Date%TYPE;
  v_quantity_to_create   commodity.Quantity%TYPE; -- Quantity for the new child instance

BEGIN
  -- Step 1: Create the new child productInstance
  INSERT INTO productInstance (Product_ID, Date_Manufactured, Is_Recalled)
  VALUES (237.0, TIMESTAMP '2025-02-10 08:48:55', 0)
  RETURNING Instance_ID INTO v_new_child_instance_id;

  -- Step 2: Create the corresponding subtype record
  IF v_child_category = 'Commodity' THEN
    -- Find max existing Batch_Number for this specific Child_PID
    SELECT NVL(MAX(c.Batch_Number), 0) INTO v_max_existing_batch_lot
    FROM commodity c JOIN productInstance pi ON c.Instance_ID = pi.Instance_ID
    WHERE pi.Product_ID = 237.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next batch

    v_expiration_date := TIMESTAMP '2025-02-10 08:48:55' + INTERVAL '267' DAY;
    v_quantity_to_create := ROUND(1.2, 1);

    INSERT INTO commodity (Instance_ID, Batch_Number, Expiration_Date, Quantity)
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Packaged' THEN
    -- Find max existing Lot_Number for this specific Child_PID
    SELECT NVL(MAX(p.Lot_Number), 0) INTO v_max_existing_batch_lot
    FROM packaged p JOIN productInstance pi ON p.Instance_ID = pi.Instance_ID -- Assuming 'packaged' table name
    WHERE pi.Product_ID = 237.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next lot

    v_expiration_date := TIMESTAMP '2025-02-10 08:48:55' + INTERVAL '431' DAY;
    v_quantity_to_create := ROUND(1.2, 1);

    INSERT INTO packaged (Instance_ID, Lot_Number, Expiration_Date, Quantity) -- Assuming 'packaged' table name
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Serialized' THEN
    -- Assign a unique serial number
    -- Using Instance ID guarantees uniqueness within this context
    v_serial_number := 'SN-' || TO_CHAR(237.0) || '-' || TO_CHAR(v_new_child_instance_id) || '-' || SUBSTR(SYS_GUID(),1,8);
    -- Assign a batch number - use Product_ID of the *parent* instance as the batch for simplicity? Or a sequence?
    -- Let's use the Parent_IID itself as a simple batch identifier for this run.
    v_batch_number := 70.0; -- All children created FOR this parent get same batch number

    INSERT INTO serialized (Instance_ID, Serial_Number, Batch_Number)
    VALUES (v_new_child_instance_id, v_serial_number, v_batch_number);

    -- Quantity for usesComponent link for serialized is typically 1
    v_quantity_to_create := 1;

  END IF;

  -- Step 3: Create the usesComponent link
  -- Quantity_Used is the Quantity_Needed from needsComponent (which matches child quantity for non-serialized)
  IF v_child_category IN ('Commodity', 'Packaged', 'Serialized') THEN -- Only insert if subtype was handled
      INSERT INTO usesComponent (Parent_IID, Child_IID, Quantity_Used)
      VALUES (70.0, v_new_child_instance_id, ROUND(1.2, 1)); -- Use rounded quantity needed
  END IF;

EXCEPTION
  WHEN OTHERS THEN
    DBMS_OUTPUT.PUT_LINE('Error processing Parent_IID=' || 70.0 || ', Child_PID=' || 237.0 || ': ' || SQLERRM);
    -- Decide if you want to rollback just this block or let the main exception handler catch it
END;
/
DECLARE
  v_new_child_instance_id productInstance.Instance_ID%TYPE;
  v_child_category        product.Category%TYPE := 'Commodity'; -- Pass category
  v_max_existing_batch_lot NUMBER;
  v_next_batch_lot_num   NUMBER;
  v_serial_number        serialized.Serial_Number%TYPE;
  v_batch_number         serialized.Batch_Number%TYPE; -- Shared batch for serialized children of *this* parent
  v_expiration_date      commodity.Expiration_Date%TYPE;
  v_quantity_to_create   commodity.Quantity%TYPE; -- Quantity for the new child instance

BEGIN
  -- Step 1: Create the new child productInstance
  INSERT INTO productInstance (Product_ID, Date_Manufactured, Is_Recalled)
  VALUES (109.0, TIMESTAMP '2024-12-02 22:16:35', 0)
  RETURNING Instance_ID INTO v_new_child_instance_id;

  -- Step 2: Create the corresponding subtype record
  IF v_child_category = 'Commodity' THEN
    -- Find max existing Batch_Number for this specific Child_PID
    SELECT NVL(MAX(c.Batch_Number), 0) INTO v_max_existing_batch_lot
    FROM commodity c JOIN productInstance pi ON c.Instance_ID = pi.Instance_ID
    WHERE pi.Product_ID = 109.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next batch

    v_expiration_date := TIMESTAMP '2024-12-02 22:16:35' + INTERVAL '439' DAY;
    v_quantity_to_create := ROUND(0.5, 1);

    INSERT INTO commodity (Instance_ID, Batch_Number, Expiration_Date, Quantity)
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Packaged' THEN
    -- Find max existing Lot_Number for this specific Child_PID
    SELECT NVL(MAX(p.Lot_Number), 0) INTO v_max_existing_batch_lot
    FROM packaged p JOIN productInstance pi ON p.Instance_ID = pi.Instance_ID -- Assuming 'packaged' table name
    WHERE pi.Product_ID = 109.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next lot

    v_expiration_date := TIMESTAMP '2024-12-02 22:16:35' + INTERVAL '206' DAY;
    v_quantity_to_create := ROUND(0.5, 1);

    INSERT INTO packaged (Instance_ID, Lot_Number, Expiration_Date, Quantity) -- Assuming 'packaged' table name
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Serialized' THEN
    -- Assign a unique serial number
    -- Using Instance ID guarantees uniqueness within this context
    v_serial_number := 'SN-' || TO_CHAR(109.0) || '-' || TO_CHAR(v_new_child_instance_id) || '-' || SUBSTR(SYS_GUID(),1,8);
    -- Assign a batch number - use Product_ID of the *parent* instance as the batch for simplicity? Or a sequence?
    -- Let's use the Parent_IID itself as a simple batch identifier for this run.
    v_batch_number := 71.0; -- All children created FOR this parent get same batch number

    INSERT INTO serialized (Instance_ID, Serial_Number, Batch_Number)
    VALUES (v_new_child_instance_id, v_serial_number, v_batch_number);

    -- Quantity for usesComponent link for serialized is typically 1
    v_quantity_to_create := 1;

  END IF;

  -- Step 3: Create the usesComponent link
  -- Quantity_Used is the Quantity_Needed from needsComponent (which matches child quantity for non-serialized)
  IF v_child_category IN ('Commodity', 'Packaged', 'Serialized') THEN -- Only insert if subtype was handled
      INSERT INTO usesComponent (Parent_IID, Child_IID, Quantity_Used)
      VALUES (71.0, v_new_child_instance_id, ROUND(0.5, 1)); -- Use rounded quantity needed
  END IF;

EXCEPTION
  WHEN OTHERS THEN
    DBMS_OUTPUT.PUT_LINE('Error processing Parent_IID=' || 71.0 || ', Child_PID=' || 109.0 || ': ' || SQLERRM);
    -- Decide if you want to rollback just this block or let the main exception handler catch it
END;
/
DECLARE
  v_new_child_instance_id productInstance.Instance_ID%TYPE;
  v_child_category        product.Category%TYPE := 'Commodity'; -- Pass category
  v_max_existing_batch_lot NUMBER;
  v_next_batch_lot_num   NUMBER;
  v_serial_number        serialized.Serial_Number%TYPE;
  v_batch_number         serialized.Batch_Number%TYPE; -- Shared batch for serialized children of *this* parent
  v_expiration_date      commodity.Expiration_Date%TYPE;
  v_quantity_to_create   commodity.Quantity%TYPE; -- Quantity for the new child instance

BEGIN
  -- Step 1: Create the new child productInstance
  INSERT INTO productInstance (Product_ID, Date_Manufactured, Is_Recalled)
  VALUES (232.0, TIMESTAMP '2024-11-02 20:39:48', 0)
  RETURNING Instance_ID INTO v_new_child_instance_id;

  -- Step 2: Create the corresponding subtype record
  IF v_child_category = 'Commodity' THEN
    -- Find max existing Batch_Number for this specific Child_PID
    SELECT NVL(MAX(c.Batch_Number), 0) INTO v_max_existing_batch_lot
    FROM commodity c JOIN productInstance pi ON c.Instance_ID = pi.Instance_ID
    WHERE pi.Product_ID = 232.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next batch

    v_expiration_date := TIMESTAMP '2024-11-02 20:39:48' + INTERVAL '295' DAY;
    v_quantity_to_create := ROUND(1.3, 1);

    INSERT INTO commodity (Instance_ID, Batch_Number, Expiration_Date, Quantity)
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Packaged' THEN
    -- Find max existing Lot_Number for this specific Child_PID
    SELECT NVL(MAX(p.Lot_Number), 0) INTO v_max_existing_batch_lot
    FROM packaged p JOIN productInstance pi ON p.Instance_ID = pi.Instance_ID -- Assuming 'packaged' table name
    WHERE pi.Product_ID = 232.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next lot

    v_expiration_date := TIMESTAMP '2024-11-02 20:39:48' + INTERVAL '655' DAY;
    v_quantity_to_create := ROUND(1.3, 1);

    INSERT INTO packaged (Instance_ID, Lot_Number, Expiration_Date, Quantity) -- Assuming 'packaged' table name
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Serialized' THEN
    -- Assign a unique serial number
    -- Using Instance ID guarantees uniqueness within this context
    v_serial_number := 'SN-' || TO_CHAR(232.0) || '-' || TO_CHAR(v_new_child_instance_id) || '-' || SUBSTR(SYS_GUID(),1,8);
    -- Assign a batch number - use Product_ID of the *parent* instance as the batch for simplicity? Or a sequence?
    -- Let's use the Parent_IID itself as a simple batch identifier for this run.
    v_batch_number := 71.0; -- All children created FOR this parent get same batch number

    INSERT INTO serialized (Instance_ID, Serial_Number, Batch_Number)
    VALUES (v_new_child_instance_id, v_serial_number, v_batch_number);

    -- Quantity for usesComponent link for serialized is typically 1
    v_quantity_to_create := 1;

  END IF;

  -- Step 3: Create the usesComponent link
  -- Quantity_Used is the Quantity_Needed from needsComponent (which matches child quantity for non-serialized)
  IF v_child_category IN ('Commodity', 'Packaged', 'Serialized') THEN -- Only insert if subtype was handled
      INSERT INTO usesComponent (Parent_IID, Child_IID, Quantity_Used)
      VALUES (71.0, v_new_child_instance_id, ROUND(1.3, 1)); -- Use rounded quantity needed
  END IF;

EXCEPTION
  WHEN OTHERS THEN
    DBMS_OUTPUT.PUT_LINE('Error processing Parent_IID=' || 71.0 || ', Child_PID=' || 232.0 || ': ' || SQLERRM);
    -- Decide if you want to rollback just this block or let the main exception handler catch it
END;
/
DECLARE
  v_new_child_instance_id productInstance.Instance_ID%TYPE;
  v_child_category        product.Category%TYPE := 'Commodity'; -- Pass category
  v_max_existing_batch_lot NUMBER;
  v_next_batch_lot_num   NUMBER;
  v_serial_number        serialized.Serial_Number%TYPE;
  v_batch_number         serialized.Batch_Number%TYPE; -- Shared batch for serialized children of *this* parent
  v_expiration_date      commodity.Expiration_Date%TYPE;
  v_quantity_to_create   commodity.Quantity%TYPE; -- Quantity for the new child instance

BEGIN
  -- Step 1: Create the new child productInstance
  INSERT INTO productInstance (Product_ID, Date_Manufactured, Is_Recalled)
  VALUES (106.0, TIMESTAMP '2024-09-04 01:27:42', 0)
  RETURNING Instance_ID INTO v_new_child_instance_id;

  -- Step 2: Create the corresponding subtype record
  IF v_child_category = 'Commodity' THEN
    -- Find max existing Batch_Number for this specific Child_PID
    SELECT NVL(MAX(c.Batch_Number), 0) INTO v_max_existing_batch_lot
    FROM commodity c JOIN productInstance pi ON c.Instance_ID = pi.Instance_ID
    WHERE pi.Product_ID = 106.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next batch

    v_expiration_date := TIMESTAMP '2024-09-04 01:27:42' + INTERVAL '257' DAY;
    v_quantity_to_create := ROUND(0.9, 1);

    INSERT INTO commodity (Instance_ID, Batch_Number, Expiration_Date, Quantity)
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Packaged' THEN
    -- Find max existing Lot_Number for this specific Child_PID
    SELECT NVL(MAX(p.Lot_Number), 0) INTO v_max_existing_batch_lot
    FROM packaged p JOIN productInstance pi ON p.Instance_ID = pi.Instance_ID -- Assuming 'packaged' table name
    WHERE pi.Product_ID = 106.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next lot

    v_expiration_date := TIMESTAMP '2024-09-04 01:27:42' + INTERVAL '294' DAY;
    v_quantity_to_create := ROUND(0.9, 1);

    INSERT INTO packaged (Instance_ID, Lot_Number, Expiration_Date, Quantity) -- Assuming 'packaged' table name
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Serialized' THEN
    -- Assign a unique serial number
    -- Using Instance ID guarantees uniqueness within this context
    v_serial_number := 'SN-' || TO_CHAR(106.0) || '-' || TO_CHAR(v_new_child_instance_id) || '-' || SUBSTR(SYS_GUID(),1,8);
    -- Assign a batch number - use Product_ID of the *parent* instance as the batch for simplicity? Or a sequence?
    -- Let's use the Parent_IID itself as a simple batch identifier for this run.
    v_batch_number := 71.0; -- All children created FOR this parent get same batch number

    INSERT INTO serialized (Instance_ID, Serial_Number, Batch_Number)
    VALUES (v_new_child_instance_id, v_serial_number, v_batch_number);

    -- Quantity for usesComponent link for serialized is typically 1
    v_quantity_to_create := 1;

  END IF;

  -- Step 3: Create the usesComponent link
  -- Quantity_Used is the Quantity_Needed from needsComponent (which matches child quantity for non-serialized)
  IF v_child_category IN ('Commodity', 'Packaged', 'Serialized') THEN -- Only insert if subtype was handled
      INSERT INTO usesComponent (Parent_IID, Child_IID, Quantity_Used)
      VALUES (71.0, v_new_child_instance_id, ROUND(0.9, 1)); -- Use rounded quantity needed
  END IF;

EXCEPTION
  WHEN OTHERS THEN
    DBMS_OUTPUT.PUT_LINE('Error processing Parent_IID=' || 71.0 || ', Child_PID=' || 106.0 || ': ' || SQLERRM);
    -- Decide if you want to rollback just this block or let the main exception handler catch it
END;
/
DECLARE
  v_new_child_instance_id productInstance.Instance_ID%TYPE;
  v_child_category        product.Category%TYPE := 'Commodity'; -- Pass category
  v_max_existing_batch_lot NUMBER;
  v_next_batch_lot_num   NUMBER;
  v_serial_number        serialized.Serial_Number%TYPE;
  v_batch_number         serialized.Batch_Number%TYPE; -- Shared batch for serialized children of *this* parent
  v_expiration_date      commodity.Expiration_Date%TYPE;
  v_quantity_to_create   commodity.Quantity%TYPE; -- Quantity for the new child instance

BEGIN
  -- Step 1: Create the new child productInstance
  INSERT INTO productInstance (Product_ID, Date_Manufactured, Is_Recalled)
  VALUES (237.0, TIMESTAMP '2024-12-21 22:06:33', 0)
  RETURNING Instance_ID INTO v_new_child_instance_id;

  -- Step 2: Create the corresponding subtype record
  IF v_child_category = 'Commodity' THEN
    -- Find max existing Batch_Number for this specific Child_PID
    SELECT NVL(MAX(c.Batch_Number), 0) INTO v_max_existing_batch_lot
    FROM commodity c JOIN productInstance pi ON c.Instance_ID = pi.Instance_ID
    WHERE pi.Product_ID = 237.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next batch

    v_expiration_date := TIMESTAMP '2024-12-21 22:06:33' + INTERVAL '280' DAY;
    v_quantity_to_create := ROUND(1.2, 1);

    INSERT INTO commodity (Instance_ID, Batch_Number, Expiration_Date, Quantity)
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Packaged' THEN
    -- Find max existing Lot_Number for this specific Child_PID
    SELECT NVL(MAX(p.Lot_Number), 0) INTO v_max_existing_batch_lot
    FROM packaged p JOIN productInstance pi ON p.Instance_ID = pi.Instance_ID -- Assuming 'packaged' table name
    WHERE pi.Product_ID = 237.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next lot

    v_expiration_date := TIMESTAMP '2024-12-21 22:06:33' + INTERVAL '706' DAY;
    v_quantity_to_create := ROUND(1.2, 1);

    INSERT INTO packaged (Instance_ID, Lot_Number, Expiration_Date, Quantity) -- Assuming 'packaged' table name
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Serialized' THEN
    -- Assign a unique serial number
    -- Using Instance ID guarantees uniqueness within this context
    v_serial_number := 'SN-' || TO_CHAR(237.0) || '-' || TO_CHAR(v_new_child_instance_id) || '-' || SUBSTR(SYS_GUID(),1,8);
    -- Assign a batch number - use Product_ID of the *parent* instance as the batch for simplicity? Or a sequence?
    -- Let's use the Parent_IID itself as a simple batch identifier for this run.
    v_batch_number := 71.0; -- All children created FOR this parent get same batch number

    INSERT INTO serialized (Instance_ID, Serial_Number, Batch_Number)
    VALUES (v_new_child_instance_id, v_serial_number, v_batch_number);

    -- Quantity for usesComponent link for serialized is typically 1
    v_quantity_to_create := 1;

  END IF;

  -- Step 3: Create the usesComponent link
  -- Quantity_Used is the Quantity_Needed from needsComponent (which matches child quantity for non-serialized)
  IF v_child_category IN ('Commodity', 'Packaged', 'Serialized') THEN -- Only insert if subtype was handled
      INSERT INTO usesComponent (Parent_IID, Child_IID, Quantity_Used)
      VALUES (71.0, v_new_child_instance_id, ROUND(1.2, 1)); -- Use rounded quantity needed
  END IF;

EXCEPTION
  WHEN OTHERS THEN
    DBMS_OUTPUT.PUT_LINE('Error processing Parent_IID=' || 71.0 || ', Child_PID=' || 237.0 || ': ' || SQLERRM);
    -- Decide if you want to rollback just this block or let the main exception handler catch it
END;
/
DECLARE
  v_new_child_instance_id productInstance.Instance_ID%TYPE;
  v_child_category        product.Category%TYPE := 'Commodity'; -- Pass category
  v_max_existing_batch_lot NUMBER;
  v_next_batch_lot_num   NUMBER;
  v_serial_number        serialized.Serial_Number%TYPE;
  v_batch_number         serialized.Batch_Number%TYPE; -- Shared batch for serialized children of *this* parent
  v_expiration_date      commodity.Expiration_Date%TYPE;
  v_quantity_to_create   commodity.Quantity%TYPE; -- Quantity for the new child instance

BEGIN
  -- Step 1: Create the new child productInstance
  INSERT INTO productInstance (Product_ID, Date_Manufactured, Is_Recalled)
  VALUES (109.0, TIMESTAMP '2024-05-10 21:33:46', 0)
  RETURNING Instance_ID INTO v_new_child_instance_id;

  -- Step 2: Create the corresponding subtype record
  IF v_child_category = 'Commodity' THEN
    -- Find max existing Batch_Number for this specific Child_PID
    SELECT NVL(MAX(c.Batch_Number), 0) INTO v_max_existing_batch_lot
    FROM commodity c JOIN productInstance pi ON c.Instance_ID = pi.Instance_ID
    WHERE pi.Product_ID = 109.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next batch

    v_expiration_date := TIMESTAMP '2024-05-10 21:33:46' + INTERVAL '667' DAY;
    v_quantity_to_create := ROUND(0.5, 1);

    INSERT INTO commodity (Instance_ID, Batch_Number, Expiration_Date, Quantity)
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Packaged' THEN
    -- Find max existing Lot_Number for this specific Child_PID
    SELECT NVL(MAX(p.Lot_Number), 0) INTO v_max_existing_batch_lot
    FROM packaged p JOIN productInstance pi ON p.Instance_ID = pi.Instance_ID -- Assuming 'packaged' table name
    WHERE pi.Product_ID = 109.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next lot

    v_expiration_date := TIMESTAMP '2024-05-10 21:33:46' + INTERVAL '442' DAY;
    v_quantity_to_create := ROUND(0.5, 1);

    INSERT INTO packaged (Instance_ID, Lot_Number, Expiration_Date, Quantity) -- Assuming 'packaged' table name
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Serialized' THEN
    -- Assign a unique serial number
    -- Using Instance ID guarantees uniqueness within this context
    v_serial_number := 'SN-' || TO_CHAR(109.0) || '-' || TO_CHAR(v_new_child_instance_id) || '-' || SUBSTR(SYS_GUID(),1,8);
    -- Assign a batch number - use Product_ID of the *parent* instance as the batch for simplicity? Or a sequence?
    -- Let's use the Parent_IID itself as a simple batch identifier for this run.
    v_batch_number := 72.0; -- All children created FOR this parent get same batch number

    INSERT INTO serialized (Instance_ID, Serial_Number, Batch_Number)
    VALUES (v_new_child_instance_id, v_serial_number, v_batch_number);

    -- Quantity for usesComponent link for serialized is typically 1
    v_quantity_to_create := 1;

  END IF;

  -- Step 3: Create the usesComponent link
  -- Quantity_Used is the Quantity_Needed from needsComponent (which matches child quantity for non-serialized)
  IF v_child_category IN ('Commodity', 'Packaged', 'Serialized') THEN -- Only insert if subtype was handled
      INSERT INTO usesComponent (Parent_IID, Child_IID, Quantity_Used)
      VALUES (72.0, v_new_child_instance_id, ROUND(0.5, 1)); -- Use rounded quantity needed
  END IF;

EXCEPTION
  WHEN OTHERS THEN
    DBMS_OUTPUT.PUT_LINE('Error processing Parent_IID=' || 72.0 || ', Child_PID=' || 109.0 || ': ' || SQLERRM);
    -- Decide if you want to rollback just this block or let the main exception handler catch it
END;
/
DECLARE
  v_new_child_instance_id productInstance.Instance_ID%TYPE;
  v_child_category        product.Category%TYPE := 'Commodity'; -- Pass category
  v_max_existing_batch_lot NUMBER;
  v_next_batch_lot_num   NUMBER;
  v_serial_number        serialized.Serial_Number%TYPE;
  v_batch_number         serialized.Batch_Number%TYPE; -- Shared batch for serialized children of *this* parent
  v_expiration_date      commodity.Expiration_Date%TYPE;
  v_quantity_to_create   commodity.Quantity%TYPE; -- Quantity for the new child instance

BEGIN
  -- Step 1: Create the new child productInstance
  INSERT INTO productInstance (Product_ID, Date_Manufactured, Is_Recalled)
  VALUES (232.0, TIMESTAMP '2024-08-29 23:13:35', 0)
  RETURNING Instance_ID INTO v_new_child_instance_id;

  -- Step 2: Create the corresponding subtype record
  IF v_child_category = 'Commodity' THEN
    -- Find max existing Batch_Number for this specific Child_PID
    SELECT NVL(MAX(c.Batch_Number), 0) INTO v_max_existing_batch_lot
    FROM commodity c JOIN productInstance pi ON c.Instance_ID = pi.Instance_ID
    WHERE pi.Product_ID = 232.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next batch

    v_expiration_date := TIMESTAMP '2024-08-29 23:13:35' + INTERVAL '472' DAY;
    v_quantity_to_create := ROUND(1.3, 1);

    INSERT INTO commodity (Instance_ID, Batch_Number, Expiration_Date, Quantity)
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Packaged' THEN
    -- Find max existing Lot_Number for this specific Child_PID
    SELECT NVL(MAX(p.Lot_Number), 0) INTO v_max_existing_batch_lot
    FROM packaged p JOIN productInstance pi ON p.Instance_ID = pi.Instance_ID -- Assuming 'packaged' table name
    WHERE pi.Product_ID = 232.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next lot

    v_expiration_date := TIMESTAMP '2024-08-29 23:13:35' + INTERVAL '284' DAY;
    v_quantity_to_create := ROUND(1.3, 1);

    INSERT INTO packaged (Instance_ID, Lot_Number, Expiration_Date, Quantity) -- Assuming 'packaged' table name
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Serialized' THEN
    -- Assign a unique serial number
    -- Using Instance ID guarantees uniqueness within this context
    v_serial_number := 'SN-' || TO_CHAR(232.0) || '-' || TO_CHAR(v_new_child_instance_id) || '-' || SUBSTR(SYS_GUID(),1,8);
    -- Assign a batch number - use Product_ID of the *parent* instance as the batch for simplicity? Or a sequence?
    -- Let's use the Parent_IID itself as a simple batch identifier for this run.
    v_batch_number := 72.0; -- All children created FOR this parent get same batch number

    INSERT INTO serialized (Instance_ID, Serial_Number, Batch_Number)
    VALUES (v_new_child_instance_id, v_serial_number, v_batch_number);

    -- Quantity for usesComponent link for serialized is typically 1
    v_quantity_to_create := 1;

  END IF;

  -- Step 3: Create the usesComponent link
  -- Quantity_Used is the Quantity_Needed from needsComponent (which matches child quantity for non-serialized)
  IF v_child_category IN ('Commodity', 'Packaged', 'Serialized') THEN -- Only insert if subtype was handled
      INSERT INTO usesComponent (Parent_IID, Child_IID, Quantity_Used)
      VALUES (72.0, v_new_child_instance_id, ROUND(1.3, 1)); -- Use rounded quantity needed
  END IF;

EXCEPTION
  WHEN OTHERS THEN
    DBMS_OUTPUT.PUT_LINE('Error processing Parent_IID=' || 72.0 || ', Child_PID=' || 232.0 || ': ' || SQLERRM);
    -- Decide if you want to rollback just this block or let the main exception handler catch it
END;
/
DECLARE
  v_new_child_instance_id productInstance.Instance_ID%TYPE;
  v_child_category        product.Category%TYPE := 'Commodity'; -- Pass category
  v_max_existing_batch_lot NUMBER;
  v_next_batch_lot_num   NUMBER;
  v_serial_number        serialized.Serial_Number%TYPE;
  v_batch_number         serialized.Batch_Number%TYPE; -- Shared batch for serialized children of *this* parent
  v_expiration_date      commodity.Expiration_Date%TYPE;
  v_quantity_to_create   commodity.Quantity%TYPE; -- Quantity for the new child instance

BEGIN
  -- Step 1: Create the new child productInstance
  INSERT INTO productInstance (Product_ID, Date_Manufactured, Is_Recalled)
  VALUES (106.0, TIMESTAMP '2025-02-28 01:31:52', 0)
  RETURNING Instance_ID INTO v_new_child_instance_id;

  -- Step 2: Create the corresponding subtype record
  IF v_child_category = 'Commodity' THEN
    -- Find max existing Batch_Number for this specific Child_PID
    SELECT NVL(MAX(c.Batch_Number), 0) INTO v_max_existing_batch_lot
    FROM commodity c JOIN productInstance pi ON c.Instance_ID = pi.Instance_ID
    WHERE pi.Product_ID = 106.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next batch

    v_expiration_date := TIMESTAMP '2025-02-28 01:31:52' + INTERVAL '305' DAY;
    v_quantity_to_create := ROUND(0.9, 1);

    INSERT INTO commodity (Instance_ID, Batch_Number, Expiration_Date, Quantity)
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Packaged' THEN
    -- Find max existing Lot_Number for this specific Child_PID
    SELECT NVL(MAX(p.Lot_Number), 0) INTO v_max_existing_batch_lot
    FROM packaged p JOIN productInstance pi ON p.Instance_ID = pi.Instance_ID -- Assuming 'packaged' table name
    WHERE pi.Product_ID = 106.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next lot

    v_expiration_date := TIMESTAMP '2025-02-28 01:31:52' + INTERVAL '224' DAY;
    v_quantity_to_create := ROUND(0.9, 1);

    INSERT INTO packaged (Instance_ID, Lot_Number, Expiration_Date, Quantity) -- Assuming 'packaged' table name
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Serialized' THEN
    -- Assign a unique serial number
    -- Using Instance ID guarantees uniqueness within this context
    v_serial_number := 'SN-' || TO_CHAR(106.0) || '-' || TO_CHAR(v_new_child_instance_id) || '-' || SUBSTR(SYS_GUID(),1,8);
    -- Assign a batch number - use Product_ID of the *parent* instance as the batch for simplicity? Or a sequence?
    -- Let's use the Parent_IID itself as a simple batch identifier for this run.
    v_batch_number := 72.0; -- All children created FOR this parent get same batch number

    INSERT INTO serialized (Instance_ID, Serial_Number, Batch_Number)
    VALUES (v_new_child_instance_id, v_serial_number, v_batch_number);

    -- Quantity for usesComponent link for serialized is typically 1
    v_quantity_to_create := 1;

  END IF;

  -- Step 3: Create the usesComponent link
  -- Quantity_Used is the Quantity_Needed from needsComponent (which matches child quantity for non-serialized)
  IF v_child_category IN ('Commodity', 'Packaged', 'Serialized') THEN -- Only insert if subtype was handled
      INSERT INTO usesComponent (Parent_IID, Child_IID, Quantity_Used)
      VALUES (72.0, v_new_child_instance_id, ROUND(0.9, 1)); -- Use rounded quantity needed
  END IF;

EXCEPTION
  WHEN OTHERS THEN
    DBMS_OUTPUT.PUT_LINE('Error processing Parent_IID=' || 72.0 || ', Child_PID=' || 106.0 || ': ' || SQLERRM);
    -- Decide if you want to rollback just this block or let the main exception handler catch it
END;
/
DECLARE
  v_new_child_instance_id productInstance.Instance_ID%TYPE;
  v_child_category        product.Category%TYPE := 'Commodity'; -- Pass category
  v_max_existing_batch_lot NUMBER;
  v_next_batch_lot_num   NUMBER;
  v_serial_number        serialized.Serial_Number%TYPE;
  v_batch_number         serialized.Batch_Number%TYPE; -- Shared batch for serialized children of *this* parent
  v_expiration_date      commodity.Expiration_Date%TYPE;
  v_quantity_to_create   commodity.Quantity%TYPE; -- Quantity for the new child instance

BEGIN
  -- Step 1: Create the new child productInstance
  INSERT INTO productInstance (Product_ID, Date_Manufactured, Is_Recalled)
  VALUES (237.0, TIMESTAMP '2024-05-27 05:04:36', 0)
  RETURNING Instance_ID INTO v_new_child_instance_id;

  -- Step 2: Create the corresponding subtype record
  IF v_child_category = 'Commodity' THEN
    -- Find max existing Batch_Number for this specific Child_PID
    SELECT NVL(MAX(c.Batch_Number), 0) INTO v_max_existing_batch_lot
    FROM commodity c JOIN productInstance pi ON c.Instance_ID = pi.Instance_ID
    WHERE pi.Product_ID = 237.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next batch

    v_expiration_date := TIMESTAMP '2024-05-27 05:04:36' + INTERVAL '670' DAY;
    v_quantity_to_create := ROUND(1.2, 1);

    INSERT INTO commodity (Instance_ID, Batch_Number, Expiration_Date, Quantity)
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Packaged' THEN
    -- Find max existing Lot_Number for this specific Child_PID
    SELECT NVL(MAX(p.Lot_Number), 0) INTO v_max_existing_batch_lot
    FROM packaged p JOIN productInstance pi ON p.Instance_ID = pi.Instance_ID -- Assuming 'packaged' table name
    WHERE pi.Product_ID = 237.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next lot

    v_expiration_date := TIMESTAMP '2024-05-27 05:04:36' + INTERVAL '199' DAY;
    v_quantity_to_create := ROUND(1.2, 1);

    INSERT INTO packaged (Instance_ID, Lot_Number, Expiration_Date, Quantity) -- Assuming 'packaged' table name
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Serialized' THEN
    -- Assign a unique serial number
    -- Using Instance ID guarantees uniqueness within this context
    v_serial_number := 'SN-' || TO_CHAR(237.0) || '-' || TO_CHAR(v_new_child_instance_id) || '-' || SUBSTR(SYS_GUID(),1,8);
    -- Assign a batch number - use Product_ID of the *parent* instance as the batch for simplicity? Or a sequence?
    -- Let's use the Parent_IID itself as a simple batch identifier for this run.
    v_batch_number := 72.0; -- All children created FOR this parent get same batch number

    INSERT INTO serialized (Instance_ID, Serial_Number, Batch_Number)
    VALUES (v_new_child_instance_id, v_serial_number, v_batch_number);

    -- Quantity for usesComponent link for serialized is typically 1
    v_quantity_to_create := 1;

  END IF;

  -- Step 3: Create the usesComponent link
  -- Quantity_Used is the Quantity_Needed from needsComponent (which matches child quantity for non-serialized)
  IF v_child_category IN ('Commodity', 'Packaged', 'Serialized') THEN -- Only insert if subtype was handled
      INSERT INTO usesComponent (Parent_IID, Child_IID, Quantity_Used)
      VALUES (72.0, v_new_child_instance_id, ROUND(1.2, 1)); -- Use rounded quantity needed
  END IF;

EXCEPTION
  WHEN OTHERS THEN
    DBMS_OUTPUT.PUT_LINE('Error processing Parent_IID=' || 72.0 || ', Child_PID=' || 237.0 || ': ' || SQLERRM);
    -- Decide if you want to rollback just this block or let the main exception handler catch it
END;
/
DECLARE
  v_new_child_instance_id productInstance.Instance_ID%TYPE;
  v_child_category        product.Category%TYPE := 'Commodity'; -- Pass category
  v_max_existing_batch_lot NUMBER;
  v_next_batch_lot_num   NUMBER;
  v_serial_number        serialized.Serial_Number%TYPE;
  v_batch_number         serialized.Batch_Number%TYPE; -- Shared batch for serialized children of *this* parent
  v_expiration_date      commodity.Expiration_Date%TYPE;
  v_quantity_to_create   commodity.Quantity%TYPE; -- Quantity for the new child instance

BEGIN
  -- Step 1: Create the new child productInstance
  INSERT INTO productInstance (Product_ID, Date_Manufactured, Is_Recalled)
  VALUES (170.0, TIMESTAMP '2025-04-02 07:45:52', 0)
  RETURNING Instance_ID INTO v_new_child_instance_id;

  -- Step 2: Create the corresponding subtype record
  IF v_child_category = 'Commodity' THEN
    -- Find max existing Batch_Number for this specific Child_PID
    SELECT NVL(MAX(c.Batch_Number), 0) INTO v_max_existing_batch_lot
    FROM commodity c JOIN productInstance pi ON c.Instance_ID = pi.Instance_ID
    WHERE pi.Product_ID = 170.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next batch

    v_expiration_date := TIMESTAMP '2025-04-02 07:45:52' + INTERVAL '623' DAY;
    v_quantity_to_create := ROUND(1.4, 1);

    INSERT INTO commodity (Instance_ID, Batch_Number, Expiration_Date, Quantity)
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Packaged' THEN
    -- Find max existing Lot_Number for this specific Child_PID
    SELECT NVL(MAX(p.Lot_Number), 0) INTO v_max_existing_batch_lot
    FROM packaged p JOIN productInstance pi ON p.Instance_ID = pi.Instance_ID -- Assuming 'packaged' table name
    WHERE pi.Product_ID = 170.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next lot

    v_expiration_date := TIMESTAMP '2025-04-02 07:45:52' + INTERVAL '484' DAY;
    v_quantity_to_create := ROUND(1.4, 1);

    INSERT INTO packaged (Instance_ID, Lot_Number, Expiration_Date, Quantity) -- Assuming 'packaged' table name
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Serialized' THEN
    -- Assign a unique serial number
    -- Using Instance ID guarantees uniqueness within this context
    v_serial_number := 'SN-' || TO_CHAR(170.0) || '-' || TO_CHAR(v_new_child_instance_id) || '-' || SUBSTR(SYS_GUID(),1,8);
    -- Assign a batch number - use Product_ID of the *parent* instance as the batch for simplicity? Or a sequence?
    -- Let's use the Parent_IID itself as a simple batch identifier for this run.
    v_batch_number := 85.0; -- All children created FOR this parent get same batch number

    INSERT INTO serialized (Instance_ID, Serial_Number, Batch_Number)
    VALUES (v_new_child_instance_id, v_serial_number, v_batch_number);

    -- Quantity for usesComponent link for serialized is typically 1
    v_quantity_to_create := 1;

  END IF;

  -- Step 3: Create the usesComponent link
  -- Quantity_Used is the Quantity_Needed from needsComponent (which matches child quantity for non-serialized)
  IF v_child_category IN ('Commodity', 'Packaged', 'Serialized') THEN -- Only insert if subtype was handled
      INSERT INTO usesComponent (Parent_IID, Child_IID, Quantity_Used)
      VALUES (85.0, v_new_child_instance_id, ROUND(1.4, 1)); -- Use rounded quantity needed
  END IF;

EXCEPTION
  WHEN OTHERS THEN
    DBMS_OUTPUT.PUT_LINE('Error processing Parent_IID=' || 85.0 || ', Child_PID=' || 170.0 || ': ' || SQLERRM);
    -- Decide if you want to rollback just this block or let the main exception handler catch it
END;
/
DECLARE
  v_new_child_instance_id productInstance.Instance_ID%TYPE;
  v_child_category        product.Category%TYPE := 'Commodity'; -- Pass category
  v_max_existing_batch_lot NUMBER;
  v_next_batch_lot_num   NUMBER;
  v_serial_number        serialized.Serial_Number%TYPE;
  v_batch_number         serialized.Batch_Number%TYPE; -- Shared batch for serialized children of *this* parent
  v_expiration_date      commodity.Expiration_Date%TYPE;
  v_quantity_to_create   commodity.Quantity%TYPE; -- Quantity for the new child instance

BEGIN
  -- Step 1: Create the new child productInstance
  INSERT INTO productInstance (Product_ID, Date_Manufactured, Is_Recalled)
  VALUES (154.0, TIMESTAMP '2024-12-10 20:18:38', 0)
  RETURNING Instance_ID INTO v_new_child_instance_id;

  -- Step 2: Create the corresponding subtype record
  IF v_child_category = 'Commodity' THEN
    -- Find max existing Batch_Number for this specific Child_PID
    SELECT NVL(MAX(c.Batch_Number), 0) INTO v_max_existing_batch_lot
    FROM commodity c JOIN productInstance pi ON c.Instance_ID = pi.Instance_ID
    WHERE pi.Product_ID = 154.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next batch

    v_expiration_date := TIMESTAMP '2024-12-10 20:18:38' + INTERVAL '181' DAY;
    v_quantity_to_create := ROUND(1.9, 1);

    INSERT INTO commodity (Instance_ID, Batch_Number, Expiration_Date, Quantity)
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Packaged' THEN
    -- Find max existing Lot_Number for this specific Child_PID
    SELECT NVL(MAX(p.Lot_Number), 0) INTO v_max_existing_batch_lot
    FROM packaged p JOIN productInstance pi ON p.Instance_ID = pi.Instance_ID -- Assuming 'packaged' table name
    WHERE pi.Product_ID = 154.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next lot

    v_expiration_date := TIMESTAMP '2024-12-10 20:18:38' + INTERVAL '650' DAY;
    v_quantity_to_create := ROUND(1.9, 1);

    INSERT INTO packaged (Instance_ID, Lot_Number, Expiration_Date, Quantity) -- Assuming 'packaged' table name
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Serialized' THEN
    -- Assign a unique serial number
    -- Using Instance ID guarantees uniqueness within this context
    v_serial_number := 'SN-' || TO_CHAR(154.0) || '-' || TO_CHAR(v_new_child_instance_id) || '-' || SUBSTR(SYS_GUID(),1,8);
    -- Assign a batch number - use Product_ID of the *parent* instance as the batch for simplicity? Or a sequence?
    -- Let's use the Parent_IID itself as a simple batch identifier for this run.
    v_batch_number := 85.0; -- All children created FOR this parent get same batch number

    INSERT INTO serialized (Instance_ID, Serial_Number, Batch_Number)
    VALUES (v_new_child_instance_id, v_serial_number, v_batch_number);

    -- Quantity for usesComponent link for serialized is typically 1
    v_quantity_to_create := 1;

  END IF;

  -- Step 3: Create the usesComponent link
  -- Quantity_Used is the Quantity_Needed from needsComponent (which matches child quantity for non-serialized)
  IF v_child_category IN ('Commodity', 'Packaged', 'Serialized') THEN -- Only insert if subtype was handled
      INSERT INTO usesComponent (Parent_IID, Child_IID, Quantity_Used)
      VALUES (85.0, v_new_child_instance_id, ROUND(1.9, 1)); -- Use rounded quantity needed
  END IF;

EXCEPTION
  WHEN OTHERS THEN
    DBMS_OUTPUT.PUT_LINE('Error processing Parent_IID=' || 85.0 || ', Child_PID=' || 154.0 || ': ' || SQLERRM);
    -- Decide if you want to rollback just this block or let the main exception handler catch it
END;
/
DECLARE
  v_new_child_instance_id productInstance.Instance_ID%TYPE;
  v_child_category        product.Category%TYPE := 'Commodity'; -- Pass category
  v_max_existing_batch_lot NUMBER;
  v_next_batch_lot_num   NUMBER;
  v_serial_number        serialized.Serial_Number%TYPE;
  v_batch_number         serialized.Batch_Number%TYPE; -- Shared batch for serialized children of *this* parent
  v_expiration_date      commodity.Expiration_Date%TYPE;
  v_quantity_to_create   commodity.Quantity%TYPE; -- Quantity for the new child instance

BEGIN
  -- Step 1: Create the new child productInstance
  INSERT INTO productInstance (Product_ID, Date_Manufactured, Is_Recalled)
  VALUES (144.0, TIMESTAMP '2024-08-08 18:49:45', 0)
  RETURNING Instance_ID INTO v_new_child_instance_id;

  -- Step 2: Create the corresponding subtype record
  IF v_child_category = 'Commodity' THEN
    -- Find max existing Batch_Number for this specific Child_PID
    SELECT NVL(MAX(c.Batch_Number), 0) INTO v_max_existing_batch_lot
    FROM commodity c JOIN productInstance pi ON c.Instance_ID = pi.Instance_ID
    WHERE pi.Product_ID = 144.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next batch

    v_expiration_date := TIMESTAMP '2024-08-08 18:49:45' + INTERVAL '500' DAY;
    v_quantity_to_create := ROUND(1.5, 1);

    INSERT INTO commodity (Instance_ID, Batch_Number, Expiration_Date, Quantity)
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Packaged' THEN
    -- Find max existing Lot_Number for this specific Child_PID
    SELECT NVL(MAX(p.Lot_Number), 0) INTO v_max_existing_batch_lot
    FROM packaged p JOIN productInstance pi ON p.Instance_ID = pi.Instance_ID -- Assuming 'packaged' table name
    WHERE pi.Product_ID = 144.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next lot

    v_expiration_date := TIMESTAMP '2024-08-08 18:49:45' + INTERVAL '569' DAY;
    v_quantity_to_create := ROUND(1.5, 1);

    INSERT INTO packaged (Instance_ID, Lot_Number, Expiration_Date, Quantity) -- Assuming 'packaged' table name
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Serialized' THEN
    -- Assign a unique serial number
    -- Using Instance ID guarantees uniqueness within this context
    v_serial_number := 'SN-' || TO_CHAR(144.0) || '-' || TO_CHAR(v_new_child_instance_id) || '-' || SUBSTR(SYS_GUID(),1,8);
    -- Assign a batch number - use Product_ID of the *parent* instance as the batch for simplicity? Or a sequence?
    -- Let's use the Parent_IID itself as a simple batch identifier for this run.
    v_batch_number := 85.0; -- All children created FOR this parent get same batch number

    INSERT INTO serialized (Instance_ID, Serial_Number, Batch_Number)
    VALUES (v_new_child_instance_id, v_serial_number, v_batch_number);

    -- Quantity for usesComponent link for serialized is typically 1
    v_quantity_to_create := 1;

  END IF;

  -- Step 3: Create the usesComponent link
  -- Quantity_Used is the Quantity_Needed from needsComponent (which matches child quantity for non-serialized)
  IF v_child_category IN ('Commodity', 'Packaged', 'Serialized') THEN -- Only insert if subtype was handled
      INSERT INTO usesComponent (Parent_IID, Child_IID, Quantity_Used)
      VALUES (85.0, v_new_child_instance_id, ROUND(1.5, 1)); -- Use rounded quantity needed
  END IF;

EXCEPTION
  WHEN OTHERS THEN
    DBMS_OUTPUT.PUT_LINE('Error processing Parent_IID=' || 85.0 || ', Child_PID=' || 144.0 || ': ' || SQLERRM);
    -- Decide if you want to rollback just this block or let the main exception handler catch it
END;
/
DECLARE
  v_new_child_instance_id productInstance.Instance_ID%TYPE;
  v_child_category        product.Category%TYPE := 'Commodity'; -- Pass category
  v_max_existing_batch_lot NUMBER;
  v_next_batch_lot_num   NUMBER;
  v_serial_number        serialized.Serial_Number%TYPE;
  v_batch_number         serialized.Batch_Number%TYPE; -- Shared batch for serialized children of *this* parent
  v_expiration_date      commodity.Expiration_Date%TYPE;
  v_quantity_to_create   commodity.Quantity%TYPE; -- Quantity for the new child instance

BEGIN
  -- Step 1: Create the new child productInstance
  INSERT INTO productInstance (Product_ID, Date_Manufactured, Is_Recalled)
  VALUES (106.0, TIMESTAMP '2024-07-01 03:54:16', 0)
  RETURNING Instance_ID INTO v_new_child_instance_id;

  -- Step 2: Create the corresponding subtype record
  IF v_child_category = 'Commodity' THEN
    -- Find max existing Batch_Number for this specific Child_PID
    SELECT NVL(MAX(c.Batch_Number), 0) INTO v_max_existing_batch_lot
    FROM commodity c JOIN productInstance pi ON c.Instance_ID = pi.Instance_ID
    WHERE pi.Product_ID = 106.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next batch

    v_expiration_date := TIMESTAMP '2024-07-01 03:54:16' + INTERVAL '171' DAY;
    v_quantity_to_create := ROUND(1.1, 1);

    INSERT INTO commodity (Instance_ID, Batch_Number, Expiration_Date, Quantity)
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Packaged' THEN
    -- Find max existing Lot_Number for this specific Child_PID
    SELECT NVL(MAX(p.Lot_Number), 0) INTO v_max_existing_batch_lot
    FROM packaged p JOIN productInstance pi ON p.Instance_ID = pi.Instance_ID -- Assuming 'packaged' table name
    WHERE pi.Product_ID = 106.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next lot

    v_expiration_date := TIMESTAMP '2024-07-01 03:54:16' + INTERVAL '171' DAY;
    v_quantity_to_create := ROUND(1.1, 1);

    INSERT INTO packaged (Instance_ID, Lot_Number, Expiration_Date, Quantity) -- Assuming 'packaged' table name
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Serialized' THEN
    -- Assign a unique serial number
    -- Using Instance ID guarantees uniqueness within this context
    v_serial_number := 'SN-' || TO_CHAR(106.0) || '-' || TO_CHAR(v_new_child_instance_id) || '-' || SUBSTR(SYS_GUID(),1,8);
    -- Assign a batch number - use Product_ID of the *parent* instance as the batch for simplicity? Or a sequence?
    -- Let's use the Parent_IID itself as a simple batch identifier for this run.
    v_batch_number := 85.0; -- All children created FOR this parent get same batch number

    INSERT INTO serialized (Instance_ID, Serial_Number, Batch_Number)
    VALUES (v_new_child_instance_id, v_serial_number, v_batch_number);

    -- Quantity for usesComponent link for serialized is typically 1
    v_quantity_to_create := 1;

  END IF;

  -- Step 3: Create the usesComponent link
  -- Quantity_Used is the Quantity_Needed from needsComponent (which matches child quantity for non-serialized)
  IF v_child_category IN ('Commodity', 'Packaged', 'Serialized') THEN -- Only insert if subtype was handled
      INSERT INTO usesComponent (Parent_IID, Child_IID, Quantity_Used)
      VALUES (85.0, v_new_child_instance_id, ROUND(1.1, 1)); -- Use rounded quantity needed
  END IF;

EXCEPTION
  WHEN OTHERS THEN
    DBMS_OUTPUT.PUT_LINE('Error processing Parent_IID=' || 85.0 || ', Child_PID=' || 106.0 || ': ' || SQLERRM);
    -- Decide if you want to rollback just this block or let the main exception handler catch it
END;
/
DECLARE
  v_new_child_instance_id productInstance.Instance_ID%TYPE;
  v_child_category        product.Category%TYPE := 'Commodity'; -- Pass category
  v_max_existing_batch_lot NUMBER;
  v_next_batch_lot_num   NUMBER;
  v_serial_number        serialized.Serial_Number%TYPE;
  v_batch_number         serialized.Batch_Number%TYPE; -- Shared batch for serialized children of *this* parent
  v_expiration_date      commodity.Expiration_Date%TYPE;
  v_quantity_to_create   commodity.Quantity%TYPE; -- Quantity for the new child instance

BEGIN
  -- Step 1: Create the new child productInstance
  INSERT INTO productInstance (Product_ID, Date_Manufactured, Is_Recalled)
  VALUES (170.0, TIMESTAMP '2025-04-11 04:26:07', 0)
  RETURNING Instance_ID INTO v_new_child_instance_id;

  -- Step 2: Create the corresponding subtype record
  IF v_child_category = 'Commodity' THEN
    -- Find max existing Batch_Number for this specific Child_PID
    SELECT NVL(MAX(c.Batch_Number), 0) INTO v_max_existing_batch_lot
    FROM commodity c JOIN productInstance pi ON c.Instance_ID = pi.Instance_ID
    WHERE pi.Product_ID = 170.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next batch

    v_expiration_date := TIMESTAMP '2025-04-11 04:26:07' + INTERVAL '481' DAY;
    v_quantity_to_create := ROUND(1.4, 1);

    INSERT INTO commodity (Instance_ID, Batch_Number, Expiration_Date, Quantity)
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Packaged' THEN
    -- Find max existing Lot_Number for this specific Child_PID
    SELECT NVL(MAX(p.Lot_Number), 0) INTO v_max_existing_batch_lot
    FROM packaged p JOIN productInstance pi ON p.Instance_ID = pi.Instance_ID -- Assuming 'packaged' table name
    WHERE pi.Product_ID = 170.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next lot

    v_expiration_date := TIMESTAMP '2025-04-11 04:26:07' + INTERVAL '399' DAY;
    v_quantity_to_create := ROUND(1.4, 1);

    INSERT INTO packaged (Instance_ID, Lot_Number, Expiration_Date, Quantity) -- Assuming 'packaged' table name
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Serialized' THEN
    -- Assign a unique serial number
    -- Using Instance ID guarantees uniqueness within this context
    v_serial_number := 'SN-' || TO_CHAR(170.0) || '-' || TO_CHAR(v_new_child_instance_id) || '-' || SUBSTR(SYS_GUID(),1,8);
    -- Assign a batch number - use Product_ID of the *parent* instance as the batch for simplicity? Or a sequence?
    -- Let's use the Parent_IID itself as a simple batch identifier for this run.
    v_batch_number := 86.0; -- All children created FOR this parent get same batch number

    INSERT INTO serialized (Instance_ID, Serial_Number, Batch_Number)
    VALUES (v_new_child_instance_id, v_serial_number, v_batch_number);

    -- Quantity for usesComponent link for serialized is typically 1
    v_quantity_to_create := 1;

  END IF;

  -- Step 3: Create the usesComponent link
  -- Quantity_Used is the Quantity_Needed from needsComponent (which matches child quantity for non-serialized)
  IF v_child_category IN ('Commodity', 'Packaged', 'Serialized') THEN -- Only insert if subtype was handled
      INSERT INTO usesComponent (Parent_IID, Child_IID, Quantity_Used)
      VALUES (86.0, v_new_child_instance_id, ROUND(1.4, 1)); -- Use rounded quantity needed
  END IF;

EXCEPTION
  WHEN OTHERS THEN
    DBMS_OUTPUT.PUT_LINE('Error processing Parent_IID=' || 86.0 || ', Child_PID=' || 170.0 || ': ' || SQLERRM);
    -- Decide if you want to rollback just this block or let the main exception handler catch it
END;
/
DECLARE
  v_new_child_instance_id productInstance.Instance_ID%TYPE;
  v_child_category        product.Category%TYPE := 'Commodity'; -- Pass category
  v_max_existing_batch_lot NUMBER;
  v_next_batch_lot_num   NUMBER;
  v_serial_number        serialized.Serial_Number%TYPE;
  v_batch_number         serialized.Batch_Number%TYPE; -- Shared batch for serialized children of *this* parent
  v_expiration_date      commodity.Expiration_Date%TYPE;
  v_quantity_to_create   commodity.Quantity%TYPE; -- Quantity for the new child instance

BEGIN
  -- Step 1: Create the new child productInstance
  INSERT INTO productInstance (Product_ID, Date_Manufactured, Is_Recalled)
  VALUES (154.0, TIMESTAMP '2024-08-27 08:09:03', 0)
  RETURNING Instance_ID INTO v_new_child_instance_id;

  -- Step 2: Create the corresponding subtype record
  IF v_child_category = 'Commodity' THEN
    -- Find max existing Batch_Number for this specific Child_PID
    SELECT NVL(MAX(c.Batch_Number), 0) INTO v_max_existing_batch_lot
    FROM commodity c JOIN productInstance pi ON c.Instance_ID = pi.Instance_ID
    WHERE pi.Product_ID = 154.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next batch

    v_expiration_date := TIMESTAMP '2024-08-27 08:09:03' + INTERVAL '440' DAY;
    v_quantity_to_create := ROUND(1.9, 1);

    INSERT INTO commodity (Instance_ID, Batch_Number, Expiration_Date, Quantity)
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Packaged' THEN
    -- Find max existing Lot_Number for this specific Child_PID
    SELECT NVL(MAX(p.Lot_Number), 0) INTO v_max_existing_batch_lot
    FROM packaged p JOIN productInstance pi ON p.Instance_ID = pi.Instance_ID -- Assuming 'packaged' table name
    WHERE pi.Product_ID = 154.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next lot

    v_expiration_date := TIMESTAMP '2024-08-27 08:09:03' + INTERVAL '276' DAY;
    v_quantity_to_create := ROUND(1.9, 1);

    INSERT INTO packaged (Instance_ID, Lot_Number, Expiration_Date, Quantity) -- Assuming 'packaged' table name
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Serialized' THEN
    -- Assign a unique serial number
    -- Using Instance ID guarantees uniqueness within this context
    v_serial_number := 'SN-' || TO_CHAR(154.0) || '-' || TO_CHAR(v_new_child_instance_id) || '-' || SUBSTR(SYS_GUID(),1,8);
    -- Assign a batch number - use Product_ID of the *parent* instance as the batch for simplicity? Or a sequence?
    -- Let's use the Parent_IID itself as a simple batch identifier for this run.
    v_batch_number := 86.0; -- All children created FOR this parent get same batch number

    INSERT INTO serialized (Instance_ID, Serial_Number, Batch_Number)
    VALUES (v_new_child_instance_id, v_serial_number, v_batch_number);

    -- Quantity for usesComponent link for serialized is typically 1
    v_quantity_to_create := 1;

  END IF;

  -- Step 3: Create the usesComponent link
  -- Quantity_Used is the Quantity_Needed from needsComponent (which matches child quantity for non-serialized)
  IF v_child_category IN ('Commodity', 'Packaged', 'Serialized') THEN -- Only insert if subtype was handled
      INSERT INTO usesComponent (Parent_IID, Child_IID, Quantity_Used)
      VALUES (86.0, v_new_child_instance_id, ROUND(1.9, 1)); -- Use rounded quantity needed
  END IF;

EXCEPTION
  WHEN OTHERS THEN
    DBMS_OUTPUT.PUT_LINE('Error processing Parent_IID=' || 86.0 || ', Child_PID=' || 154.0 || ': ' || SQLERRM);
    -- Decide if you want to rollback just this block or let the main exception handler catch it
END;
/
DECLARE
  v_new_child_instance_id productInstance.Instance_ID%TYPE;
  v_child_category        product.Category%TYPE := 'Commodity'; -- Pass category
  v_max_existing_batch_lot NUMBER;
  v_next_batch_lot_num   NUMBER;
  v_serial_number        serialized.Serial_Number%TYPE;
  v_batch_number         serialized.Batch_Number%TYPE; -- Shared batch for serialized children of *this* parent
  v_expiration_date      commodity.Expiration_Date%TYPE;
  v_quantity_to_create   commodity.Quantity%TYPE; -- Quantity for the new child instance

BEGIN
  -- Step 1: Create the new child productInstance
  INSERT INTO productInstance (Product_ID, Date_Manufactured, Is_Recalled)
  VALUES (144.0, TIMESTAMP '2024-06-13 00:38:23', 0)
  RETURNING Instance_ID INTO v_new_child_instance_id;

  -- Step 2: Create the corresponding subtype record
  IF v_child_category = 'Commodity' THEN
    -- Find max existing Batch_Number for this specific Child_PID
    SELECT NVL(MAX(c.Batch_Number), 0) INTO v_max_existing_batch_lot
    FROM commodity c JOIN productInstance pi ON c.Instance_ID = pi.Instance_ID
    WHERE pi.Product_ID = 144.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next batch

    v_expiration_date := TIMESTAMP '2024-06-13 00:38:23' + INTERVAL '241' DAY;
    v_quantity_to_create := ROUND(1.5, 1);

    INSERT INTO commodity (Instance_ID, Batch_Number, Expiration_Date, Quantity)
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Packaged' THEN
    -- Find max existing Lot_Number for this specific Child_PID
    SELECT NVL(MAX(p.Lot_Number), 0) INTO v_max_existing_batch_lot
    FROM packaged p JOIN productInstance pi ON p.Instance_ID = pi.Instance_ID -- Assuming 'packaged' table name
    WHERE pi.Product_ID = 144.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next lot

    v_expiration_date := TIMESTAMP '2024-06-13 00:38:23' + INTERVAL '727' DAY;
    v_quantity_to_create := ROUND(1.5, 1);

    INSERT INTO packaged (Instance_ID, Lot_Number, Expiration_Date, Quantity) -- Assuming 'packaged' table name
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Serialized' THEN
    -- Assign a unique serial number
    -- Using Instance ID guarantees uniqueness within this context
    v_serial_number := 'SN-' || TO_CHAR(144.0) || '-' || TO_CHAR(v_new_child_instance_id) || '-' || SUBSTR(SYS_GUID(),1,8);
    -- Assign a batch number - use Product_ID of the *parent* instance as the batch for simplicity? Or a sequence?
    -- Let's use the Parent_IID itself as a simple batch identifier for this run.
    v_batch_number := 86.0; -- All children created FOR this parent get same batch number

    INSERT INTO serialized (Instance_ID, Serial_Number, Batch_Number)
    VALUES (v_new_child_instance_id, v_serial_number, v_batch_number);

    -- Quantity for usesComponent link for serialized is typically 1
    v_quantity_to_create := 1;

  END IF;

  -- Step 3: Create the usesComponent link
  -- Quantity_Used is the Quantity_Needed from needsComponent (which matches child quantity for non-serialized)
  IF v_child_category IN ('Commodity', 'Packaged', 'Serialized') THEN -- Only insert if subtype was handled
      INSERT INTO usesComponent (Parent_IID, Child_IID, Quantity_Used)
      VALUES (86.0, v_new_child_instance_id, ROUND(1.5, 1)); -- Use rounded quantity needed
  END IF;

EXCEPTION
  WHEN OTHERS THEN
    DBMS_OUTPUT.PUT_LINE('Error processing Parent_IID=' || 86.0 || ', Child_PID=' || 144.0 || ': ' || SQLERRM);
    -- Decide if you want to rollback just this block or let the main exception handler catch it
END;
/
DECLARE
  v_new_child_instance_id productInstance.Instance_ID%TYPE;
  v_child_category        product.Category%TYPE := 'Commodity'; -- Pass category
  v_max_existing_batch_lot NUMBER;
  v_next_batch_lot_num   NUMBER;
  v_serial_number        serialized.Serial_Number%TYPE;
  v_batch_number         serialized.Batch_Number%TYPE; -- Shared batch for serialized children of *this* parent
  v_expiration_date      commodity.Expiration_Date%TYPE;
  v_quantity_to_create   commodity.Quantity%TYPE; -- Quantity for the new child instance

BEGIN
  -- Step 1: Create the new child productInstance
  INSERT INTO productInstance (Product_ID, Date_Manufactured, Is_Recalled)
  VALUES (106.0, TIMESTAMP '2024-08-25 16:23:20', 0)
  RETURNING Instance_ID INTO v_new_child_instance_id;

  -- Step 2: Create the corresponding subtype record
  IF v_child_category = 'Commodity' THEN
    -- Find max existing Batch_Number for this specific Child_PID
    SELECT NVL(MAX(c.Batch_Number), 0) INTO v_max_existing_batch_lot
    FROM commodity c JOIN productInstance pi ON c.Instance_ID = pi.Instance_ID
    WHERE pi.Product_ID = 106.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next batch

    v_expiration_date := TIMESTAMP '2024-08-25 16:23:20' + INTERVAL '99' DAY;
    v_quantity_to_create := ROUND(1.1, 1);

    INSERT INTO commodity (Instance_ID, Batch_Number, Expiration_Date, Quantity)
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Packaged' THEN
    -- Find max existing Lot_Number for this specific Child_PID
    SELECT NVL(MAX(p.Lot_Number), 0) INTO v_max_existing_batch_lot
    FROM packaged p JOIN productInstance pi ON p.Instance_ID = pi.Instance_ID -- Assuming 'packaged' table name
    WHERE pi.Product_ID = 106.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next lot

    v_expiration_date := TIMESTAMP '2024-08-25 16:23:20' + INTERVAL '138' DAY;
    v_quantity_to_create := ROUND(1.1, 1);

    INSERT INTO packaged (Instance_ID, Lot_Number, Expiration_Date, Quantity) -- Assuming 'packaged' table name
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Serialized' THEN
    -- Assign a unique serial number
    -- Using Instance ID guarantees uniqueness within this context
    v_serial_number := 'SN-' || TO_CHAR(106.0) || '-' || TO_CHAR(v_new_child_instance_id) || '-' || SUBSTR(SYS_GUID(),1,8);
    -- Assign a batch number - use Product_ID of the *parent* instance as the batch for simplicity? Or a sequence?
    -- Let's use the Parent_IID itself as a simple batch identifier for this run.
    v_batch_number := 86.0; -- All children created FOR this parent get same batch number

    INSERT INTO serialized (Instance_ID, Serial_Number, Batch_Number)
    VALUES (v_new_child_instance_id, v_serial_number, v_batch_number);

    -- Quantity for usesComponent link for serialized is typically 1
    v_quantity_to_create := 1;

  END IF;

  -- Step 3: Create the usesComponent link
  -- Quantity_Used is the Quantity_Needed from needsComponent (which matches child quantity for non-serialized)
  IF v_child_category IN ('Commodity', 'Packaged', 'Serialized') THEN -- Only insert if subtype was handled
      INSERT INTO usesComponent (Parent_IID, Child_IID, Quantity_Used)
      VALUES (86.0, v_new_child_instance_id, ROUND(1.1, 1)); -- Use rounded quantity needed
  END IF;

EXCEPTION
  WHEN OTHERS THEN
    DBMS_OUTPUT.PUT_LINE('Error processing Parent_IID=' || 86.0 || ', Child_PID=' || 106.0 || ': ' || SQLERRM);
    -- Decide if you want to rollback just this block or let the main exception handler catch it
END;
/
DECLARE
  v_new_child_instance_id productInstance.Instance_ID%TYPE;
  v_child_category        product.Category%TYPE := 'Commodity'; -- Pass category
  v_max_existing_batch_lot NUMBER;
  v_next_batch_lot_num   NUMBER;
  v_serial_number        serialized.Serial_Number%TYPE;
  v_batch_number         serialized.Batch_Number%TYPE; -- Shared batch for serialized children of *this* parent
  v_expiration_date      commodity.Expiration_Date%TYPE;
  v_quantity_to_create   commodity.Quantity%TYPE; -- Quantity for the new child instance

BEGIN
  -- Step 1: Create the new child productInstance
  INSERT INTO productInstance (Product_ID, Date_Manufactured, Is_Recalled)
  VALUES (170.0, TIMESTAMP '2024-07-26 10:31:49', 0)
  RETURNING Instance_ID INTO v_new_child_instance_id;

  -- Step 2: Create the corresponding subtype record
  IF v_child_category = 'Commodity' THEN
    -- Find max existing Batch_Number for this specific Child_PID
    SELECT NVL(MAX(c.Batch_Number), 0) INTO v_max_existing_batch_lot
    FROM commodity c JOIN productInstance pi ON c.Instance_ID = pi.Instance_ID
    WHERE pi.Product_ID = 170.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next batch

    v_expiration_date := TIMESTAMP '2024-07-26 10:31:49' + INTERVAL '436' DAY;
    v_quantity_to_create := ROUND(1.4, 1);

    INSERT INTO commodity (Instance_ID, Batch_Number, Expiration_Date, Quantity)
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Packaged' THEN
    -- Find max existing Lot_Number for this specific Child_PID
    SELECT NVL(MAX(p.Lot_Number), 0) INTO v_max_existing_batch_lot
    FROM packaged p JOIN productInstance pi ON p.Instance_ID = pi.Instance_ID -- Assuming 'packaged' table name
    WHERE pi.Product_ID = 170.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next lot

    v_expiration_date := TIMESTAMP '2024-07-26 10:31:49' + INTERVAL '359' DAY;
    v_quantity_to_create := ROUND(1.4, 1);

    INSERT INTO packaged (Instance_ID, Lot_Number, Expiration_Date, Quantity) -- Assuming 'packaged' table name
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Serialized' THEN
    -- Assign a unique serial number
    -- Using Instance ID guarantees uniqueness within this context
    v_serial_number := 'SN-' || TO_CHAR(170.0) || '-' || TO_CHAR(v_new_child_instance_id) || '-' || SUBSTR(SYS_GUID(),1,8);
    -- Assign a batch number - use Product_ID of the *parent* instance as the batch for simplicity? Or a sequence?
    -- Let's use the Parent_IID itself as a simple batch identifier for this run.
    v_batch_number := 87.0; -- All children created FOR this parent get same batch number

    INSERT INTO serialized (Instance_ID, Serial_Number, Batch_Number)
    VALUES (v_new_child_instance_id, v_serial_number, v_batch_number);

    -- Quantity for usesComponent link for serialized is typically 1
    v_quantity_to_create := 1;

  END IF;

  -- Step 3: Create the usesComponent link
  -- Quantity_Used is the Quantity_Needed from needsComponent (which matches child quantity for non-serialized)
  IF v_child_category IN ('Commodity', 'Packaged', 'Serialized') THEN -- Only insert if subtype was handled
      INSERT INTO usesComponent (Parent_IID, Child_IID, Quantity_Used)
      VALUES (87.0, v_new_child_instance_id, ROUND(1.4, 1)); -- Use rounded quantity needed
  END IF;

EXCEPTION
  WHEN OTHERS THEN
    DBMS_OUTPUT.PUT_LINE('Error processing Parent_IID=' || 87.0 || ', Child_PID=' || 170.0 || ': ' || SQLERRM);
    -- Decide if you want to rollback just this block or let the main exception handler catch it
END;
/
DECLARE
  v_new_child_instance_id productInstance.Instance_ID%TYPE;
  v_child_category        product.Category%TYPE := 'Commodity'; -- Pass category
  v_max_existing_batch_lot NUMBER;
  v_next_batch_lot_num   NUMBER;
  v_serial_number        serialized.Serial_Number%TYPE;
  v_batch_number         serialized.Batch_Number%TYPE; -- Shared batch for serialized children of *this* parent
  v_expiration_date      commodity.Expiration_Date%TYPE;
  v_quantity_to_create   commodity.Quantity%TYPE; -- Quantity for the new child instance

BEGIN
  -- Step 1: Create the new child productInstance
  INSERT INTO productInstance (Product_ID, Date_Manufactured, Is_Recalled)
  VALUES (154.0, TIMESTAMP '2024-11-06 06:06:10', 0)
  RETURNING Instance_ID INTO v_new_child_instance_id;

  -- Step 2: Create the corresponding subtype record
  IF v_child_category = 'Commodity' THEN
    -- Find max existing Batch_Number for this specific Child_PID
    SELECT NVL(MAX(c.Batch_Number), 0) INTO v_max_existing_batch_lot
    FROM commodity c JOIN productInstance pi ON c.Instance_ID = pi.Instance_ID
    WHERE pi.Product_ID = 154.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next batch

    v_expiration_date := TIMESTAMP '2024-11-06 06:06:10' + INTERVAL '132' DAY;
    v_quantity_to_create := ROUND(1.9, 1);

    INSERT INTO commodity (Instance_ID, Batch_Number, Expiration_Date, Quantity)
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Packaged' THEN
    -- Find max existing Lot_Number for this specific Child_PID
    SELECT NVL(MAX(p.Lot_Number), 0) INTO v_max_existing_batch_lot
    FROM packaged p JOIN productInstance pi ON p.Instance_ID = pi.Instance_ID -- Assuming 'packaged' table name
    WHERE pi.Product_ID = 154.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next lot

    v_expiration_date := TIMESTAMP '2024-11-06 06:06:10' + INTERVAL '221' DAY;
    v_quantity_to_create := ROUND(1.9, 1);

    INSERT INTO packaged (Instance_ID, Lot_Number, Expiration_Date, Quantity) -- Assuming 'packaged' table name
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Serialized' THEN
    -- Assign a unique serial number
    -- Using Instance ID guarantees uniqueness within this context
    v_serial_number := 'SN-' || TO_CHAR(154.0) || '-' || TO_CHAR(v_new_child_instance_id) || '-' || SUBSTR(SYS_GUID(),1,8);
    -- Assign a batch number - use Product_ID of the *parent* instance as the batch for simplicity? Or a sequence?
    -- Let's use the Parent_IID itself as a simple batch identifier for this run.
    v_batch_number := 87.0; -- All children created FOR this parent get same batch number

    INSERT INTO serialized (Instance_ID, Serial_Number, Batch_Number)
    VALUES (v_new_child_instance_id, v_serial_number, v_batch_number);

    -- Quantity for usesComponent link for serialized is typically 1
    v_quantity_to_create := 1;

  END IF;

  -- Step 3: Create the usesComponent link
  -- Quantity_Used is the Quantity_Needed from needsComponent (which matches child quantity for non-serialized)
  IF v_child_category IN ('Commodity', 'Packaged', 'Serialized') THEN -- Only insert if subtype was handled
      INSERT INTO usesComponent (Parent_IID, Child_IID, Quantity_Used)
      VALUES (87.0, v_new_child_instance_id, ROUND(1.9, 1)); -- Use rounded quantity needed
  END IF;

EXCEPTION
  WHEN OTHERS THEN
    DBMS_OUTPUT.PUT_LINE('Error processing Parent_IID=' || 87.0 || ', Child_PID=' || 154.0 || ': ' || SQLERRM);
    -- Decide if you want to rollback just this block or let the main exception handler catch it
END;
/
DECLARE
  v_new_child_instance_id productInstance.Instance_ID%TYPE;
  v_child_category        product.Category%TYPE := 'Commodity'; -- Pass category
  v_max_existing_batch_lot NUMBER;
  v_next_batch_lot_num   NUMBER;
  v_serial_number        serialized.Serial_Number%TYPE;
  v_batch_number         serialized.Batch_Number%TYPE; -- Shared batch for serialized children of *this* parent
  v_expiration_date      commodity.Expiration_Date%TYPE;
  v_quantity_to_create   commodity.Quantity%TYPE; -- Quantity for the new child instance

BEGIN
  -- Step 1: Create the new child productInstance
  INSERT INTO productInstance (Product_ID, Date_Manufactured, Is_Recalled)
  VALUES (144.0, TIMESTAMP '2024-05-16 12:12:40', 0)
  RETURNING Instance_ID INTO v_new_child_instance_id;

  -- Step 2: Create the corresponding subtype record
  IF v_child_category = 'Commodity' THEN
    -- Find max existing Batch_Number for this specific Child_PID
    SELECT NVL(MAX(c.Batch_Number), 0) INTO v_max_existing_batch_lot
    FROM commodity c JOIN productInstance pi ON c.Instance_ID = pi.Instance_ID
    WHERE pi.Product_ID = 144.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next batch

    v_expiration_date := TIMESTAMP '2024-05-16 12:12:40' + INTERVAL '86' DAY;
    v_quantity_to_create := ROUND(1.5, 1);

    INSERT INTO commodity (Instance_ID, Batch_Number, Expiration_Date, Quantity)
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Packaged' THEN
    -- Find max existing Lot_Number for this specific Child_PID
    SELECT NVL(MAX(p.Lot_Number), 0) INTO v_max_existing_batch_lot
    FROM packaged p JOIN productInstance pi ON p.Instance_ID = pi.Instance_ID -- Assuming 'packaged' table name
    WHERE pi.Product_ID = 144.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next lot

    v_expiration_date := TIMESTAMP '2024-05-16 12:12:40' + INTERVAL '641' DAY;
    v_quantity_to_create := ROUND(1.5, 1);

    INSERT INTO packaged (Instance_ID, Lot_Number, Expiration_Date, Quantity) -- Assuming 'packaged' table name
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Serialized' THEN
    -- Assign a unique serial number
    -- Using Instance ID guarantees uniqueness within this context
    v_serial_number := 'SN-' || TO_CHAR(144.0) || '-' || TO_CHAR(v_new_child_instance_id) || '-' || SUBSTR(SYS_GUID(),1,8);
    -- Assign a batch number - use Product_ID of the *parent* instance as the batch for simplicity? Or a sequence?
    -- Let's use the Parent_IID itself as a simple batch identifier for this run.
    v_batch_number := 87.0; -- All children created FOR this parent get same batch number

    INSERT INTO serialized (Instance_ID, Serial_Number, Batch_Number)
    VALUES (v_new_child_instance_id, v_serial_number, v_batch_number);

    -- Quantity for usesComponent link for serialized is typically 1
    v_quantity_to_create := 1;

  END IF;

  -- Step 3: Create the usesComponent link
  -- Quantity_Used is the Quantity_Needed from needsComponent (which matches child quantity for non-serialized)
  IF v_child_category IN ('Commodity', 'Packaged', 'Serialized') THEN -- Only insert if subtype was handled
      INSERT INTO usesComponent (Parent_IID, Child_IID, Quantity_Used)
      VALUES (87.0, v_new_child_instance_id, ROUND(1.5, 1)); -- Use rounded quantity needed
  END IF;

EXCEPTION
  WHEN OTHERS THEN
    DBMS_OUTPUT.PUT_LINE('Error processing Parent_IID=' || 87.0 || ', Child_PID=' || 144.0 || ': ' || SQLERRM);
    -- Decide if you want to rollback just this block or let the main exception handler catch it
END;
/
DECLARE
  v_new_child_instance_id productInstance.Instance_ID%TYPE;
  v_child_category        product.Category%TYPE := 'Commodity'; -- Pass category
  v_max_existing_batch_lot NUMBER;
  v_next_batch_lot_num   NUMBER;
  v_serial_number        serialized.Serial_Number%TYPE;
  v_batch_number         serialized.Batch_Number%TYPE; -- Shared batch for serialized children of *this* parent
  v_expiration_date      commodity.Expiration_Date%TYPE;
  v_quantity_to_create   commodity.Quantity%TYPE; -- Quantity for the new child instance

BEGIN
  -- Step 1: Create the new child productInstance
  INSERT INTO productInstance (Product_ID, Date_Manufactured, Is_Recalled)
  VALUES (106.0, TIMESTAMP '2024-05-08 01:58:42', 0)
  RETURNING Instance_ID INTO v_new_child_instance_id;

  -- Step 2: Create the corresponding subtype record
  IF v_child_category = 'Commodity' THEN
    -- Find max existing Batch_Number for this specific Child_PID
    SELECT NVL(MAX(c.Batch_Number), 0) INTO v_max_existing_batch_lot
    FROM commodity c JOIN productInstance pi ON c.Instance_ID = pi.Instance_ID
    WHERE pi.Product_ID = 106.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next batch

    v_expiration_date := TIMESTAMP '2024-05-08 01:58:42' + INTERVAL '251' DAY;
    v_quantity_to_create := ROUND(1.1, 1);

    INSERT INTO commodity (Instance_ID, Batch_Number, Expiration_Date, Quantity)
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Packaged' THEN
    -- Find max existing Lot_Number for this specific Child_PID
    SELECT NVL(MAX(p.Lot_Number), 0) INTO v_max_existing_batch_lot
    FROM packaged p JOIN productInstance pi ON p.Instance_ID = pi.Instance_ID -- Assuming 'packaged' table name
    WHERE pi.Product_ID = 106.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next lot

    v_expiration_date := TIMESTAMP '2024-05-08 01:58:42' + INTERVAL '729' DAY;
    v_quantity_to_create := ROUND(1.1, 1);

    INSERT INTO packaged (Instance_ID, Lot_Number, Expiration_Date, Quantity) -- Assuming 'packaged' table name
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Serialized' THEN
    -- Assign a unique serial number
    -- Using Instance ID guarantees uniqueness within this context
    v_serial_number := 'SN-' || TO_CHAR(106.0) || '-' || TO_CHAR(v_new_child_instance_id) || '-' || SUBSTR(SYS_GUID(),1,8);
    -- Assign a batch number - use Product_ID of the *parent* instance as the batch for simplicity? Or a sequence?
    -- Let's use the Parent_IID itself as a simple batch identifier for this run.
    v_batch_number := 87.0; -- All children created FOR this parent get same batch number

    INSERT INTO serialized (Instance_ID, Serial_Number, Batch_Number)
    VALUES (v_new_child_instance_id, v_serial_number, v_batch_number);

    -- Quantity for usesComponent link for serialized is typically 1
    v_quantity_to_create := 1;

  END IF;

  -- Step 3: Create the usesComponent link
  -- Quantity_Used is the Quantity_Needed from needsComponent (which matches child quantity for non-serialized)
  IF v_child_category IN ('Commodity', 'Packaged', 'Serialized') THEN -- Only insert if subtype was handled
      INSERT INTO usesComponent (Parent_IID, Child_IID, Quantity_Used)
      VALUES (87.0, v_new_child_instance_id, ROUND(1.1, 1)); -- Use rounded quantity needed
  END IF;

EXCEPTION
  WHEN OTHERS THEN
    DBMS_OUTPUT.PUT_LINE('Error processing Parent_IID=' || 87.0 || ', Child_PID=' || 106.0 || ': ' || SQLERRM);
    -- Decide if you want to rollback just this block or let the main exception handler catch it
END;
/
DECLARE
  v_new_child_instance_id productInstance.Instance_ID%TYPE;
  v_child_category        product.Category%TYPE := 'Commodity'; -- Pass category
  v_max_existing_batch_lot NUMBER;
  v_next_batch_lot_num   NUMBER;
  v_serial_number        serialized.Serial_Number%TYPE;
  v_batch_number         serialized.Batch_Number%TYPE; -- Shared batch for serialized children of *this* parent
  v_expiration_date      commodity.Expiration_Date%TYPE;
  v_quantity_to_create   commodity.Quantity%TYPE; -- Quantity for the new child instance

BEGIN
  -- Step 1: Create the new child productInstance
  INSERT INTO productInstance (Product_ID, Date_Manufactured, Is_Recalled)
  VALUES (166.0, TIMESTAMP '2024-05-12 12:30:49', 0)
  RETURNING Instance_ID INTO v_new_child_instance_id;

  -- Step 2: Create the corresponding subtype record
  IF v_child_category = 'Commodity' THEN
    -- Find max existing Batch_Number for this specific Child_PID
    SELECT NVL(MAX(c.Batch_Number), 0) INTO v_max_existing_batch_lot
    FROM commodity c JOIN productInstance pi ON c.Instance_ID = pi.Instance_ID
    WHERE pi.Product_ID = 166.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next batch

    v_expiration_date := TIMESTAMP '2024-05-12 12:30:49' + INTERVAL '536' DAY;
    v_quantity_to_create := ROUND(0.9, 1);

    INSERT INTO commodity (Instance_ID, Batch_Number, Expiration_Date, Quantity)
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Packaged' THEN
    -- Find max existing Lot_Number for this specific Child_PID
    SELECT NVL(MAX(p.Lot_Number), 0) INTO v_max_existing_batch_lot
    FROM packaged p JOIN productInstance pi ON p.Instance_ID = pi.Instance_ID -- Assuming 'packaged' table name
    WHERE pi.Product_ID = 166.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next lot

    v_expiration_date := TIMESTAMP '2024-05-12 12:30:49' + INTERVAL '571' DAY;
    v_quantity_to_create := ROUND(0.9, 1);

    INSERT INTO packaged (Instance_ID, Lot_Number, Expiration_Date, Quantity) -- Assuming 'packaged' table name
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Serialized' THEN
    -- Assign a unique serial number
    -- Using Instance ID guarantees uniqueness within this context
    v_serial_number := 'SN-' || TO_CHAR(166.0) || '-' || TO_CHAR(v_new_child_instance_id) || '-' || SUBSTR(SYS_GUID(),1,8);
    -- Assign a batch number - use Product_ID of the *parent* instance as the batch for simplicity? Or a sequence?
    -- Let's use the Parent_IID itself as a simple batch identifier for this run.
    v_batch_number := 110.0; -- All children created FOR this parent get same batch number

    INSERT INTO serialized (Instance_ID, Serial_Number, Batch_Number)
    VALUES (v_new_child_instance_id, v_serial_number, v_batch_number);

    -- Quantity for usesComponent link for serialized is typically 1
    v_quantity_to_create := 1;

  END IF;

  -- Step 3: Create the usesComponent link
  -- Quantity_Used is the Quantity_Needed from needsComponent (which matches child quantity for non-serialized)
  IF v_child_category IN ('Commodity', 'Packaged', 'Serialized') THEN -- Only insert if subtype was handled
      INSERT INTO usesComponent (Parent_IID, Child_IID, Quantity_Used)
      VALUES (110.0, v_new_child_instance_id, ROUND(0.9, 1)); -- Use rounded quantity needed
  END IF;

EXCEPTION
  WHEN OTHERS THEN
    DBMS_OUTPUT.PUT_LINE('Error processing Parent_IID=' || 110.0 || ', Child_PID=' || 166.0 || ': ' || SQLERRM);
    -- Decide if you want to rollback just this block or let the main exception handler catch it
END;
/
DECLARE
  v_new_child_instance_id productInstance.Instance_ID%TYPE;
  v_child_category        product.Category%TYPE := 'Commodity'; -- Pass category
  v_max_existing_batch_lot NUMBER;
  v_next_batch_lot_num   NUMBER;
  v_serial_number        serialized.Serial_Number%TYPE;
  v_batch_number         serialized.Batch_Number%TYPE; -- Shared batch for serialized children of *this* parent
  v_expiration_date      commodity.Expiration_Date%TYPE;
  v_quantity_to_create   commodity.Quantity%TYPE; -- Quantity for the new child instance

BEGIN
  -- Step 1: Create the new child productInstance
  INSERT INTO productInstance (Product_ID, Date_Manufactured, Is_Recalled)
  VALUES (189.0, TIMESTAMP '2025-03-11 12:28:40', 0)
  RETURNING Instance_ID INTO v_new_child_instance_id;

  -- Step 2: Create the corresponding subtype record
  IF v_child_category = 'Commodity' THEN
    -- Find max existing Batch_Number for this specific Child_PID
    SELECT NVL(MAX(c.Batch_Number), 0) INTO v_max_existing_batch_lot
    FROM commodity c JOIN productInstance pi ON c.Instance_ID = pi.Instance_ID
    WHERE pi.Product_ID = 189.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next batch

    v_expiration_date := TIMESTAMP '2025-03-11 12:28:40' + INTERVAL '657' DAY;
    v_quantity_to_create := ROUND(0.8, 1);

    INSERT INTO commodity (Instance_ID, Batch_Number, Expiration_Date, Quantity)
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Packaged' THEN
    -- Find max existing Lot_Number for this specific Child_PID
    SELECT NVL(MAX(p.Lot_Number), 0) INTO v_max_existing_batch_lot
    FROM packaged p JOIN productInstance pi ON p.Instance_ID = pi.Instance_ID -- Assuming 'packaged' table name
    WHERE pi.Product_ID = 189.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next lot

    v_expiration_date := TIMESTAMP '2025-03-11 12:28:40' + INTERVAL '482' DAY;
    v_quantity_to_create := ROUND(0.8, 1);

    INSERT INTO packaged (Instance_ID, Lot_Number, Expiration_Date, Quantity) -- Assuming 'packaged' table name
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Serialized' THEN
    -- Assign a unique serial number
    -- Using Instance ID guarantees uniqueness within this context
    v_serial_number := 'SN-' || TO_CHAR(189.0) || '-' || TO_CHAR(v_new_child_instance_id) || '-' || SUBSTR(SYS_GUID(),1,8);
    -- Assign a batch number - use Product_ID of the *parent* instance as the batch for simplicity? Or a sequence?
    -- Let's use the Parent_IID itself as a simple batch identifier for this run.
    v_batch_number := 110.0; -- All children created FOR this parent get same batch number

    INSERT INTO serialized (Instance_ID, Serial_Number, Batch_Number)
    VALUES (v_new_child_instance_id, v_serial_number, v_batch_number);

    -- Quantity for usesComponent link for serialized is typically 1
    v_quantity_to_create := 1;

  END IF;

  -- Step 3: Create the usesComponent link
  -- Quantity_Used is the Quantity_Needed from needsComponent (which matches child quantity for non-serialized)
  IF v_child_category IN ('Commodity', 'Packaged', 'Serialized') THEN -- Only insert if subtype was handled
      INSERT INTO usesComponent (Parent_IID, Child_IID, Quantity_Used)
      VALUES (110.0, v_new_child_instance_id, ROUND(0.8, 1)); -- Use rounded quantity needed
  END IF;

EXCEPTION
  WHEN OTHERS THEN
    DBMS_OUTPUT.PUT_LINE('Error processing Parent_IID=' || 110.0 || ', Child_PID=' || 189.0 || ': ' || SQLERRM);
    -- Decide if you want to rollback just this block or let the main exception handler catch it
END;
/
DECLARE
  v_new_child_instance_id productInstance.Instance_ID%TYPE;
  v_child_category        product.Category%TYPE := 'Commodity'; -- Pass category
  v_max_existing_batch_lot NUMBER;
  v_next_batch_lot_num   NUMBER;
  v_serial_number        serialized.Serial_Number%TYPE;
  v_batch_number         serialized.Batch_Number%TYPE; -- Shared batch for serialized children of *this* parent
  v_expiration_date      commodity.Expiration_Date%TYPE;
  v_quantity_to_create   commodity.Quantity%TYPE; -- Quantity for the new child instance

BEGIN
  -- Step 1: Create the new child productInstance
  INSERT INTO productInstance (Product_ID, Date_Manufactured, Is_Recalled)
  VALUES (166.0, TIMESTAMP '2024-09-09 00:45:45', 0)
  RETURNING Instance_ID INTO v_new_child_instance_id;

  -- Step 2: Create the corresponding subtype record
  IF v_child_category = 'Commodity' THEN
    -- Find max existing Batch_Number for this specific Child_PID
    SELECT NVL(MAX(c.Batch_Number), 0) INTO v_max_existing_batch_lot
    FROM commodity c JOIN productInstance pi ON c.Instance_ID = pi.Instance_ID
    WHERE pi.Product_ID = 166.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next batch

    v_expiration_date := TIMESTAMP '2024-09-09 00:45:45' + INTERVAL '708' DAY;
    v_quantity_to_create := ROUND(0.9, 1);

    INSERT INTO commodity (Instance_ID, Batch_Number, Expiration_Date, Quantity)
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Packaged' THEN
    -- Find max existing Lot_Number for this specific Child_PID
    SELECT NVL(MAX(p.Lot_Number), 0) INTO v_max_existing_batch_lot
    FROM packaged p JOIN productInstance pi ON p.Instance_ID = pi.Instance_ID -- Assuming 'packaged' table name
    WHERE pi.Product_ID = 166.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next lot

    v_expiration_date := TIMESTAMP '2024-09-09 00:45:45' + INTERVAL '311' DAY;
    v_quantity_to_create := ROUND(0.9, 1);

    INSERT INTO packaged (Instance_ID, Lot_Number, Expiration_Date, Quantity) -- Assuming 'packaged' table name
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Serialized' THEN
    -- Assign a unique serial number
    -- Using Instance ID guarantees uniqueness within this context
    v_serial_number := 'SN-' || TO_CHAR(166.0) || '-' || TO_CHAR(v_new_child_instance_id) || '-' || SUBSTR(SYS_GUID(),1,8);
    -- Assign a batch number - use Product_ID of the *parent* instance as the batch for simplicity? Or a sequence?
    -- Let's use the Parent_IID itself as a simple batch identifier for this run.
    v_batch_number := 111.0; -- All children created FOR this parent get same batch number

    INSERT INTO serialized (Instance_ID, Serial_Number, Batch_Number)
    VALUES (v_new_child_instance_id, v_serial_number, v_batch_number);

    -- Quantity for usesComponent link for serialized is typically 1
    v_quantity_to_create := 1;

  END IF;

  -- Step 3: Create the usesComponent link
  -- Quantity_Used is the Quantity_Needed from needsComponent (which matches child quantity for non-serialized)
  IF v_child_category IN ('Commodity', 'Packaged', 'Serialized') THEN -- Only insert if subtype was handled
      INSERT INTO usesComponent (Parent_IID, Child_IID, Quantity_Used)
      VALUES (111.0, v_new_child_instance_id, ROUND(0.9, 1)); -- Use rounded quantity needed
  END IF;

EXCEPTION
  WHEN OTHERS THEN
    DBMS_OUTPUT.PUT_LINE('Error processing Parent_IID=' || 111.0 || ', Child_PID=' || 166.0 || ': ' || SQLERRM);
    -- Decide if you want to rollback just this block or let the main exception handler catch it
END;
/
DECLARE
  v_new_child_instance_id productInstance.Instance_ID%TYPE;
  v_child_category        product.Category%TYPE := 'Commodity'; -- Pass category
  v_max_existing_batch_lot NUMBER;
  v_next_batch_lot_num   NUMBER;
  v_serial_number        serialized.Serial_Number%TYPE;
  v_batch_number         serialized.Batch_Number%TYPE; -- Shared batch for serialized children of *this* parent
  v_expiration_date      commodity.Expiration_Date%TYPE;
  v_quantity_to_create   commodity.Quantity%TYPE; -- Quantity for the new child instance

BEGIN
  -- Step 1: Create the new child productInstance
  INSERT INTO productInstance (Product_ID, Date_Manufactured, Is_Recalled)
  VALUES (189.0, TIMESTAMP '2024-06-13 21:25:34', 0)
  RETURNING Instance_ID INTO v_new_child_instance_id;

  -- Step 2: Create the corresponding subtype record
  IF v_child_category = 'Commodity' THEN
    -- Find max existing Batch_Number for this specific Child_PID
    SELECT NVL(MAX(c.Batch_Number), 0) INTO v_max_existing_batch_lot
    FROM commodity c JOIN productInstance pi ON c.Instance_ID = pi.Instance_ID
    WHERE pi.Product_ID = 189.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next batch

    v_expiration_date := TIMESTAMP '2024-06-13 21:25:34' + INTERVAL '657' DAY;
    v_quantity_to_create := ROUND(0.8, 1);

    INSERT INTO commodity (Instance_ID, Batch_Number, Expiration_Date, Quantity)
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Packaged' THEN
    -- Find max existing Lot_Number for this specific Child_PID
    SELECT NVL(MAX(p.Lot_Number), 0) INTO v_max_existing_batch_lot
    FROM packaged p JOIN productInstance pi ON p.Instance_ID = pi.Instance_ID -- Assuming 'packaged' table name
    WHERE pi.Product_ID = 189.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next lot

    v_expiration_date := TIMESTAMP '2024-06-13 21:25:34' + INTERVAL '206' DAY;
    v_quantity_to_create := ROUND(0.8, 1);

    INSERT INTO packaged (Instance_ID, Lot_Number, Expiration_Date, Quantity) -- Assuming 'packaged' table name
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Serialized' THEN
    -- Assign a unique serial number
    -- Using Instance ID guarantees uniqueness within this context
    v_serial_number := 'SN-' || TO_CHAR(189.0) || '-' || TO_CHAR(v_new_child_instance_id) || '-' || SUBSTR(SYS_GUID(),1,8);
    -- Assign a batch number - use Product_ID of the *parent* instance as the batch for simplicity? Or a sequence?
    -- Let's use the Parent_IID itself as a simple batch identifier for this run.
    v_batch_number := 111.0; -- All children created FOR this parent get same batch number

    INSERT INTO serialized (Instance_ID, Serial_Number, Batch_Number)
    VALUES (v_new_child_instance_id, v_serial_number, v_batch_number);

    -- Quantity for usesComponent link for serialized is typically 1
    v_quantity_to_create := 1;

  END IF;

  -- Step 3: Create the usesComponent link
  -- Quantity_Used is the Quantity_Needed from needsComponent (which matches child quantity for non-serialized)
  IF v_child_category IN ('Commodity', 'Packaged', 'Serialized') THEN -- Only insert if subtype was handled
      INSERT INTO usesComponent (Parent_IID, Child_IID, Quantity_Used)
      VALUES (111.0, v_new_child_instance_id, ROUND(0.8, 1)); -- Use rounded quantity needed
  END IF;

EXCEPTION
  WHEN OTHERS THEN
    DBMS_OUTPUT.PUT_LINE('Error processing Parent_IID=' || 111.0 || ', Child_PID=' || 189.0 || ': ' || SQLERRM);
    -- Decide if you want to rollback just this block or let the main exception handler catch it
END;
/
DECLARE
  v_new_child_instance_id productInstance.Instance_ID%TYPE;
  v_child_category        product.Category%TYPE := 'Commodity'; -- Pass category
  v_max_existing_batch_lot NUMBER;
  v_next_batch_lot_num   NUMBER;
  v_serial_number        serialized.Serial_Number%TYPE;
  v_batch_number         serialized.Batch_Number%TYPE; -- Shared batch for serialized children of *this* parent
  v_expiration_date      commodity.Expiration_Date%TYPE;
  v_quantity_to_create   commodity.Quantity%TYPE; -- Quantity for the new child instance

BEGIN
  -- Step 1: Create the new child productInstance
  INSERT INTO productInstance (Product_ID, Date_Manufactured, Is_Recalled)
  VALUES (166.0, TIMESTAMP '2024-06-05 00:34:37', 0)
  RETURNING Instance_ID INTO v_new_child_instance_id;

  -- Step 2: Create the corresponding subtype record
  IF v_child_category = 'Commodity' THEN
    -- Find max existing Batch_Number for this specific Child_PID
    SELECT NVL(MAX(c.Batch_Number), 0) INTO v_max_existing_batch_lot
    FROM commodity c JOIN productInstance pi ON c.Instance_ID = pi.Instance_ID
    WHERE pi.Product_ID = 166.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next batch

    v_expiration_date := TIMESTAMP '2024-06-05 00:34:37' + INTERVAL '257' DAY;
    v_quantity_to_create := ROUND(0.9, 1);

    INSERT INTO commodity (Instance_ID, Batch_Number, Expiration_Date, Quantity)
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Packaged' THEN
    -- Find max existing Lot_Number for this specific Child_PID
    SELECT NVL(MAX(p.Lot_Number), 0) INTO v_max_existing_batch_lot
    FROM packaged p JOIN productInstance pi ON p.Instance_ID = pi.Instance_ID -- Assuming 'packaged' table name
    WHERE pi.Product_ID = 166.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next lot

    v_expiration_date := TIMESTAMP '2024-06-05 00:34:37' + INTERVAL '439' DAY;
    v_quantity_to_create := ROUND(0.9, 1);

    INSERT INTO packaged (Instance_ID, Lot_Number, Expiration_Date, Quantity) -- Assuming 'packaged' table name
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Serialized' THEN
    -- Assign a unique serial number
    -- Using Instance ID guarantees uniqueness within this context
    v_serial_number := 'SN-' || TO_CHAR(166.0) || '-' || TO_CHAR(v_new_child_instance_id) || '-' || SUBSTR(SYS_GUID(),1,8);
    -- Assign a batch number - use Product_ID of the *parent* instance as the batch for simplicity? Or a sequence?
    -- Let's use the Parent_IID itself as a simple batch identifier for this run.
    v_batch_number := 112.0; -- All children created FOR this parent get same batch number

    INSERT INTO serialized (Instance_ID, Serial_Number, Batch_Number)
    VALUES (v_new_child_instance_id, v_serial_number, v_batch_number);

    -- Quantity for usesComponent link for serialized is typically 1
    v_quantity_to_create := 1;

  END IF;

  -- Step 3: Create the usesComponent link
  -- Quantity_Used is the Quantity_Needed from needsComponent (which matches child quantity for non-serialized)
  IF v_child_category IN ('Commodity', 'Packaged', 'Serialized') THEN -- Only insert if subtype was handled
      INSERT INTO usesComponent (Parent_IID, Child_IID, Quantity_Used)
      VALUES (112.0, v_new_child_instance_id, ROUND(0.9, 1)); -- Use rounded quantity needed
  END IF;

EXCEPTION
  WHEN OTHERS THEN
    DBMS_OUTPUT.PUT_LINE('Error processing Parent_IID=' || 112.0 || ', Child_PID=' || 166.0 || ': ' || SQLERRM);
    -- Decide if you want to rollback just this block or let the main exception handler catch it
END;
/
DECLARE
  v_new_child_instance_id productInstance.Instance_ID%TYPE;
  v_child_category        product.Category%TYPE := 'Commodity'; -- Pass category
  v_max_existing_batch_lot NUMBER;
  v_next_batch_lot_num   NUMBER;
  v_serial_number        serialized.Serial_Number%TYPE;
  v_batch_number         serialized.Batch_Number%TYPE; -- Shared batch for serialized children of *this* parent
  v_expiration_date      commodity.Expiration_Date%TYPE;
  v_quantity_to_create   commodity.Quantity%TYPE; -- Quantity for the new child instance

BEGIN
  -- Step 1: Create the new child productInstance
  INSERT INTO productInstance (Product_ID, Date_Manufactured, Is_Recalled)
  VALUES (189.0, TIMESTAMP '2024-07-28 14:42:39', 0)
  RETURNING Instance_ID INTO v_new_child_instance_id;

  -- Step 2: Create the corresponding subtype record
  IF v_child_category = 'Commodity' THEN
    -- Find max existing Batch_Number for this specific Child_PID
    SELECT NVL(MAX(c.Batch_Number), 0) INTO v_max_existing_batch_lot
    FROM commodity c JOIN productInstance pi ON c.Instance_ID = pi.Instance_ID
    WHERE pi.Product_ID = 189.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next batch

    v_expiration_date := TIMESTAMP '2024-07-28 14:42:39' + INTERVAL '536' DAY;
    v_quantity_to_create := ROUND(0.8, 1);

    INSERT INTO commodity (Instance_ID, Batch_Number, Expiration_Date, Quantity)
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Packaged' THEN
    -- Find max existing Lot_Number for this specific Child_PID
    SELECT NVL(MAX(p.Lot_Number), 0) INTO v_max_existing_batch_lot
    FROM packaged p JOIN productInstance pi ON p.Instance_ID = pi.Instance_ID -- Assuming 'packaged' table name
    WHERE pi.Product_ID = 189.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next lot

    v_expiration_date := TIMESTAMP '2024-07-28 14:42:39' + INTERVAL '490' DAY;
    v_quantity_to_create := ROUND(0.8, 1);

    INSERT INTO packaged (Instance_ID, Lot_Number, Expiration_Date, Quantity) -- Assuming 'packaged' table name
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Serialized' THEN
    -- Assign a unique serial number
    -- Using Instance ID guarantees uniqueness within this context
    v_serial_number := 'SN-' || TO_CHAR(189.0) || '-' || TO_CHAR(v_new_child_instance_id) || '-' || SUBSTR(SYS_GUID(),1,8);
    -- Assign a batch number - use Product_ID of the *parent* instance as the batch for simplicity? Or a sequence?
    -- Let's use the Parent_IID itself as a simple batch identifier for this run.
    v_batch_number := 112.0; -- All children created FOR this parent get same batch number

    INSERT INTO serialized (Instance_ID, Serial_Number, Batch_Number)
    VALUES (v_new_child_instance_id, v_serial_number, v_batch_number);

    -- Quantity for usesComponent link for serialized is typically 1
    v_quantity_to_create := 1;

  END IF;

  -- Step 3: Create the usesComponent link
  -- Quantity_Used is the Quantity_Needed from needsComponent (which matches child quantity for non-serialized)
  IF v_child_category IN ('Commodity', 'Packaged', 'Serialized') THEN -- Only insert if subtype was handled
      INSERT INTO usesComponent (Parent_IID, Child_IID, Quantity_Used)
      VALUES (112.0, v_new_child_instance_id, ROUND(0.8, 1)); -- Use rounded quantity needed
  END IF;

EXCEPTION
  WHEN OTHERS THEN
    DBMS_OUTPUT.PUT_LINE('Error processing Parent_IID=' || 112.0 || ', Child_PID=' || 189.0 || ': ' || SQLERRM);
    -- Decide if you want to rollback just this block or let the main exception handler catch it
END;
/
DECLARE
  v_new_child_instance_id productInstance.Instance_ID%TYPE;
  v_child_category        product.Category%TYPE := 'Commodity'; -- Pass category
  v_max_existing_batch_lot NUMBER;
  v_next_batch_lot_num   NUMBER;
  v_serial_number        serialized.Serial_Number%TYPE;
  v_batch_number         serialized.Batch_Number%TYPE; -- Shared batch for serialized children of *this* parent
  v_expiration_date      commodity.Expiration_Date%TYPE;
  v_quantity_to_create   commodity.Quantity%TYPE; -- Quantity for the new child instance

BEGIN
  -- Step 1: Create the new child productInstance
  INSERT INTO productInstance (Product_ID, Date_Manufactured, Is_Recalled)
  VALUES (166.0, TIMESTAMP '2024-09-22 19:11:27', 0)
  RETURNING Instance_ID INTO v_new_child_instance_id;

  -- Step 2: Create the corresponding subtype record
  IF v_child_category = 'Commodity' THEN
    -- Find max existing Batch_Number for this specific Child_PID
    SELECT NVL(MAX(c.Batch_Number), 0) INTO v_max_existing_batch_lot
    FROM commodity c JOIN productInstance pi ON c.Instance_ID = pi.Instance_ID
    WHERE pi.Product_ID = 166.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next batch

    v_expiration_date := TIMESTAMP '2024-09-22 19:11:27' + INTERVAL '202' DAY;
    v_quantity_to_create := ROUND(0.9, 1);

    INSERT INTO commodity (Instance_ID, Batch_Number, Expiration_Date, Quantity)
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Packaged' THEN
    -- Find max existing Lot_Number for this specific Child_PID
    SELECT NVL(MAX(p.Lot_Number), 0) INTO v_max_existing_batch_lot
    FROM packaged p JOIN productInstance pi ON p.Instance_ID = pi.Instance_ID -- Assuming 'packaged' table name
    WHERE pi.Product_ID = 166.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next lot

    v_expiration_date := TIMESTAMP '2024-09-22 19:11:27' + INTERVAL '267' DAY;
    v_quantity_to_create := ROUND(0.9, 1);

    INSERT INTO packaged (Instance_ID, Lot_Number, Expiration_Date, Quantity) -- Assuming 'packaged' table name
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Serialized' THEN
    -- Assign a unique serial number
    -- Using Instance ID guarantees uniqueness within this context
    v_serial_number := 'SN-' || TO_CHAR(166.0) || '-' || TO_CHAR(v_new_child_instance_id) || '-' || SUBSTR(SYS_GUID(),1,8);
    -- Assign a batch number - use Product_ID of the *parent* instance as the batch for simplicity? Or a sequence?
    -- Let's use the Parent_IID itself as a simple batch identifier for this run.
    v_batch_number := 113.0; -- All children created FOR this parent get same batch number

    INSERT INTO serialized (Instance_ID, Serial_Number, Batch_Number)
    VALUES (v_new_child_instance_id, v_serial_number, v_batch_number);

    -- Quantity for usesComponent link for serialized is typically 1
    v_quantity_to_create := 1;

  END IF;

  -- Step 3: Create the usesComponent link
  -- Quantity_Used is the Quantity_Needed from needsComponent (which matches child quantity for non-serialized)
  IF v_child_category IN ('Commodity', 'Packaged', 'Serialized') THEN -- Only insert if subtype was handled
      INSERT INTO usesComponent (Parent_IID, Child_IID, Quantity_Used)
      VALUES (113.0, v_new_child_instance_id, ROUND(0.9, 1)); -- Use rounded quantity needed
  END IF;

EXCEPTION
  WHEN OTHERS THEN
    DBMS_OUTPUT.PUT_LINE('Error processing Parent_IID=' || 113.0 || ', Child_PID=' || 166.0 || ': ' || SQLERRM);
    -- Decide if you want to rollback just this block or let the main exception handler catch it
END;
/
DECLARE
  v_new_child_instance_id productInstance.Instance_ID%TYPE;
  v_child_category        product.Category%TYPE := 'Commodity'; -- Pass category
  v_max_existing_batch_lot NUMBER;
  v_next_batch_lot_num   NUMBER;
  v_serial_number        serialized.Serial_Number%TYPE;
  v_batch_number         serialized.Batch_Number%TYPE; -- Shared batch for serialized children of *this* parent
  v_expiration_date      commodity.Expiration_Date%TYPE;
  v_quantity_to_create   commodity.Quantity%TYPE; -- Quantity for the new child instance

BEGIN
  -- Step 1: Create the new child productInstance
  INSERT INTO productInstance (Product_ID, Date_Manufactured, Is_Recalled)
  VALUES (189.0, TIMESTAMP '2024-07-29 14:11:12', 0)
  RETURNING Instance_ID INTO v_new_child_instance_id;

  -- Step 2: Create the corresponding subtype record
  IF v_child_category = 'Commodity' THEN
    -- Find max existing Batch_Number for this specific Child_PID
    SELECT NVL(MAX(c.Batch_Number), 0) INTO v_max_existing_batch_lot
    FROM commodity c JOIN productInstance pi ON c.Instance_ID = pi.Instance_ID
    WHERE pi.Product_ID = 189.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next batch

    v_expiration_date := TIMESTAMP '2024-07-29 14:11:12' + INTERVAL '320' DAY;
    v_quantity_to_create := ROUND(0.8, 1);

    INSERT INTO commodity (Instance_ID, Batch_Number, Expiration_Date, Quantity)
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Packaged' THEN
    -- Find max existing Lot_Number for this specific Child_PID
    SELECT NVL(MAX(p.Lot_Number), 0) INTO v_max_existing_batch_lot
    FROM packaged p JOIN productInstance pi ON p.Instance_ID = pi.Instance_ID -- Assuming 'packaged' table name
    WHERE pi.Product_ID = 189.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next lot

    v_expiration_date := TIMESTAMP '2024-07-29 14:11:12' + INTERVAL '503' DAY;
    v_quantity_to_create := ROUND(0.8, 1);

    INSERT INTO packaged (Instance_ID, Lot_Number, Expiration_Date, Quantity) -- Assuming 'packaged' table name
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Serialized' THEN
    -- Assign a unique serial number
    -- Using Instance ID guarantees uniqueness within this context
    v_serial_number := 'SN-' || TO_CHAR(189.0) || '-' || TO_CHAR(v_new_child_instance_id) || '-' || SUBSTR(SYS_GUID(),1,8);
    -- Assign a batch number - use Product_ID of the *parent* instance as the batch for simplicity? Or a sequence?
    -- Let's use the Parent_IID itself as a simple batch identifier for this run.
    v_batch_number := 113.0; -- All children created FOR this parent get same batch number

    INSERT INTO serialized (Instance_ID, Serial_Number, Batch_Number)
    VALUES (v_new_child_instance_id, v_serial_number, v_batch_number);

    -- Quantity for usesComponent link for serialized is typically 1
    v_quantity_to_create := 1;

  END IF;

  -- Step 3: Create the usesComponent link
  -- Quantity_Used is the Quantity_Needed from needsComponent (which matches child quantity for non-serialized)
  IF v_child_category IN ('Commodity', 'Packaged', 'Serialized') THEN -- Only insert if subtype was handled
      INSERT INTO usesComponent (Parent_IID, Child_IID, Quantity_Used)
      VALUES (113.0, v_new_child_instance_id, ROUND(0.8, 1)); -- Use rounded quantity needed
  END IF;

EXCEPTION
  WHEN OTHERS THEN
    DBMS_OUTPUT.PUT_LINE('Error processing Parent_IID=' || 113.0 || ', Child_PID=' || 189.0 || ': ' || SQLERRM);
    -- Decide if you want to rollback just this block or let the main exception handler catch it
END;
/
DECLARE
  v_new_child_instance_id productInstance.Instance_ID%TYPE;
  v_child_category        product.Category%TYPE := 'Commodity'; -- Pass category
  v_max_existing_batch_lot NUMBER;
  v_next_batch_lot_num   NUMBER;
  v_serial_number        serialized.Serial_Number%TYPE;
  v_batch_number         serialized.Batch_Number%TYPE; -- Shared batch for serialized children of *this* parent
  v_expiration_date      commodity.Expiration_Date%TYPE;
  v_quantity_to_create   commodity.Quantity%TYPE; -- Quantity for the new child instance

BEGIN
  -- Step 1: Create the new child productInstance
  INSERT INTO productInstance (Product_ID, Date_Manufactured, Is_Recalled)
  VALUES (218.0, TIMESTAMP '2024-11-27 11:33:08', 0)
  RETURNING Instance_ID INTO v_new_child_instance_id;

  -- Step 2: Create the corresponding subtype record
  IF v_child_category = 'Commodity' THEN
    -- Find max existing Batch_Number for this specific Child_PID
    SELECT NVL(MAX(c.Batch_Number), 0) INTO v_max_existing_batch_lot
    FROM commodity c JOIN productInstance pi ON c.Instance_ID = pi.Instance_ID
    WHERE pi.Product_ID = 218.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next batch

    v_expiration_date := TIMESTAMP '2024-11-27 11:33:08' + INTERVAL '623' DAY;
    v_quantity_to_create := ROUND(0.7, 1);

    INSERT INTO commodity (Instance_ID, Batch_Number, Expiration_Date, Quantity)
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Packaged' THEN
    -- Find max existing Lot_Number for this specific Child_PID
    SELECT NVL(MAX(p.Lot_Number), 0) INTO v_max_existing_batch_lot
    FROM packaged p JOIN productInstance pi ON p.Instance_ID = pi.Instance_ID -- Assuming 'packaged' table name
    WHERE pi.Product_ID = 218.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next lot

    v_expiration_date := TIMESTAMP '2024-11-27 11:33:08' + INTERVAL '428' DAY;
    v_quantity_to_create := ROUND(0.7, 1);

    INSERT INTO packaged (Instance_ID, Lot_Number, Expiration_Date, Quantity) -- Assuming 'packaged' table name
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Serialized' THEN
    -- Assign a unique serial number
    -- Using Instance ID guarantees uniqueness within this context
    v_serial_number := 'SN-' || TO_CHAR(218.0) || '-' || TO_CHAR(v_new_child_instance_id) || '-' || SUBSTR(SYS_GUID(),1,8);
    -- Assign a batch number - use Product_ID of the *parent* instance as the batch for simplicity? Or a sequence?
    -- Let's use the Parent_IID itself as a simple batch identifier for this run.
    v_batch_number := 116.0; -- All children created FOR this parent get same batch number

    INSERT INTO serialized (Instance_ID, Serial_Number, Batch_Number)
    VALUES (v_new_child_instance_id, v_serial_number, v_batch_number);

    -- Quantity for usesComponent link for serialized is typically 1
    v_quantity_to_create := 1;

  END IF;

  -- Step 3: Create the usesComponent link
  -- Quantity_Used is the Quantity_Needed from needsComponent (which matches child quantity for non-serialized)
  IF v_child_category IN ('Commodity', 'Packaged', 'Serialized') THEN -- Only insert if subtype was handled
      INSERT INTO usesComponent (Parent_IID, Child_IID, Quantity_Used)
      VALUES (116.0, v_new_child_instance_id, ROUND(0.7, 1)); -- Use rounded quantity needed
  END IF;

EXCEPTION
  WHEN OTHERS THEN
    DBMS_OUTPUT.PUT_LINE('Error processing Parent_IID=' || 116.0 || ', Child_PID=' || 218.0 || ': ' || SQLERRM);
    -- Decide if you want to rollback just this block or let the main exception handler catch it
END;
/
DECLARE
  v_new_child_instance_id productInstance.Instance_ID%TYPE;
  v_child_category        product.Category%TYPE := 'Commodity'; -- Pass category
  v_max_existing_batch_lot NUMBER;
  v_next_batch_lot_num   NUMBER;
  v_serial_number        serialized.Serial_Number%TYPE;
  v_batch_number         serialized.Batch_Number%TYPE; -- Shared batch for serialized children of *this* parent
  v_expiration_date      commodity.Expiration_Date%TYPE;
  v_quantity_to_create   commodity.Quantity%TYPE; -- Quantity for the new child instance

BEGIN
  -- Step 1: Create the new child productInstance
  INSERT INTO productInstance (Product_ID, Date_Manufactured, Is_Recalled)
  VALUES (218.0, TIMESTAMP '2024-07-20 08:04:39', 0)
  RETURNING Instance_ID INTO v_new_child_instance_id;

  -- Step 2: Create the corresponding subtype record
  IF v_child_category = 'Commodity' THEN
    -- Find max existing Batch_Number for this specific Child_PID
    SELECT NVL(MAX(c.Batch_Number), 0) INTO v_max_existing_batch_lot
    FROM commodity c JOIN productInstance pi ON c.Instance_ID = pi.Instance_ID
    WHERE pi.Product_ID = 218.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next batch

    v_expiration_date := TIMESTAMP '2024-07-20 08:04:39' + INTERVAL '492' DAY;
    v_quantity_to_create := ROUND(0.7, 1);

    INSERT INTO commodity (Instance_ID, Batch_Number, Expiration_Date, Quantity)
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Packaged' THEN
    -- Find max existing Lot_Number for this specific Child_PID
    SELECT NVL(MAX(p.Lot_Number), 0) INTO v_max_existing_batch_lot
    FROM packaged p JOIN productInstance pi ON p.Instance_ID = pi.Instance_ID -- Assuming 'packaged' table name
    WHERE pi.Product_ID = 218.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next lot

    v_expiration_date := TIMESTAMP '2024-07-20 08:04:39' + INTERVAL '294' DAY;
    v_quantity_to_create := ROUND(0.7, 1);

    INSERT INTO packaged (Instance_ID, Lot_Number, Expiration_Date, Quantity) -- Assuming 'packaged' table name
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Serialized' THEN
    -- Assign a unique serial number
    -- Using Instance ID guarantees uniqueness within this context
    v_serial_number := 'SN-' || TO_CHAR(218.0) || '-' || TO_CHAR(v_new_child_instance_id) || '-' || SUBSTR(SYS_GUID(),1,8);
    -- Assign a batch number - use Product_ID of the *parent* instance as the batch for simplicity? Or a sequence?
    -- Let's use the Parent_IID itself as a simple batch identifier for this run.
    v_batch_number := 117.0; -- All children created FOR this parent get same batch number

    INSERT INTO serialized (Instance_ID, Serial_Number, Batch_Number)
    VALUES (v_new_child_instance_id, v_serial_number, v_batch_number);

    -- Quantity for usesComponent link for serialized is typically 1
    v_quantity_to_create := 1;

  END IF;

  -- Step 3: Create the usesComponent link
  -- Quantity_Used is the Quantity_Needed from needsComponent (which matches child quantity for non-serialized)
  IF v_child_category IN ('Commodity', 'Packaged', 'Serialized') THEN -- Only insert if subtype was handled
      INSERT INTO usesComponent (Parent_IID, Child_IID, Quantity_Used)
      VALUES (117.0, v_new_child_instance_id, ROUND(0.7, 1)); -- Use rounded quantity needed
  END IF;

EXCEPTION
  WHEN OTHERS THEN
    DBMS_OUTPUT.PUT_LINE('Error processing Parent_IID=' || 117.0 || ', Child_PID=' || 218.0 || ': ' || SQLERRM);
    -- Decide if you want to rollback just this block or let the main exception handler catch it
END;
/
DECLARE
  v_new_child_instance_id productInstance.Instance_ID%TYPE;
  v_child_category        product.Category%TYPE := 'Commodity'; -- Pass category
  v_max_existing_batch_lot NUMBER;
  v_next_batch_lot_num   NUMBER;
  v_serial_number        serialized.Serial_Number%TYPE;
  v_batch_number         serialized.Batch_Number%TYPE; -- Shared batch for serialized children of *this* parent
  v_expiration_date      commodity.Expiration_Date%TYPE;
  v_quantity_to_create   commodity.Quantity%TYPE; -- Quantity for the new child instance

BEGIN
  -- Step 1: Create the new child productInstance
  INSERT INTO productInstance (Product_ID, Date_Manufactured, Is_Recalled)
  VALUES (158.0, TIMESTAMP '2024-09-04 05:52:37', 0)
  RETURNING Instance_ID INTO v_new_child_instance_id;

  -- Step 2: Create the corresponding subtype record
  IF v_child_category = 'Commodity' THEN
    -- Find max existing Batch_Number for this specific Child_PID
    SELECT NVL(MAX(c.Batch_Number), 0) INTO v_max_existing_batch_lot
    FROM commodity c JOIN productInstance pi ON c.Instance_ID = pi.Instance_ID
    WHERE pi.Product_ID = 158.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next batch

    v_expiration_date := TIMESTAMP '2024-09-04 05:52:37' + INTERVAL '538' DAY;
    v_quantity_to_create := ROUND(0.6, 1);

    INSERT INTO commodity (Instance_ID, Batch_Number, Expiration_Date, Quantity)
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Packaged' THEN
    -- Find max existing Lot_Number for this specific Child_PID
    SELECT NVL(MAX(p.Lot_Number), 0) INTO v_max_existing_batch_lot
    FROM packaged p JOIN productInstance pi ON p.Instance_ID = pi.Instance_ID -- Assuming 'packaged' table name
    WHERE pi.Product_ID = 158.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next lot

    v_expiration_date := TIMESTAMP '2024-09-04 05:52:37' + INTERVAL '637' DAY;
    v_quantity_to_create := ROUND(0.6, 1);

    INSERT INTO packaged (Instance_ID, Lot_Number, Expiration_Date, Quantity) -- Assuming 'packaged' table name
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Serialized' THEN
    -- Assign a unique serial number
    -- Using Instance ID guarantees uniqueness within this context
    v_serial_number := 'SN-' || TO_CHAR(158.0) || '-' || TO_CHAR(v_new_child_instance_id) || '-' || SUBSTR(SYS_GUID(),1,8);
    -- Assign a batch number - use Product_ID of the *parent* instance as the batch for simplicity? Or a sequence?
    -- Let's use the Parent_IID itself as a simple batch identifier for this run.
    v_batch_number := 118.0; -- All children created FOR this parent get same batch number

    INSERT INTO serialized (Instance_ID, Serial_Number, Batch_Number)
    VALUES (v_new_child_instance_id, v_serial_number, v_batch_number);

    -- Quantity for usesComponent link for serialized is typically 1
    v_quantity_to_create := 1;

  END IF;

  -- Step 3: Create the usesComponent link
  -- Quantity_Used is the Quantity_Needed from needsComponent (which matches child quantity for non-serialized)
  IF v_child_category IN ('Commodity', 'Packaged', 'Serialized') THEN -- Only insert if subtype was handled
      INSERT INTO usesComponent (Parent_IID, Child_IID, Quantity_Used)
      VALUES (118.0, v_new_child_instance_id, ROUND(0.6, 1)); -- Use rounded quantity needed
  END IF;

EXCEPTION
  WHEN OTHERS THEN
    DBMS_OUTPUT.PUT_LINE('Error processing Parent_IID=' || 118.0 || ', Child_PID=' || 158.0 || ': ' || SQLERRM);
    -- Decide if you want to rollback just this block or let the main exception handler catch it
END;
/
DECLARE
  v_new_child_instance_id productInstance.Instance_ID%TYPE;
  v_child_category        product.Category%TYPE := 'Commodity'; -- Pass category
  v_max_existing_batch_lot NUMBER;
  v_next_batch_lot_num   NUMBER;
  v_serial_number        serialized.Serial_Number%TYPE;
  v_batch_number         serialized.Batch_Number%TYPE; -- Shared batch for serialized children of *this* parent
  v_expiration_date      commodity.Expiration_Date%TYPE;
  v_quantity_to_create   commodity.Quantity%TYPE; -- Quantity for the new child instance

BEGIN
  -- Step 1: Create the new child productInstance
  INSERT INTO productInstance (Product_ID, Date_Manufactured, Is_Recalled)
  VALUES (106.0, TIMESTAMP '2024-06-11 03:02:57', 0)
  RETURNING Instance_ID INTO v_new_child_instance_id;

  -- Step 2: Create the corresponding subtype record
  IF v_child_category = 'Commodity' THEN
    -- Find max existing Batch_Number for this specific Child_PID
    SELECT NVL(MAX(c.Batch_Number), 0) INTO v_max_existing_batch_lot
    FROM commodity c JOIN productInstance pi ON c.Instance_ID = pi.Instance_ID
    WHERE pi.Product_ID = 106.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next batch

    v_expiration_date := TIMESTAMP '2024-06-11 03:02:57' + INTERVAL '248' DAY;
    v_quantity_to_create := ROUND(0.3, 1);

    INSERT INTO commodity (Instance_ID, Batch_Number, Expiration_Date, Quantity)
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Packaged' THEN
    -- Find max existing Lot_Number for this specific Child_PID
    SELECT NVL(MAX(p.Lot_Number), 0) INTO v_max_existing_batch_lot
    FROM packaged p JOIN productInstance pi ON p.Instance_ID = pi.Instance_ID -- Assuming 'packaged' table name
    WHERE pi.Product_ID = 106.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next lot

    v_expiration_date := TIMESTAMP '2024-06-11 03:02:57' + INTERVAL '110' DAY;
    v_quantity_to_create := ROUND(0.3, 1);

    INSERT INTO packaged (Instance_ID, Lot_Number, Expiration_Date, Quantity) -- Assuming 'packaged' table name
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Serialized' THEN
    -- Assign a unique serial number
    -- Using Instance ID guarantees uniqueness within this context
    v_serial_number := 'SN-' || TO_CHAR(106.0) || '-' || TO_CHAR(v_new_child_instance_id) || '-' || SUBSTR(SYS_GUID(),1,8);
    -- Assign a batch number - use Product_ID of the *parent* instance as the batch for simplicity? Or a sequence?
    -- Let's use the Parent_IID itself as a simple batch identifier for this run.
    v_batch_number := 118.0; -- All children created FOR this parent get same batch number

    INSERT INTO serialized (Instance_ID, Serial_Number, Batch_Number)
    VALUES (v_new_child_instance_id, v_serial_number, v_batch_number);

    -- Quantity for usesComponent link for serialized is typically 1
    v_quantity_to_create := 1;

  END IF;

  -- Step 3: Create the usesComponent link
  -- Quantity_Used is the Quantity_Needed from needsComponent (which matches child quantity for non-serialized)
  IF v_child_category IN ('Commodity', 'Packaged', 'Serialized') THEN -- Only insert if subtype was handled
      INSERT INTO usesComponent (Parent_IID, Child_IID, Quantity_Used)
      VALUES (118.0, v_new_child_instance_id, ROUND(0.3, 1)); -- Use rounded quantity needed
  END IF;

EXCEPTION
  WHEN OTHERS THEN
    DBMS_OUTPUT.PUT_LINE('Error processing Parent_IID=' || 118.0 || ', Child_PID=' || 106.0 || ': ' || SQLERRM);
    -- Decide if you want to rollback just this block or let the main exception handler catch it
END;
/
DECLARE
  v_new_child_instance_id productInstance.Instance_ID%TYPE;
  v_child_category        product.Category%TYPE := 'Commodity'; -- Pass category
  v_max_existing_batch_lot NUMBER;
  v_next_batch_lot_num   NUMBER;
  v_serial_number        serialized.Serial_Number%TYPE;
  v_batch_number         serialized.Batch_Number%TYPE; -- Shared batch for serialized children of *this* parent
  v_expiration_date      commodity.Expiration_Date%TYPE;
  v_quantity_to_create   commodity.Quantity%TYPE; -- Quantity for the new child instance

BEGIN
  -- Step 1: Create the new child productInstance
  INSERT INTO productInstance (Product_ID, Date_Manufactured, Is_Recalled)
  VALUES (132.0, TIMESTAMP '2024-05-16 23:44:37', 0)
  RETURNING Instance_ID INTO v_new_child_instance_id;

  -- Step 2: Create the corresponding subtype record
  IF v_child_category = 'Commodity' THEN
    -- Find max existing Batch_Number for this specific Child_PID
    SELECT NVL(MAX(c.Batch_Number), 0) INTO v_max_existing_batch_lot
    FROM commodity c JOIN productInstance pi ON c.Instance_ID = pi.Instance_ID
    WHERE pi.Product_ID = 132.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next batch

    v_expiration_date := TIMESTAMP '2024-05-16 23:44:37' + INTERVAL '45' DAY;
    v_quantity_to_create := ROUND(1.3, 1);

    INSERT INTO commodity (Instance_ID, Batch_Number, Expiration_Date, Quantity)
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Packaged' THEN
    -- Find max existing Lot_Number for this specific Child_PID
    SELECT NVL(MAX(p.Lot_Number), 0) INTO v_max_existing_batch_lot
    FROM packaged p JOIN productInstance pi ON p.Instance_ID = pi.Instance_ID -- Assuming 'packaged' table name
    WHERE pi.Product_ID = 132.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next lot

    v_expiration_date := TIMESTAMP '2024-05-16 23:44:37' + INTERVAL '35' DAY;
    v_quantity_to_create := ROUND(1.3, 1);

    INSERT INTO packaged (Instance_ID, Lot_Number, Expiration_Date, Quantity) -- Assuming 'packaged' table name
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Serialized' THEN
    -- Assign a unique serial number
    -- Using Instance ID guarantees uniqueness within this context
    v_serial_number := 'SN-' || TO_CHAR(132.0) || '-' || TO_CHAR(v_new_child_instance_id) || '-' || SUBSTR(SYS_GUID(),1,8);
    -- Assign a batch number - use Product_ID of the *parent* instance as the batch for simplicity? Or a sequence?
    -- Let's use the Parent_IID itself as a simple batch identifier for this run.
    v_batch_number := 118.0; -- All children created FOR this parent get same batch number

    INSERT INTO serialized (Instance_ID, Serial_Number, Batch_Number)
    VALUES (v_new_child_instance_id, v_serial_number, v_batch_number);

    -- Quantity for usesComponent link for serialized is typically 1
    v_quantity_to_create := 1;

  END IF;

  -- Step 3: Create the usesComponent link
  -- Quantity_Used is the Quantity_Needed from needsComponent (which matches child quantity for non-serialized)
  IF v_child_category IN ('Commodity', 'Packaged', 'Serialized') THEN -- Only insert if subtype was handled
      INSERT INTO usesComponent (Parent_IID, Child_IID, Quantity_Used)
      VALUES (118.0, v_new_child_instance_id, ROUND(1.3, 1)); -- Use rounded quantity needed
  END IF;

EXCEPTION
  WHEN OTHERS THEN
    DBMS_OUTPUT.PUT_LINE('Error processing Parent_IID=' || 118.0 || ', Child_PID=' || 132.0 || ': ' || SQLERRM);
    -- Decide if you want to rollback just this block or let the main exception handler catch it
END;
/
DECLARE
  v_new_child_instance_id productInstance.Instance_ID%TYPE;
  v_child_category        product.Category%TYPE := 'Commodity'; -- Pass category
  v_max_existing_batch_lot NUMBER;
  v_next_batch_lot_num   NUMBER;
  v_serial_number        serialized.Serial_Number%TYPE;
  v_batch_number         serialized.Batch_Number%TYPE; -- Shared batch for serialized children of *this* parent
  v_expiration_date      commodity.Expiration_Date%TYPE;
  v_quantity_to_create   commodity.Quantity%TYPE; -- Quantity for the new child instance

BEGIN
  -- Step 1: Create the new child productInstance
  INSERT INTO productInstance (Product_ID, Date_Manufactured, Is_Recalled)
  VALUES (158.0, TIMESTAMP '2025-03-28 02:15:32', 0)
  RETURNING Instance_ID INTO v_new_child_instance_id;

  -- Step 2: Create the corresponding subtype record
  IF v_child_category = 'Commodity' THEN
    -- Find max existing Batch_Number for this specific Child_PID
    SELECT NVL(MAX(c.Batch_Number), 0) INTO v_max_existing_batch_lot
    FROM commodity c JOIN productInstance pi ON c.Instance_ID = pi.Instance_ID
    WHERE pi.Product_ID = 158.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next batch

    v_expiration_date := TIMESTAMP '2025-03-28 02:15:32' + INTERVAL '521' DAY;
    v_quantity_to_create := ROUND(0.6, 1);

    INSERT INTO commodity (Instance_ID, Batch_Number, Expiration_Date, Quantity)
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Packaged' THEN
    -- Find max existing Lot_Number for this specific Child_PID
    SELECT NVL(MAX(p.Lot_Number), 0) INTO v_max_existing_batch_lot
    FROM packaged p JOIN productInstance pi ON p.Instance_ID = pi.Instance_ID -- Assuming 'packaged' table name
    WHERE pi.Product_ID = 158.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next lot

    v_expiration_date := TIMESTAMP '2025-03-28 02:15:32' + INTERVAL '357' DAY;
    v_quantity_to_create := ROUND(0.6, 1);

    INSERT INTO packaged (Instance_ID, Lot_Number, Expiration_Date, Quantity) -- Assuming 'packaged' table name
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Serialized' THEN
    -- Assign a unique serial number
    -- Using Instance ID guarantees uniqueness within this context
    v_serial_number := 'SN-' || TO_CHAR(158.0) || '-' || TO_CHAR(v_new_child_instance_id) || '-' || SUBSTR(SYS_GUID(),1,8);
    -- Assign a batch number - use Product_ID of the *parent* instance as the batch for simplicity? Or a sequence?
    -- Let's use the Parent_IID itself as a simple batch identifier for this run.
    v_batch_number := 119.0; -- All children created FOR this parent get same batch number

    INSERT INTO serialized (Instance_ID, Serial_Number, Batch_Number)
    VALUES (v_new_child_instance_id, v_serial_number, v_batch_number);

    -- Quantity for usesComponent link for serialized is typically 1
    v_quantity_to_create := 1;

  END IF;

  -- Step 3: Create the usesComponent link
  -- Quantity_Used is the Quantity_Needed from needsComponent (which matches child quantity for non-serialized)
  IF v_child_category IN ('Commodity', 'Packaged', 'Serialized') THEN -- Only insert if subtype was handled
      INSERT INTO usesComponent (Parent_IID, Child_IID, Quantity_Used)
      VALUES (119.0, v_new_child_instance_id, ROUND(0.6, 1)); -- Use rounded quantity needed
  END IF;

EXCEPTION
  WHEN OTHERS THEN
    DBMS_OUTPUT.PUT_LINE('Error processing Parent_IID=' || 119.0 || ', Child_PID=' || 158.0 || ': ' || SQLERRM);
    -- Decide if you want to rollback just this block or let the main exception handler catch it
END;
/
DECLARE
  v_new_child_instance_id productInstance.Instance_ID%TYPE;
  v_child_category        product.Category%TYPE := 'Commodity'; -- Pass category
  v_max_existing_batch_lot NUMBER;
  v_next_batch_lot_num   NUMBER;
  v_serial_number        serialized.Serial_Number%TYPE;
  v_batch_number         serialized.Batch_Number%TYPE; -- Shared batch for serialized children of *this* parent
  v_expiration_date      commodity.Expiration_Date%TYPE;
  v_quantity_to_create   commodity.Quantity%TYPE; -- Quantity for the new child instance

BEGIN
  -- Step 1: Create the new child productInstance
  INSERT INTO productInstance (Product_ID, Date_Manufactured, Is_Recalled)
  VALUES (106.0, TIMESTAMP '2025-04-09 05:27:19', 0)
  RETURNING Instance_ID INTO v_new_child_instance_id;

  -- Step 2: Create the corresponding subtype record
  IF v_child_category = 'Commodity' THEN
    -- Find max existing Batch_Number for this specific Child_PID
    SELECT NVL(MAX(c.Batch_Number), 0) INTO v_max_existing_batch_lot
    FROM commodity c JOIN productInstance pi ON c.Instance_ID = pi.Instance_ID
    WHERE pi.Product_ID = 106.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next batch

    v_expiration_date := TIMESTAMP '2025-04-09 05:27:19' + INTERVAL '422' DAY;
    v_quantity_to_create := ROUND(0.3, 1);

    INSERT INTO commodity (Instance_ID, Batch_Number, Expiration_Date, Quantity)
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Packaged' THEN
    -- Find max existing Lot_Number for this specific Child_PID
    SELECT NVL(MAX(p.Lot_Number), 0) INTO v_max_existing_batch_lot
    FROM packaged p JOIN productInstance pi ON p.Instance_ID = pi.Instance_ID -- Assuming 'packaged' table name
    WHERE pi.Product_ID = 106.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next lot

    v_expiration_date := TIMESTAMP '2025-04-09 05:27:19' + INTERVAL '624' DAY;
    v_quantity_to_create := ROUND(0.3, 1);

    INSERT INTO packaged (Instance_ID, Lot_Number, Expiration_Date, Quantity) -- Assuming 'packaged' table name
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Serialized' THEN
    -- Assign a unique serial number
    -- Using Instance ID guarantees uniqueness within this context
    v_serial_number := 'SN-' || TO_CHAR(106.0) || '-' || TO_CHAR(v_new_child_instance_id) || '-' || SUBSTR(SYS_GUID(),1,8);
    -- Assign a batch number - use Product_ID of the *parent* instance as the batch for simplicity? Or a sequence?
    -- Let's use the Parent_IID itself as a simple batch identifier for this run.
    v_batch_number := 119.0; -- All children created FOR this parent get same batch number

    INSERT INTO serialized (Instance_ID, Serial_Number, Batch_Number)
    VALUES (v_new_child_instance_id, v_serial_number, v_batch_number);

    -- Quantity for usesComponent link for serialized is typically 1
    v_quantity_to_create := 1;

  END IF;

  -- Step 3: Create the usesComponent link
  -- Quantity_Used is the Quantity_Needed from needsComponent (which matches child quantity for non-serialized)
  IF v_child_category IN ('Commodity', 'Packaged', 'Serialized') THEN -- Only insert if subtype was handled
      INSERT INTO usesComponent (Parent_IID, Child_IID, Quantity_Used)
      VALUES (119.0, v_new_child_instance_id, ROUND(0.3, 1)); -- Use rounded quantity needed
  END IF;

EXCEPTION
  WHEN OTHERS THEN
    DBMS_OUTPUT.PUT_LINE('Error processing Parent_IID=' || 119.0 || ', Child_PID=' || 106.0 || ': ' || SQLERRM);
    -- Decide if you want to rollback just this block or let the main exception handler catch it
END;
/
DECLARE
  v_new_child_instance_id productInstance.Instance_ID%TYPE;
  v_child_category        product.Category%TYPE := 'Commodity'; -- Pass category
  v_max_existing_batch_lot NUMBER;
  v_next_batch_lot_num   NUMBER;
  v_serial_number        serialized.Serial_Number%TYPE;
  v_batch_number         serialized.Batch_Number%TYPE; -- Shared batch for serialized children of *this* parent
  v_expiration_date      commodity.Expiration_Date%TYPE;
  v_quantity_to_create   commodity.Quantity%TYPE; -- Quantity for the new child instance

BEGIN
  -- Step 1: Create the new child productInstance
  INSERT INTO productInstance (Product_ID, Date_Manufactured, Is_Recalled)
  VALUES (132.0, TIMESTAMP '2024-08-18 14:00:11', 0)
  RETURNING Instance_ID INTO v_new_child_instance_id;

  -- Step 2: Create the corresponding subtype record
  IF v_child_category = 'Commodity' THEN
    -- Find max existing Batch_Number for this specific Child_PID
    SELECT NVL(MAX(c.Batch_Number), 0) INTO v_max_existing_batch_lot
    FROM commodity c JOIN productInstance pi ON c.Instance_ID = pi.Instance_ID
    WHERE pi.Product_ID = 132.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next batch

    v_expiration_date := TIMESTAMP '2024-08-18 14:00:11' + INTERVAL '230' DAY;
    v_quantity_to_create := ROUND(1.3, 1);

    INSERT INTO commodity (Instance_ID, Batch_Number, Expiration_Date, Quantity)
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Packaged' THEN
    -- Find max existing Lot_Number for this specific Child_PID
    SELECT NVL(MAX(p.Lot_Number), 0) INTO v_max_existing_batch_lot
    FROM packaged p JOIN productInstance pi ON p.Instance_ID = pi.Instance_ID -- Assuming 'packaged' table name
    WHERE pi.Product_ID = 132.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next lot

    v_expiration_date := TIMESTAMP '2024-08-18 14:00:11' + INTERVAL '439' DAY;
    v_quantity_to_create := ROUND(1.3, 1);

    INSERT INTO packaged (Instance_ID, Lot_Number, Expiration_Date, Quantity) -- Assuming 'packaged' table name
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Serialized' THEN
    -- Assign a unique serial number
    -- Using Instance ID guarantees uniqueness within this context
    v_serial_number := 'SN-' || TO_CHAR(132.0) || '-' || TO_CHAR(v_new_child_instance_id) || '-' || SUBSTR(SYS_GUID(),1,8);
    -- Assign a batch number - use Product_ID of the *parent* instance as the batch for simplicity? Or a sequence?
    -- Let's use the Parent_IID itself as a simple batch identifier for this run.
    v_batch_number := 119.0; -- All children created FOR this parent get same batch number

    INSERT INTO serialized (Instance_ID, Serial_Number, Batch_Number)
    VALUES (v_new_child_instance_id, v_serial_number, v_batch_number);

    -- Quantity for usesComponent link for serialized is typically 1
    v_quantity_to_create := 1;

  END IF;

  -- Step 3: Create the usesComponent link
  -- Quantity_Used is the Quantity_Needed from needsComponent (which matches child quantity for non-serialized)
  IF v_child_category IN ('Commodity', 'Packaged', 'Serialized') THEN -- Only insert if subtype was handled
      INSERT INTO usesComponent (Parent_IID, Child_IID, Quantity_Used)
      VALUES (119.0, v_new_child_instance_id, ROUND(1.3, 1)); -- Use rounded quantity needed
  END IF;

EXCEPTION
  WHEN OTHERS THEN
    DBMS_OUTPUT.PUT_LINE('Error processing Parent_IID=' || 119.0 || ', Child_PID=' || 132.0 || ': ' || SQLERRM);
    -- Decide if you want to rollback just this block or let the main exception handler catch it
END;
/
DECLARE
  v_new_child_instance_id productInstance.Instance_ID%TYPE;
  v_child_category        product.Category%TYPE := 'Commodity'; -- Pass category
  v_max_existing_batch_lot NUMBER;
  v_next_batch_lot_num   NUMBER;
  v_serial_number        serialized.Serial_Number%TYPE;
  v_batch_number         serialized.Batch_Number%TYPE; -- Shared batch for serialized children of *this* parent
  v_expiration_date      commodity.Expiration_Date%TYPE;
  v_quantity_to_create   commodity.Quantity%TYPE; -- Quantity for the new child instance

BEGIN
  -- Step 1: Create the new child productInstance
  INSERT INTO productInstance (Product_ID, Date_Manufactured, Is_Recalled)
  VALUES (158.0, TIMESTAMP '2024-06-30 04:54:08', 0)
  RETURNING Instance_ID INTO v_new_child_instance_id;

  -- Step 2: Create the corresponding subtype record
  IF v_child_category = 'Commodity' THEN
    -- Find max existing Batch_Number for this specific Child_PID
    SELECT NVL(MAX(c.Batch_Number), 0) INTO v_max_existing_batch_lot
    FROM commodity c JOIN productInstance pi ON c.Instance_ID = pi.Instance_ID
    WHERE pi.Product_ID = 158.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next batch

    v_expiration_date := TIMESTAMP '2024-06-30 04:54:08' + INTERVAL '691' DAY;
    v_quantity_to_create := ROUND(0.6, 1);

    INSERT INTO commodity (Instance_ID, Batch_Number, Expiration_Date, Quantity)
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Packaged' THEN
    -- Find max existing Lot_Number for this specific Child_PID
    SELECT NVL(MAX(p.Lot_Number), 0) INTO v_max_existing_batch_lot
    FROM packaged p JOIN productInstance pi ON p.Instance_ID = pi.Instance_ID -- Assuming 'packaged' table name
    WHERE pi.Product_ID = 158.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next lot

    v_expiration_date := TIMESTAMP '2024-06-30 04:54:08' + INTERVAL '185' DAY;
    v_quantity_to_create := ROUND(0.6, 1);

    INSERT INTO packaged (Instance_ID, Lot_Number, Expiration_Date, Quantity) -- Assuming 'packaged' table name
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Serialized' THEN
    -- Assign a unique serial number
    -- Using Instance ID guarantees uniqueness within this context
    v_serial_number := 'SN-' || TO_CHAR(158.0) || '-' || TO_CHAR(v_new_child_instance_id) || '-' || SUBSTR(SYS_GUID(),1,8);
    -- Assign a batch number - use Product_ID of the *parent* instance as the batch for simplicity? Or a sequence?
    -- Let's use the Parent_IID itself as a simple batch identifier for this run.
    v_batch_number := 120.0; -- All children created FOR this parent get same batch number

    INSERT INTO serialized (Instance_ID, Serial_Number, Batch_Number)
    VALUES (v_new_child_instance_id, v_serial_number, v_batch_number);

    -- Quantity for usesComponent link for serialized is typically 1
    v_quantity_to_create := 1;

  END IF;

  -- Step 3: Create the usesComponent link
  -- Quantity_Used is the Quantity_Needed from needsComponent (which matches child quantity for non-serialized)
  IF v_child_category IN ('Commodity', 'Packaged', 'Serialized') THEN -- Only insert if subtype was handled
      INSERT INTO usesComponent (Parent_IID, Child_IID, Quantity_Used)
      VALUES (120.0, v_new_child_instance_id, ROUND(0.6, 1)); -- Use rounded quantity needed
  END IF;

EXCEPTION
  WHEN OTHERS THEN
    DBMS_OUTPUT.PUT_LINE('Error processing Parent_IID=' || 120.0 || ', Child_PID=' || 158.0 || ': ' || SQLERRM);
    -- Decide if you want to rollback just this block or let the main exception handler catch it
END;
/
DECLARE
  v_new_child_instance_id productInstance.Instance_ID%TYPE;
  v_child_category        product.Category%TYPE := 'Commodity'; -- Pass category
  v_max_existing_batch_lot NUMBER;
  v_next_batch_lot_num   NUMBER;
  v_serial_number        serialized.Serial_Number%TYPE;
  v_batch_number         serialized.Batch_Number%TYPE; -- Shared batch for serialized children of *this* parent
  v_expiration_date      commodity.Expiration_Date%TYPE;
  v_quantity_to_create   commodity.Quantity%TYPE; -- Quantity for the new child instance

BEGIN
  -- Step 1: Create the new child productInstance
  INSERT INTO productInstance (Product_ID, Date_Manufactured, Is_Recalled)
  VALUES (106.0, TIMESTAMP '2025-03-03 07:05:03', 0)
  RETURNING Instance_ID INTO v_new_child_instance_id;

  -- Step 2: Create the corresponding subtype record
  IF v_child_category = 'Commodity' THEN
    -- Find max existing Batch_Number for this specific Child_PID
    SELECT NVL(MAX(c.Batch_Number), 0) INTO v_max_existing_batch_lot
    FROM commodity c JOIN productInstance pi ON c.Instance_ID = pi.Instance_ID
    WHERE pi.Product_ID = 106.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next batch

    v_expiration_date := TIMESTAMP '2025-03-03 07:05:03' + INTERVAL '61' DAY;
    v_quantity_to_create := ROUND(0.3, 1);

    INSERT INTO commodity (Instance_ID, Batch_Number, Expiration_Date, Quantity)
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Packaged' THEN
    -- Find max existing Lot_Number for this specific Child_PID
    SELECT NVL(MAX(p.Lot_Number), 0) INTO v_max_existing_batch_lot
    FROM packaged p JOIN productInstance pi ON p.Instance_ID = pi.Instance_ID -- Assuming 'packaged' table name
    WHERE pi.Product_ID = 106.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next lot

    v_expiration_date := TIMESTAMP '2025-03-03 07:05:03' + INTERVAL '45' DAY;
    v_quantity_to_create := ROUND(0.3, 1);

    INSERT INTO packaged (Instance_ID, Lot_Number, Expiration_Date, Quantity) -- Assuming 'packaged' table name
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Serialized' THEN
    -- Assign a unique serial number
    -- Using Instance ID guarantees uniqueness within this context
    v_serial_number := 'SN-' || TO_CHAR(106.0) || '-' || TO_CHAR(v_new_child_instance_id) || '-' || SUBSTR(SYS_GUID(),1,8);
    -- Assign a batch number - use Product_ID of the *parent* instance as the batch for simplicity? Or a sequence?
    -- Let's use the Parent_IID itself as a simple batch identifier for this run.
    v_batch_number := 120.0; -- All children created FOR this parent get same batch number

    INSERT INTO serialized (Instance_ID, Serial_Number, Batch_Number)
    VALUES (v_new_child_instance_id, v_serial_number, v_batch_number);

    -- Quantity for usesComponent link for serialized is typically 1
    v_quantity_to_create := 1;

  END IF;

  -- Step 3: Create the usesComponent link
  -- Quantity_Used is the Quantity_Needed from needsComponent (which matches child quantity for non-serialized)
  IF v_child_category IN ('Commodity', 'Packaged', 'Serialized') THEN -- Only insert if subtype was handled
      INSERT INTO usesComponent (Parent_IID, Child_IID, Quantity_Used)
      VALUES (120.0, v_new_child_instance_id, ROUND(0.3, 1)); -- Use rounded quantity needed
  END IF;

EXCEPTION
  WHEN OTHERS THEN
    DBMS_OUTPUT.PUT_LINE('Error processing Parent_IID=' || 120.0 || ', Child_PID=' || 106.0 || ': ' || SQLERRM);
    -- Decide if you want to rollback just this block or let the main exception handler catch it
END;
/
DECLARE
  v_new_child_instance_id productInstance.Instance_ID%TYPE;
  v_child_category        product.Category%TYPE := 'Commodity'; -- Pass category
  v_max_existing_batch_lot NUMBER;
  v_next_batch_lot_num   NUMBER;
  v_serial_number        serialized.Serial_Number%TYPE;
  v_batch_number         serialized.Batch_Number%TYPE; -- Shared batch for serialized children of *this* parent
  v_expiration_date      commodity.Expiration_Date%TYPE;
  v_quantity_to_create   commodity.Quantity%TYPE; -- Quantity for the new child instance

BEGIN
  -- Step 1: Create the new child productInstance
  INSERT INTO productInstance (Product_ID, Date_Manufactured, Is_Recalled)
  VALUES (132.0, TIMESTAMP '2024-09-26 10:35:44', 0)
  RETURNING Instance_ID INTO v_new_child_instance_id;

  -- Step 2: Create the corresponding subtype record
  IF v_child_category = 'Commodity' THEN
    -- Find max existing Batch_Number for this specific Child_PID
    SELECT NVL(MAX(c.Batch_Number), 0) INTO v_max_existing_batch_lot
    FROM commodity c JOIN productInstance pi ON c.Instance_ID = pi.Instance_ID
    WHERE pi.Product_ID = 132.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next batch

    v_expiration_date := TIMESTAMP '2024-09-26 10:35:44' + INTERVAL '178' DAY;
    v_quantity_to_create := ROUND(1.3, 1);

    INSERT INTO commodity (Instance_ID, Batch_Number, Expiration_Date, Quantity)
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Packaged' THEN
    -- Find max existing Lot_Number for this specific Child_PID
    SELECT NVL(MAX(p.Lot_Number), 0) INTO v_max_existing_batch_lot
    FROM packaged p JOIN productInstance pi ON p.Instance_ID = pi.Instance_ID -- Assuming 'packaged' table name
    WHERE pi.Product_ID = 132.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next lot

    v_expiration_date := TIMESTAMP '2024-09-26 10:35:44' + INTERVAL '710' DAY;
    v_quantity_to_create := ROUND(1.3, 1);

    INSERT INTO packaged (Instance_ID, Lot_Number, Expiration_Date, Quantity) -- Assuming 'packaged' table name
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Serialized' THEN
    -- Assign a unique serial number
    -- Using Instance ID guarantees uniqueness within this context
    v_serial_number := 'SN-' || TO_CHAR(132.0) || '-' || TO_CHAR(v_new_child_instance_id) || '-' || SUBSTR(SYS_GUID(),1,8);
    -- Assign a batch number - use Product_ID of the *parent* instance as the batch for simplicity? Or a sequence?
    -- Let's use the Parent_IID itself as a simple batch identifier for this run.
    v_batch_number := 120.0; -- All children created FOR this parent get same batch number

    INSERT INTO serialized (Instance_ID, Serial_Number, Batch_Number)
    VALUES (v_new_child_instance_id, v_serial_number, v_batch_number);

    -- Quantity for usesComponent link for serialized is typically 1
    v_quantity_to_create := 1;

  END IF;

  -- Step 3: Create the usesComponent link
  -- Quantity_Used is the Quantity_Needed from needsComponent (which matches child quantity for non-serialized)
  IF v_child_category IN ('Commodity', 'Packaged', 'Serialized') THEN -- Only insert if subtype was handled
      INSERT INTO usesComponent (Parent_IID, Child_IID, Quantity_Used)
      VALUES (120.0, v_new_child_instance_id, ROUND(1.3, 1)); -- Use rounded quantity needed
  END IF;

EXCEPTION
  WHEN OTHERS THEN
    DBMS_OUTPUT.PUT_LINE('Error processing Parent_IID=' || 120.0 || ', Child_PID=' || 132.0 || ': ' || SQLERRM);
    -- Decide if you want to rollback just this block or let the main exception handler catch it
END;
/
DECLARE
  v_new_child_instance_id productInstance.Instance_ID%TYPE;
  v_child_category        product.Category%TYPE := 'Commodity'; -- Pass category
  v_max_existing_batch_lot NUMBER;
  v_next_batch_lot_num   NUMBER;
  v_serial_number        serialized.Serial_Number%TYPE;
  v_batch_number         serialized.Batch_Number%TYPE; -- Shared batch for serialized children of *this* parent
  v_expiration_date      commodity.Expiration_Date%TYPE;
  v_quantity_to_create   commodity.Quantity%TYPE; -- Quantity for the new child instance

BEGIN
  -- Step 1: Create the new child productInstance
  INSERT INTO productInstance (Product_ID, Date_Manufactured, Is_Recalled)
  VALUES (154.0, TIMESTAMP '2024-11-25 18:07:53', 0)
  RETURNING Instance_ID INTO v_new_child_instance_id;

  -- Step 2: Create the corresponding subtype record
  IF v_child_category = 'Commodity' THEN
    -- Find max existing Batch_Number for this specific Child_PID
    SELECT NVL(MAX(c.Batch_Number), 0) INTO v_max_existing_batch_lot
    FROM commodity c JOIN productInstance pi ON c.Instance_ID = pi.Instance_ID
    WHERE pi.Product_ID = 154.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next batch

    v_expiration_date := TIMESTAMP '2024-11-25 18:07:53' + INTERVAL '88' DAY;
    v_quantity_to_create := ROUND(1.5, 1);

    INSERT INTO commodity (Instance_ID, Batch_Number, Expiration_Date, Quantity)
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Packaged' THEN
    -- Find max existing Lot_Number for this specific Child_PID
    SELECT NVL(MAX(p.Lot_Number), 0) INTO v_max_existing_batch_lot
    FROM packaged p JOIN productInstance pi ON p.Instance_ID = pi.Instance_ID -- Assuming 'packaged' table name
    WHERE pi.Product_ID = 154.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next lot

    v_expiration_date := TIMESTAMP '2024-11-25 18:07:53' + INTERVAL '608' DAY;
    v_quantity_to_create := ROUND(1.5, 1);

    INSERT INTO packaged (Instance_ID, Lot_Number, Expiration_Date, Quantity) -- Assuming 'packaged' table name
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Serialized' THEN
    -- Assign a unique serial number
    -- Using Instance ID guarantees uniqueness within this context
    v_serial_number := 'SN-' || TO_CHAR(154.0) || '-' || TO_CHAR(v_new_child_instance_id) || '-' || SUBSTR(SYS_GUID(),1,8);
    -- Assign a batch number - use Product_ID of the *parent* instance as the batch for simplicity? Or a sequence?
    -- Let's use the Parent_IID itself as a simple batch identifier for this run.
    v_batch_number := 139.0; -- All children created FOR this parent get same batch number

    INSERT INTO serialized (Instance_ID, Serial_Number, Batch_Number)
    VALUES (v_new_child_instance_id, v_serial_number, v_batch_number);

    -- Quantity for usesComponent link for serialized is typically 1
    v_quantity_to_create := 1;

  END IF;

  -- Step 3: Create the usesComponent link
  -- Quantity_Used is the Quantity_Needed from needsComponent (which matches child quantity for non-serialized)
  IF v_child_category IN ('Commodity', 'Packaged', 'Serialized') THEN -- Only insert if subtype was handled
      INSERT INTO usesComponent (Parent_IID, Child_IID, Quantity_Used)
      VALUES (139.0, v_new_child_instance_id, ROUND(1.5, 1)); -- Use rounded quantity needed
  END IF;

EXCEPTION
  WHEN OTHERS THEN
    DBMS_OUTPUT.PUT_LINE('Error processing Parent_IID=' || 139.0 || ', Child_PID=' || 154.0 || ': ' || SQLERRM);
    -- Decide if you want to rollback just this block or let the main exception handler catch it
END;
/
DECLARE
  v_new_child_instance_id productInstance.Instance_ID%TYPE;
  v_child_category        product.Category%TYPE := 'Commodity'; -- Pass category
  v_max_existing_batch_lot NUMBER;
  v_next_batch_lot_num   NUMBER;
  v_serial_number        serialized.Serial_Number%TYPE;
  v_batch_number         serialized.Batch_Number%TYPE; -- Shared batch for serialized children of *this* parent
  v_expiration_date      commodity.Expiration_Date%TYPE;
  v_quantity_to_create   commodity.Quantity%TYPE; -- Quantity for the new child instance

BEGIN
  -- Step 1: Create the new child productInstance
  INSERT INTO productInstance (Product_ID, Date_Manufactured, Is_Recalled)
  VALUES (174.0, TIMESTAMP '2024-09-23 10:03:47', 0)
  RETURNING Instance_ID INTO v_new_child_instance_id;

  -- Step 2: Create the corresponding subtype record
  IF v_child_category = 'Commodity' THEN
    -- Find max existing Batch_Number for this specific Child_PID
    SELECT NVL(MAX(c.Batch_Number), 0) INTO v_max_existing_batch_lot
    FROM commodity c JOIN productInstance pi ON c.Instance_ID = pi.Instance_ID
    WHERE pi.Product_ID = 174.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next batch

    v_expiration_date := TIMESTAMP '2024-09-23 10:03:47' + INTERVAL '290' DAY;
    v_quantity_to_create := ROUND(0.9, 1);

    INSERT INTO commodity (Instance_ID, Batch_Number, Expiration_Date, Quantity)
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Packaged' THEN
    -- Find max existing Lot_Number for this specific Child_PID
    SELECT NVL(MAX(p.Lot_Number), 0) INTO v_max_existing_batch_lot
    FROM packaged p JOIN productInstance pi ON p.Instance_ID = pi.Instance_ID -- Assuming 'packaged' table name
    WHERE pi.Product_ID = 174.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next lot

    v_expiration_date := TIMESTAMP '2024-09-23 10:03:47' + INTERVAL '163' DAY;
    v_quantity_to_create := ROUND(0.9, 1);

    INSERT INTO packaged (Instance_ID, Lot_Number, Expiration_Date, Quantity) -- Assuming 'packaged' table name
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Serialized' THEN
    -- Assign a unique serial number
    -- Using Instance ID guarantees uniqueness within this context
    v_serial_number := 'SN-' || TO_CHAR(174.0) || '-' || TO_CHAR(v_new_child_instance_id) || '-' || SUBSTR(SYS_GUID(),1,8);
    -- Assign a batch number - use Product_ID of the *parent* instance as the batch for simplicity? Or a sequence?
    -- Let's use the Parent_IID itself as a simple batch identifier for this run.
    v_batch_number := 139.0; -- All children created FOR this parent get same batch number

    INSERT INTO serialized (Instance_ID, Serial_Number, Batch_Number)
    VALUES (v_new_child_instance_id, v_serial_number, v_batch_number);

    -- Quantity for usesComponent link for serialized is typically 1
    v_quantity_to_create := 1;

  END IF;

  -- Step 3: Create the usesComponent link
  -- Quantity_Used is the Quantity_Needed from needsComponent (which matches child quantity for non-serialized)
  IF v_child_category IN ('Commodity', 'Packaged', 'Serialized') THEN -- Only insert if subtype was handled
      INSERT INTO usesComponent (Parent_IID, Child_IID, Quantity_Used)
      VALUES (139.0, v_new_child_instance_id, ROUND(0.9, 1)); -- Use rounded quantity needed
  END IF;

EXCEPTION
  WHEN OTHERS THEN
    DBMS_OUTPUT.PUT_LINE('Error processing Parent_IID=' || 139.0 || ', Child_PID=' || 174.0 || ': ' || SQLERRM);
    -- Decide if you want to rollback just this block or let the main exception handler catch it
END;
/
DECLARE
  v_new_child_instance_id productInstance.Instance_ID%TYPE;
  v_child_category        product.Category%TYPE := 'Commodity'; -- Pass category
  v_max_existing_batch_lot NUMBER;
  v_next_batch_lot_num   NUMBER;
  v_serial_number        serialized.Serial_Number%TYPE;
  v_batch_number         serialized.Batch_Number%TYPE; -- Shared batch for serialized children of *this* parent
  v_expiration_date      commodity.Expiration_Date%TYPE;
  v_quantity_to_create   commodity.Quantity%TYPE; -- Quantity for the new child instance

BEGIN
  -- Step 1: Create the new child productInstance
  INSERT INTO productInstance (Product_ID, Date_Manufactured, Is_Recalled)
  VALUES (191.0, TIMESTAMP '2024-05-29 22:07:36', 0)
  RETURNING Instance_ID INTO v_new_child_instance_id;

  -- Step 2: Create the corresponding subtype record
  IF v_child_category = 'Commodity' THEN
    -- Find max existing Batch_Number for this specific Child_PID
    SELECT NVL(MAX(c.Batch_Number), 0) INTO v_max_existing_batch_lot
    FROM commodity c JOIN productInstance pi ON c.Instance_ID = pi.Instance_ID
    WHERE pi.Product_ID = 191.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next batch

    v_expiration_date := TIMESTAMP '2024-05-29 22:07:36' + INTERVAL '503' DAY;
    v_quantity_to_create := ROUND(0.6, 1);

    INSERT INTO commodity (Instance_ID, Batch_Number, Expiration_Date, Quantity)
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Packaged' THEN
    -- Find max existing Lot_Number for this specific Child_PID
    SELECT NVL(MAX(p.Lot_Number), 0) INTO v_max_existing_batch_lot
    FROM packaged p JOIN productInstance pi ON p.Instance_ID = pi.Instance_ID -- Assuming 'packaged' table name
    WHERE pi.Product_ID = 191.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next lot

    v_expiration_date := TIMESTAMP '2024-05-29 22:07:36' + INTERVAL '697' DAY;
    v_quantity_to_create := ROUND(0.6, 1);

    INSERT INTO packaged (Instance_ID, Lot_Number, Expiration_Date, Quantity) -- Assuming 'packaged' table name
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Serialized' THEN
    -- Assign a unique serial number
    -- Using Instance ID guarantees uniqueness within this context
    v_serial_number := 'SN-' || TO_CHAR(191.0) || '-' || TO_CHAR(v_new_child_instance_id) || '-' || SUBSTR(SYS_GUID(),1,8);
    -- Assign a batch number - use Product_ID of the *parent* instance as the batch for simplicity? Or a sequence?
    -- Let's use the Parent_IID itself as a simple batch identifier for this run.
    v_batch_number := 139.0; -- All children created FOR this parent get same batch number

    INSERT INTO serialized (Instance_ID, Serial_Number, Batch_Number)
    VALUES (v_new_child_instance_id, v_serial_number, v_batch_number);

    -- Quantity for usesComponent link for serialized is typically 1
    v_quantity_to_create := 1;

  END IF;

  -- Step 3: Create the usesComponent link
  -- Quantity_Used is the Quantity_Needed from needsComponent (which matches child quantity for non-serialized)
  IF v_child_category IN ('Commodity', 'Packaged', 'Serialized') THEN -- Only insert if subtype was handled
      INSERT INTO usesComponent (Parent_IID, Child_IID, Quantity_Used)
      VALUES (139.0, v_new_child_instance_id, ROUND(0.6, 1)); -- Use rounded quantity needed
  END IF;

EXCEPTION
  WHEN OTHERS THEN
    DBMS_OUTPUT.PUT_LINE('Error processing Parent_IID=' || 139.0 || ', Child_PID=' || 191.0 || ': ' || SQLERRM);
    -- Decide if you want to rollback just this block or let the main exception handler catch it
END;
/
DECLARE
  v_new_child_instance_id productInstance.Instance_ID%TYPE;
  v_child_category        product.Category%TYPE := 'Commodity'; -- Pass category
  v_max_existing_batch_lot NUMBER;
  v_next_batch_lot_num   NUMBER;
  v_serial_number        serialized.Serial_Number%TYPE;
  v_batch_number         serialized.Batch_Number%TYPE; -- Shared batch for serialized children of *this* parent
  v_expiration_date      commodity.Expiration_Date%TYPE;
  v_quantity_to_create   commodity.Quantity%TYPE; -- Quantity for the new child instance

BEGIN
  -- Step 1: Create the new child productInstance
  INSERT INTO productInstance (Product_ID, Date_Manufactured, Is_Recalled)
  VALUES (132.0, TIMESTAMP '2025-03-21 06:08:43', 0)
  RETURNING Instance_ID INTO v_new_child_instance_id;

  -- Step 2: Create the corresponding subtype record
  IF v_child_category = 'Commodity' THEN
    -- Find max existing Batch_Number for this specific Child_PID
    SELECT NVL(MAX(c.Batch_Number), 0) INTO v_max_existing_batch_lot
    FROM commodity c JOIN productInstance pi ON c.Instance_ID = pi.Instance_ID
    WHERE pi.Product_ID = 132.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next batch

    v_expiration_date := TIMESTAMP '2025-03-21 06:08:43' + INTERVAL '340' DAY;
    v_quantity_to_create := ROUND(1.9, 1);

    INSERT INTO commodity (Instance_ID, Batch_Number, Expiration_Date, Quantity)
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Packaged' THEN
    -- Find max existing Lot_Number for this specific Child_PID
    SELECT NVL(MAX(p.Lot_Number), 0) INTO v_max_existing_batch_lot
    FROM packaged p JOIN productInstance pi ON p.Instance_ID = pi.Instance_ID -- Assuming 'packaged' table name
    WHERE pi.Product_ID = 132.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next lot

    v_expiration_date := TIMESTAMP '2025-03-21 06:08:43' + INTERVAL '44' DAY;
    v_quantity_to_create := ROUND(1.9, 1);

    INSERT INTO packaged (Instance_ID, Lot_Number, Expiration_Date, Quantity) -- Assuming 'packaged' table name
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Serialized' THEN
    -- Assign a unique serial number
    -- Using Instance ID guarantees uniqueness within this context
    v_serial_number := 'SN-' || TO_CHAR(132.0) || '-' || TO_CHAR(v_new_child_instance_id) || '-' || SUBSTR(SYS_GUID(),1,8);
    -- Assign a batch number - use Product_ID of the *parent* instance as the batch for simplicity? Or a sequence?
    -- Let's use the Parent_IID itself as a simple batch identifier for this run.
    v_batch_number := 144.0; -- All children created FOR this parent get same batch number

    INSERT INTO serialized (Instance_ID, Serial_Number, Batch_Number)
    VALUES (v_new_child_instance_id, v_serial_number, v_batch_number);

    -- Quantity for usesComponent link for serialized is typically 1
    v_quantity_to_create := 1;

  END IF;

  -- Step 3: Create the usesComponent link
  -- Quantity_Used is the Quantity_Needed from needsComponent (which matches child quantity for non-serialized)
  IF v_child_category IN ('Commodity', 'Packaged', 'Serialized') THEN -- Only insert if subtype was handled
      INSERT INTO usesComponent (Parent_IID, Child_IID, Quantity_Used)
      VALUES (144.0, v_new_child_instance_id, ROUND(1.9, 1)); -- Use rounded quantity needed
  END IF;

EXCEPTION
  WHEN OTHERS THEN
    DBMS_OUTPUT.PUT_LINE('Error processing Parent_IID=' || 144.0 || ', Child_PID=' || 132.0 || ': ' || SQLERRM);
    -- Decide if you want to rollback just this block or let the main exception handler catch it
END;
/
DECLARE
  v_new_child_instance_id productInstance.Instance_ID%TYPE;
  v_child_category        product.Category%TYPE := 'Commodity'; -- Pass category
  v_max_existing_batch_lot NUMBER;
  v_next_batch_lot_num   NUMBER;
  v_serial_number        serialized.Serial_Number%TYPE;
  v_batch_number         serialized.Batch_Number%TYPE; -- Shared batch for serialized children of *this* parent
  v_expiration_date      commodity.Expiration_Date%TYPE;
  v_quantity_to_create   commodity.Quantity%TYPE; -- Quantity for the new child instance

BEGIN
  -- Step 1: Create the new child productInstance
  INSERT INTO productInstance (Product_ID, Date_Manufactured, Is_Recalled)
  VALUES (216.0, TIMESTAMP '2024-05-12 19:33:43', 0)
  RETURNING Instance_ID INTO v_new_child_instance_id;

  -- Step 2: Create the corresponding subtype record
  IF v_child_category = 'Commodity' THEN
    -- Find max existing Batch_Number for this specific Child_PID
    SELECT NVL(MAX(c.Batch_Number), 0) INTO v_max_existing_batch_lot
    FROM commodity c JOIN productInstance pi ON c.Instance_ID = pi.Instance_ID
    WHERE pi.Product_ID = 216.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next batch

    v_expiration_date := TIMESTAMP '2024-05-12 19:33:43' + INTERVAL '579' DAY;
    v_quantity_to_create := ROUND(0.9, 1);

    INSERT INTO commodity (Instance_ID, Batch_Number, Expiration_Date, Quantity)
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Packaged' THEN
    -- Find max existing Lot_Number for this specific Child_PID
    SELECT NVL(MAX(p.Lot_Number), 0) INTO v_max_existing_batch_lot
    FROM packaged p JOIN productInstance pi ON p.Instance_ID = pi.Instance_ID -- Assuming 'packaged' table name
    WHERE pi.Product_ID = 216.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next lot

    v_expiration_date := TIMESTAMP '2024-05-12 19:33:43' + INTERVAL '92' DAY;
    v_quantity_to_create := ROUND(0.9, 1);

    INSERT INTO packaged (Instance_ID, Lot_Number, Expiration_Date, Quantity) -- Assuming 'packaged' table name
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Serialized' THEN
    -- Assign a unique serial number
    -- Using Instance ID guarantees uniqueness within this context
    v_serial_number := 'SN-' || TO_CHAR(216.0) || '-' || TO_CHAR(v_new_child_instance_id) || '-' || SUBSTR(SYS_GUID(),1,8);
    -- Assign a batch number - use Product_ID of the *parent* instance as the batch for simplicity? Or a sequence?
    -- Let's use the Parent_IID itself as a simple batch identifier for this run.
    v_batch_number := 144.0; -- All children created FOR this parent get same batch number

    INSERT INTO serialized (Instance_ID, Serial_Number, Batch_Number)
    VALUES (v_new_child_instance_id, v_serial_number, v_batch_number);

    -- Quantity for usesComponent link for serialized is typically 1
    v_quantity_to_create := 1;

  END IF;

  -- Step 3: Create the usesComponent link
  -- Quantity_Used is the Quantity_Needed from needsComponent (which matches child quantity for non-serialized)
  IF v_child_category IN ('Commodity', 'Packaged', 'Serialized') THEN -- Only insert if subtype was handled
      INSERT INTO usesComponent (Parent_IID, Child_IID, Quantity_Used)
      VALUES (144.0, v_new_child_instance_id, ROUND(0.9, 1)); -- Use rounded quantity needed
  END IF;

EXCEPTION
  WHEN OTHERS THEN
    DBMS_OUTPUT.PUT_LINE('Error processing Parent_IID=' || 144.0 || ', Child_PID=' || 216.0 || ': ' || SQLERRM);
    -- Decide if you want to rollback just this block or let the main exception handler catch it
END;
/
DECLARE
  v_new_child_instance_id productInstance.Instance_ID%TYPE;
  v_child_category        product.Category%TYPE := 'Commodity'; -- Pass category
  v_max_existing_batch_lot NUMBER;
  v_next_batch_lot_num   NUMBER;
  v_serial_number        serialized.Serial_Number%TYPE;
  v_batch_number         serialized.Batch_Number%TYPE; -- Shared batch for serialized children of *this* parent
  v_expiration_date      commodity.Expiration_Date%TYPE;
  v_quantity_to_create   commodity.Quantity%TYPE; -- Quantity for the new child instance

BEGIN
  -- Step 1: Create the new child productInstance
  INSERT INTO productInstance (Product_ID, Date_Manufactured, Is_Recalled)
  VALUES (132.0, TIMESTAMP '2024-11-18 21:25:10', 0)
  RETURNING Instance_ID INTO v_new_child_instance_id;

  -- Step 2: Create the corresponding subtype record
  IF v_child_category = 'Commodity' THEN
    -- Find max existing Batch_Number for this specific Child_PID
    SELECT NVL(MAX(c.Batch_Number), 0) INTO v_max_existing_batch_lot
    FROM commodity c JOIN productInstance pi ON c.Instance_ID = pi.Instance_ID
    WHERE pi.Product_ID = 132.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next batch

    v_expiration_date := TIMESTAMP '2024-11-18 21:25:10' + INTERVAL '162' DAY;
    v_quantity_to_create := ROUND(1.9, 1);

    INSERT INTO commodity (Instance_ID, Batch_Number, Expiration_Date, Quantity)
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Packaged' THEN
    -- Find max existing Lot_Number for this specific Child_PID
    SELECT NVL(MAX(p.Lot_Number), 0) INTO v_max_existing_batch_lot
    FROM packaged p JOIN productInstance pi ON p.Instance_ID = pi.Instance_ID -- Assuming 'packaged' table name
    WHERE pi.Product_ID = 132.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next lot

    v_expiration_date := TIMESTAMP '2024-11-18 21:25:10' + INTERVAL '73' DAY;
    v_quantity_to_create := ROUND(1.9, 1);

    INSERT INTO packaged (Instance_ID, Lot_Number, Expiration_Date, Quantity) -- Assuming 'packaged' table name
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Serialized' THEN
    -- Assign a unique serial number
    -- Using Instance ID guarantees uniqueness within this context
    v_serial_number := 'SN-' || TO_CHAR(132.0) || '-' || TO_CHAR(v_new_child_instance_id) || '-' || SUBSTR(SYS_GUID(),1,8);
    -- Assign a batch number - use Product_ID of the *parent* instance as the batch for simplicity? Or a sequence?
    -- Let's use the Parent_IID itself as a simple batch identifier for this run.
    v_batch_number := 145.0; -- All children created FOR this parent get same batch number

    INSERT INTO serialized (Instance_ID, Serial_Number, Batch_Number)
    VALUES (v_new_child_instance_id, v_serial_number, v_batch_number);

    -- Quantity for usesComponent link for serialized is typically 1
    v_quantity_to_create := 1;

  END IF;

  -- Step 3: Create the usesComponent link
  -- Quantity_Used is the Quantity_Needed from needsComponent (which matches child quantity for non-serialized)
  IF v_child_category IN ('Commodity', 'Packaged', 'Serialized') THEN -- Only insert if subtype was handled
      INSERT INTO usesComponent (Parent_IID, Child_IID, Quantity_Used)
      VALUES (145.0, v_new_child_instance_id, ROUND(1.9, 1)); -- Use rounded quantity needed
  END IF;

EXCEPTION
  WHEN OTHERS THEN
    DBMS_OUTPUT.PUT_LINE('Error processing Parent_IID=' || 145.0 || ', Child_PID=' || 132.0 || ': ' || SQLERRM);
    -- Decide if you want to rollback just this block or let the main exception handler catch it
END;
/
DECLARE
  v_new_child_instance_id productInstance.Instance_ID%TYPE;
  v_child_category        product.Category%TYPE := 'Commodity'; -- Pass category
  v_max_existing_batch_lot NUMBER;
  v_next_batch_lot_num   NUMBER;
  v_serial_number        serialized.Serial_Number%TYPE;
  v_batch_number         serialized.Batch_Number%TYPE; -- Shared batch for serialized children of *this* parent
  v_expiration_date      commodity.Expiration_Date%TYPE;
  v_quantity_to_create   commodity.Quantity%TYPE; -- Quantity for the new child instance

BEGIN
  -- Step 1: Create the new child productInstance
  INSERT INTO productInstance (Product_ID, Date_Manufactured, Is_Recalled)
  VALUES (216.0, TIMESTAMP '2025-04-26 12:41:56', 0)
  RETURNING Instance_ID INTO v_new_child_instance_id;

  -- Step 2: Create the corresponding subtype record
  IF v_child_category = 'Commodity' THEN
    -- Find max existing Batch_Number for this specific Child_PID
    SELECT NVL(MAX(c.Batch_Number), 0) INTO v_max_existing_batch_lot
    FROM commodity c JOIN productInstance pi ON c.Instance_ID = pi.Instance_ID
    WHERE pi.Product_ID = 216.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next batch

    v_expiration_date := TIMESTAMP '2025-04-26 12:41:56' + INTERVAL '310' DAY;
    v_quantity_to_create := ROUND(0.9, 1);

    INSERT INTO commodity (Instance_ID, Batch_Number, Expiration_Date, Quantity)
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Packaged' THEN
    -- Find max existing Lot_Number for this specific Child_PID
    SELECT NVL(MAX(p.Lot_Number), 0) INTO v_max_existing_batch_lot
    FROM packaged p JOIN productInstance pi ON p.Instance_ID = pi.Instance_ID -- Assuming 'packaged' table name
    WHERE pi.Product_ID = 216.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next lot

    v_expiration_date := TIMESTAMP '2025-04-26 12:41:56' + INTERVAL '150' DAY;
    v_quantity_to_create := ROUND(0.9, 1);

    INSERT INTO packaged (Instance_ID, Lot_Number, Expiration_Date, Quantity) -- Assuming 'packaged' table name
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Serialized' THEN
    -- Assign a unique serial number
    -- Using Instance ID guarantees uniqueness within this context
    v_serial_number := 'SN-' || TO_CHAR(216.0) || '-' || TO_CHAR(v_new_child_instance_id) || '-' || SUBSTR(SYS_GUID(),1,8);
    -- Assign a batch number - use Product_ID of the *parent* instance as the batch for simplicity? Or a sequence?
    -- Let's use the Parent_IID itself as a simple batch identifier for this run.
    v_batch_number := 145.0; -- All children created FOR this parent get same batch number

    INSERT INTO serialized (Instance_ID, Serial_Number, Batch_Number)
    VALUES (v_new_child_instance_id, v_serial_number, v_batch_number);

    -- Quantity for usesComponent link for serialized is typically 1
    v_quantity_to_create := 1;

  END IF;

  -- Step 3: Create the usesComponent link
  -- Quantity_Used is the Quantity_Needed from needsComponent (which matches child quantity for non-serialized)
  IF v_child_category IN ('Commodity', 'Packaged', 'Serialized') THEN -- Only insert if subtype was handled
      INSERT INTO usesComponent (Parent_IID, Child_IID, Quantity_Used)
      VALUES (145.0, v_new_child_instance_id, ROUND(0.9, 1)); -- Use rounded quantity needed
  END IF;

EXCEPTION
  WHEN OTHERS THEN
    DBMS_OUTPUT.PUT_LINE('Error processing Parent_IID=' || 145.0 || ', Child_PID=' || 216.0 || ': ' || SQLERRM);
    -- Decide if you want to rollback just this block or let the main exception handler catch it
END;
/
DECLARE
  v_new_child_instance_id productInstance.Instance_ID%TYPE;
  v_child_category        product.Category%TYPE := 'Commodity'; -- Pass category
  v_max_existing_batch_lot NUMBER;
  v_next_batch_lot_num   NUMBER;
  v_serial_number        serialized.Serial_Number%TYPE;
  v_batch_number         serialized.Batch_Number%TYPE; -- Shared batch for serialized children of *this* parent
  v_expiration_date      commodity.Expiration_Date%TYPE;
  v_quantity_to_create   commodity.Quantity%TYPE; -- Quantity for the new child instance

BEGIN
  -- Step 1: Create the new child productInstance
  INSERT INTO productInstance (Product_ID, Date_Manufactured, Is_Recalled)
  VALUES (132.0, TIMESTAMP '2024-10-14 00:14:44', 0)
  RETURNING Instance_ID INTO v_new_child_instance_id;

  -- Step 2: Create the corresponding subtype record
  IF v_child_category = 'Commodity' THEN
    -- Find max existing Batch_Number for this specific Child_PID
    SELECT NVL(MAX(c.Batch_Number), 0) INTO v_max_existing_batch_lot
    FROM commodity c JOIN productInstance pi ON c.Instance_ID = pi.Instance_ID
    WHERE pi.Product_ID = 132.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next batch

    v_expiration_date := TIMESTAMP '2024-10-14 00:14:44' + INTERVAL '123' DAY;
    v_quantity_to_create := ROUND(1.9, 1);

    INSERT INTO commodity (Instance_ID, Batch_Number, Expiration_Date, Quantity)
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Packaged' THEN
    -- Find max existing Lot_Number for this specific Child_PID
    SELECT NVL(MAX(p.Lot_Number), 0) INTO v_max_existing_batch_lot
    FROM packaged p JOIN productInstance pi ON p.Instance_ID = pi.Instance_ID -- Assuming 'packaged' table name
    WHERE pi.Product_ID = 132.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next lot

    v_expiration_date := TIMESTAMP '2024-10-14 00:14:44' + INTERVAL '224' DAY;
    v_quantity_to_create := ROUND(1.9, 1);

    INSERT INTO packaged (Instance_ID, Lot_Number, Expiration_Date, Quantity) -- Assuming 'packaged' table name
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Serialized' THEN
    -- Assign a unique serial number
    -- Using Instance ID guarantees uniqueness within this context
    v_serial_number := 'SN-' || TO_CHAR(132.0) || '-' || TO_CHAR(v_new_child_instance_id) || '-' || SUBSTR(SYS_GUID(),1,8);
    -- Assign a batch number - use Product_ID of the *parent* instance as the batch for simplicity? Or a sequence?
    -- Let's use the Parent_IID itself as a simple batch identifier for this run.
    v_batch_number := 146.0; -- All children created FOR this parent get same batch number

    INSERT INTO serialized (Instance_ID, Serial_Number, Batch_Number)
    VALUES (v_new_child_instance_id, v_serial_number, v_batch_number);

    -- Quantity for usesComponent link for serialized is typically 1
    v_quantity_to_create := 1;

  END IF;

  -- Step 3: Create the usesComponent link
  -- Quantity_Used is the Quantity_Needed from needsComponent (which matches child quantity for non-serialized)
  IF v_child_category IN ('Commodity', 'Packaged', 'Serialized') THEN -- Only insert if subtype was handled
      INSERT INTO usesComponent (Parent_IID, Child_IID, Quantity_Used)
      VALUES (146.0, v_new_child_instance_id, ROUND(1.9, 1)); -- Use rounded quantity needed
  END IF;

EXCEPTION
  WHEN OTHERS THEN
    DBMS_OUTPUT.PUT_LINE('Error processing Parent_IID=' || 146.0 || ', Child_PID=' || 132.0 || ': ' || SQLERRM);
    -- Decide if you want to rollback just this block or let the main exception handler catch it
END;
/
DECLARE
  v_new_child_instance_id productInstance.Instance_ID%TYPE;
  v_child_category        product.Category%TYPE := 'Commodity'; -- Pass category
  v_max_existing_batch_lot NUMBER;
  v_next_batch_lot_num   NUMBER;
  v_serial_number        serialized.Serial_Number%TYPE;
  v_batch_number         serialized.Batch_Number%TYPE; -- Shared batch for serialized children of *this* parent
  v_expiration_date      commodity.Expiration_Date%TYPE;
  v_quantity_to_create   commodity.Quantity%TYPE; -- Quantity for the new child instance

BEGIN
  -- Step 1: Create the new child productInstance
  INSERT INTO productInstance (Product_ID, Date_Manufactured, Is_Recalled)
  VALUES (216.0, TIMESTAMP '2024-05-09 18:25:30', 0)
  RETURNING Instance_ID INTO v_new_child_instance_id;

  -- Step 2: Create the corresponding subtype record
  IF v_child_category = 'Commodity' THEN
    -- Find max existing Batch_Number for this specific Child_PID
    SELECT NVL(MAX(c.Batch_Number), 0) INTO v_max_existing_batch_lot
    FROM commodity c JOIN productInstance pi ON c.Instance_ID = pi.Instance_ID
    WHERE pi.Product_ID = 216.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next batch

    v_expiration_date := TIMESTAMP '2024-05-09 18:25:30' + INTERVAL '541' DAY;
    v_quantity_to_create := ROUND(0.9, 1);

    INSERT INTO commodity (Instance_ID, Batch_Number, Expiration_Date, Quantity)
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Packaged' THEN
    -- Find max existing Lot_Number for this specific Child_PID
    SELECT NVL(MAX(p.Lot_Number), 0) INTO v_max_existing_batch_lot
    FROM packaged p JOIN productInstance pi ON p.Instance_ID = pi.Instance_ID -- Assuming 'packaged' table name
    WHERE pi.Product_ID = 216.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next lot

    v_expiration_date := TIMESTAMP '2024-05-09 18:25:30' + INTERVAL '682' DAY;
    v_quantity_to_create := ROUND(0.9, 1);

    INSERT INTO packaged (Instance_ID, Lot_Number, Expiration_Date, Quantity) -- Assuming 'packaged' table name
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Serialized' THEN
    -- Assign a unique serial number
    -- Using Instance ID guarantees uniqueness within this context
    v_serial_number := 'SN-' || TO_CHAR(216.0) || '-' || TO_CHAR(v_new_child_instance_id) || '-' || SUBSTR(SYS_GUID(),1,8);
    -- Assign a batch number - use Product_ID of the *parent* instance as the batch for simplicity? Or a sequence?
    -- Let's use the Parent_IID itself as a simple batch identifier for this run.
    v_batch_number := 146.0; -- All children created FOR this parent get same batch number

    INSERT INTO serialized (Instance_ID, Serial_Number, Batch_Number)
    VALUES (v_new_child_instance_id, v_serial_number, v_batch_number);

    -- Quantity for usesComponent link for serialized is typically 1
    v_quantity_to_create := 1;

  END IF;

  -- Step 3: Create the usesComponent link
  -- Quantity_Used is the Quantity_Needed from needsComponent (which matches child quantity for non-serialized)
  IF v_child_category IN ('Commodity', 'Packaged', 'Serialized') THEN -- Only insert if subtype was handled
      INSERT INTO usesComponent (Parent_IID, Child_IID, Quantity_Used)
      VALUES (146.0, v_new_child_instance_id, ROUND(0.9, 1)); -- Use rounded quantity needed
  END IF;

EXCEPTION
  WHEN OTHERS THEN
    DBMS_OUTPUT.PUT_LINE('Error processing Parent_IID=' || 146.0 || ', Child_PID=' || 216.0 || ': ' || SQLERRM);
    -- Decide if you want to rollback just this block or let the main exception handler catch it
END;
/
DECLARE
  v_new_child_instance_id productInstance.Instance_ID%TYPE;
  v_child_category        product.Category%TYPE := 'Commodity'; -- Pass category
  v_max_existing_batch_lot NUMBER;
  v_next_batch_lot_num   NUMBER;
  v_serial_number        serialized.Serial_Number%TYPE;
  v_batch_number         serialized.Batch_Number%TYPE; -- Shared batch for serialized children of *this* parent
  v_expiration_date      commodity.Expiration_Date%TYPE;
  v_quantity_to_create   commodity.Quantity%TYPE; -- Quantity for the new child instance

BEGIN
  -- Step 1: Create the new child productInstance
  INSERT INTO productInstance (Product_ID, Date_Manufactured, Is_Recalled)
  VALUES (601.0, TIMESTAMP '2024-06-18 15:33:16', 0)
  RETURNING Instance_ID INTO v_new_child_instance_id;

  -- Step 2: Create the corresponding subtype record
  IF v_child_category = 'Commodity' THEN
    -- Find max existing Batch_Number for this specific Child_PID
    SELECT NVL(MAX(c.Batch_Number), 0) INTO v_max_existing_batch_lot
    FROM commodity c JOIN productInstance pi ON c.Instance_ID = pi.Instance_ID
    WHERE pi.Product_ID = 601.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next batch

    v_expiration_date := TIMESTAMP '2024-06-18 15:33:16' + INTERVAL '315' DAY;
    v_quantity_to_create := ROUND(0.2, 1);

    INSERT INTO commodity (Instance_ID, Batch_Number, Expiration_Date, Quantity)
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Packaged' THEN
    -- Find max existing Lot_Number for this specific Child_PID
    SELECT NVL(MAX(p.Lot_Number), 0) INTO v_max_existing_batch_lot
    FROM packaged p JOIN productInstance pi ON p.Instance_ID = pi.Instance_ID -- Assuming 'packaged' table name
    WHERE pi.Product_ID = 601.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next lot

    v_expiration_date := TIMESTAMP '2024-06-18 15:33:16' + INTERVAL '226' DAY;
    v_quantity_to_create := ROUND(0.2, 1);

    INSERT INTO packaged (Instance_ID, Lot_Number, Expiration_Date, Quantity) -- Assuming 'packaged' table name
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Serialized' THEN
    -- Assign a unique serial number
    -- Using Instance ID guarantees uniqueness within this context
    v_serial_number := 'SN-' || TO_CHAR(601.0) || '-' || TO_CHAR(v_new_child_instance_id) || '-' || SUBSTR(SYS_GUID(),1,8);
    -- Assign a batch number - use Product_ID of the *parent* instance as the batch for simplicity? Or a sequence?
    -- Let's use the Parent_IID itself as a simple batch identifier for this run.
    v_batch_number := 194.0; -- All children created FOR this parent get same batch number

    INSERT INTO serialized (Instance_ID, Serial_Number, Batch_Number)
    VALUES (v_new_child_instance_id, v_serial_number, v_batch_number);

    -- Quantity for usesComponent link for serialized is typically 1
    v_quantity_to_create := 1;

  END IF;

  -- Step 3: Create the usesComponent link
  -- Quantity_Used is the Quantity_Needed from needsComponent (which matches child quantity for non-serialized)
  IF v_child_category IN ('Commodity', 'Packaged', 'Serialized') THEN -- Only insert if subtype was handled
      INSERT INTO usesComponent (Parent_IID, Child_IID, Quantity_Used)
      VALUES (194.0, v_new_child_instance_id, ROUND(0.2, 1)); -- Use rounded quantity needed
  END IF;

EXCEPTION
  WHEN OTHERS THEN
    DBMS_OUTPUT.PUT_LINE('Error processing Parent_IID=' || 194.0 || ', Child_PID=' || 601.0 || ': ' || SQLERRM);
    -- Decide if you want to rollback just this block or let the main exception handler catch it
END;
/
DECLARE
  v_new_child_instance_id productInstance.Instance_ID%TYPE;
  v_child_category        product.Category%TYPE := 'Commodity'; -- Pass category
  v_max_existing_batch_lot NUMBER;
  v_next_batch_lot_num   NUMBER;
  v_serial_number        serialized.Serial_Number%TYPE;
  v_batch_number         serialized.Batch_Number%TYPE; -- Shared batch for serialized children of *this* parent
  v_expiration_date      commodity.Expiration_Date%TYPE;
  v_quantity_to_create   commodity.Quantity%TYPE; -- Quantity for the new child instance

BEGIN
  -- Step 1: Create the new child productInstance
  INSERT INTO productInstance (Product_ID, Date_Manufactured, Is_Recalled)
  VALUES (601.0, TIMESTAMP '2025-01-11 12:43:11', 0)
  RETURNING Instance_ID INTO v_new_child_instance_id;

  -- Step 2: Create the corresponding subtype record
  IF v_child_category = 'Commodity' THEN
    -- Find max existing Batch_Number for this specific Child_PID
    SELECT NVL(MAX(c.Batch_Number), 0) INTO v_max_existing_batch_lot
    FROM commodity c JOIN productInstance pi ON c.Instance_ID = pi.Instance_ID
    WHERE pi.Product_ID = 601.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next batch

    v_expiration_date := TIMESTAMP '2025-01-11 12:43:11' + INTERVAL '488' DAY;
    v_quantity_to_create := ROUND(0.2, 1);

    INSERT INTO commodity (Instance_ID, Batch_Number, Expiration_Date, Quantity)
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Packaged' THEN
    -- Find max existing Lot_Number for this specific Child_PID
    SELECT NVL(MAX(p.Lot_Number), 0) INTO v_max_existing_batch_lot
    FROM packaged p JOIN productInstance pi ON p.Instance_ID = pi.Instance_ID -- Assuming 'packaged' table name
    WHERE pi.Product_ID = 601.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next lot

    v_expiration_date := TIMESTAMP '2025-01-11 12:43:11' + INTERVAL '429' DAY;
    v_quantity_to_create := ROUND(0.2, 1);

    INSERT INTO packaged (Instance_ID, Lot_Number, Expiration_Date, Quantity) -- Assuming 'packaged' table name
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Serialized' THEN
    -- Assign a unique serial number
    -- Using Instance ID guarantees uniqueness within this context
    v_serial_number := 'SN-' || TO_CHAR(601.0) || '-' || TO_CHAR(v_new_child_instance_id) || '-' || SUBSTR(SYS_GUID(),1,8);
    -- Assign a batch number - use Product_ID of the *parent* instance as the batch for simplicity? Or a sequence?
    -- Let's use the Parent_IID itself as a simple batch identifier for this run.
    v_batch_number := 195.0; -- All children created FOR this parent get same batch number

    INSERT INTO serialized (Instance_ID, Serial_Number, Batch_Number)
    VALUES (v_new_child_instance_id, v_serial_number, v_batch_number);

    -- Quantity for usesComponent link for serialized is typically 1
    v_quantity_to_create := 1;

  END IF;

  -- Step 3: Create the usesComponent link
  -- Quantity_Used is the Quantity_Needed from needsComponent (which matches child quantity for non-serialized)
  IF v_child_category IN ('Commodity', 'Packaged', 'Serialized') THEN -- Only insert if subtype was handled
      INSERT INTO usesComponent (Parent_IID, Child_IID, Quantity_Used)
      VALUES (195.0, v_new_child_instance_id, ROUND(0.2, 1)); -- Use rounded quantity needed
  END IF;

EXCEPTION
  WHEN OTHERS THEN
    DBMS_OUTPUT.PUT_LINE('Error processing Parent_IID=' || 195.0 || ', Child_PID=' || 601.0 || ': ' || SQLERRM);
    -- Decide if you want to rollback just this block or let the main exception handler catch it
END;
/
DECLARE
  v_new_child_instance_id productInstance.Instance_ID%TYPE;
  v_child_category        product.Category%TYPE := 'Commodity'; -- Pass category
  v_max_existing_batch_lot NUMBER;
  v_next_batch_lot_num   NUMBER;
  v_serial_number        serialized.Serial_Number%TYPE;
  v_batch_number         serialized.Batch_Number%TYPE; -- Shared batch for serialized children of *this* parent
  v_expiration_date      commodity.Expiration_Date%TYPE;
  v_quantity_to_create   commodity.Quantity%TYPE; -- Quantity for the new child instance

BEGIN
  -- Step 1: Create the new child productInstance
  INSERT INTO productInstance (Product_ID, Date_Manufactured, Is_Recalled)
  VALUES (601.0, TIMESTAMP '2024-09-04 02:57:58', 0)
  RETURNING Instance_ID INTO v_new_child_instance_id;

  -- Step 2: Create the corresponding subtype record
  IF v_child_category = 'Commodity' THEN
    -- Find max existing Batch_Number for this specific Child_PID
    SELECT NVL(MAX(c.Batch_Number), 0) INTO v_max_existing_batch_lot
    FROM commodity c JOIN productInstance pi ON c.Instance_ID = pi.Instance_ID
    WHERE pi.Product_ID = 601.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next batch

    v_expiration_date := TIMESTAMP '2024-09-04 02:57:58' + INTERVAL '676' DAY;
    v_quantity_to_create := ROUND(0.2, 1);

    INSERT INTO commodity (Instance_ID, Batch_Number, Expiration_Date, Quantity)
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Packaged' THEN
    -- Find max existing Lot_Number for this specific Child_PID
    SELECT NVL(MAX(p.Lot_Number), 0) INTO v_max_existing_batch_lot
    FROM packaged p JOIN productInstance pi ON p.Instance_ID = pi.Instance_ID -- Assuming 'packaged' table name
    WHERE pi.Product_ID = 601.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next lot

    v_expiration_date := TIMESTAMP '2024-09-04 02:57:58' + INTERVAL '304' DAY;
    v_quantity_to_create := ROUND(0.2, 1);

    INSERT INTO packaged (Instance_ID, Lot_Number, Expiration_Date, Quantity) -- Assuming 'packaged' table name
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Serialized' THEN
    -- Assign a unique serial number
    -- Using Instance ID guarantees uniqueness within this context
    v_serial_number := 'SN-' || TO_CHAR(601.0) || '-' || TO_CHAR(v_new_child_instance_id) || '-' || SUBSTR(SYS_GUID(),1,8);
    -- Assign a batch number - use Product_ID of the *parent* instance as the batch for simplicity? Or a sequence?
    -- Let's use the Parent_IID itself as a simple batch identifier for this run.
    v_batch_number := 196.0; -- All children created FOR this parent get same batch number

    INSERT INTO serialized (Instance_ID, Serial_Number, Batch_Number)
    VALUES (v_new_child_instance_id, v_serial_number, v_batch_number);

    -- Quantity for usesComponent link for serialized is typically 1
    v_quantity_to_create := 1;

  END IF;

  -- Step 3: Create the usesComponent link
  -- Quantity_Used is the Quantity_Needed from needsComponent (which matches child quantity for non-serialized)
  IF v_child_category IN ('Commodity', 'Packaged', 'Serialized') THEN -- Only insert if subtype was handled
      INSERT INTO usesComponent (Parent_IID, Child_IID, Quantity_Used)
      VALUES (196.0, v_new_child_instance_id, ROUND(0.2, 1)); -- Use rounded quantity needed
  END IF;

EXCEPTION
  WHEN OTHERS THEN
    DBMS_OUTPUT.PUT_LINE('Error processing Parent_IID=' || 196.0 || ', Child_PID=' || 601.0 || ': ' || SQLERRM);
    -- Decide if you want to rollback just this block or let the main exception handler catch it
END;
/
DECLARE
  v_new_child_instance_id productInstance.Instance_ID%TYPE;
  v_child_category        product.Category%TYPE := 'Commodity'; -- Pass category
  v_max_existing_batch_lot NUMBER;
  v_next_batch_lot_num   NUMBER;
  v_serial_number        serialized.Serial_Number%TYPE;
  v_batch_number         serialized.Batch_Number%TYPE; -- Shared batch for serialized children of *this* parent
  v_expiration_date      commodity.Expiration_Date%TYPE;
  v_quantity_to_create   commodity.Quantity%TYPE; -- Quantity for the new child instance

BEGIN
  -- Step 1: Create the new child productInstance
  INSERT INTO productInstance (Product_ID, Date_Manufactured, Is_Recalled)
  VALUES (601.0, TIMESTAMP '2024-08-07 22:52:15', 0)
  RETURNING Instance_ID INTO v_new_child_instance_id;

  -- Step 2: Create the corresponding subtype record
  IF v_child_category = 'Commodity' THEN
    -- Find max existing Batch_Number for this specific Child_PID
    SELECT NVL(MAX(c.Batch_Number), 0) INTO v_max_existing_batch_lot
    FROM commodity c JOIN productInstance pi ON c.Instance_ID = pi.Instance_ID
    WHERE pi.Product_ID = 601.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next batch

    v_expiration_date := TIMESTAMP '2024-08-07 22:52:15' + INTERVAL '687' DAY;
    v_quantity_to_create := ROUND(1.0, 1);

    INSERT INTO commodity (Instance_ID, Batch_Number, Expiration_Date, Quantity)
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Packaged' THEN
    -- Find max existing Lot_Number for this specific Child_PID
    SELECT NVL(MAX(p.Lot_Number), 0) INTO v_max_existing_batch_lot
    FROM packaged p JOIN productInstance pi ON p.Instance_ID = pi.Instance_ID -- Assuming 'packaged' table name
    WHERE pi.Product_ID = 601.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next lot

    v_expiration_date := TIMESTAMP '2024-08-07 22:52:15' + INTERVAL '680' DAY;
    v_quantity_to_create := ROUND(1.0, 1);

    INSERT INTO packaged (Instance_ID, Lot_Number, Expiration_Date, Quantity) -- Assuming 'packaged' table name
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Serialized' THEN
    -- Assign a unique serial number
    -- Using Instance ID guarantees uniqueness within this context
    v_serial_number := 'SN-' || TO_CHAR(601.0) || '-' || TO_CHAR(v_new_child_instance_id) || '-' || SUBSTR(SYS_GUID(),1,8);
    -- Assign a batch number - use Product_ID of the *parent* instance as the batch for simplicity? Or a sequence?
    -- Let's use the Parent_IID itself as a simple batch identifier for this run.
    v_batch_number := 201.0; -- All children created FOR this parent get same batch number

    INSERT INTO serialized (Instance_ID, Serial_Number, Batch_Number)
    VALUES (v_new_child_instance_id, v_serial_number, v_batch_number);

    -- Quantity for usesComponent link for serialized is typically 1
    v_quantity_to_create := 1;

  END IF;

  -- Step 3: Create the usesComponent link
  -- Quantity_Used is the Quantity_Needed from needsComponent (which matches child quantity for non-serialized)
  IF v_child_category IN ('Commodity', 'Packaged', 'Serialized') THEN -- Only insert if subtype was handled
      INSERT INTO usesComponent (Parent_IID, Child_IID, Quantity_Used)
      VALUES (201.0, v_new_child_instance_id, ROUND(1.0, 1)); -- Use rounded quantity needed
  END IF;

EXCEPTION
  WHEN OTHERS THEN
    DBMS_OUTPUT.PUT_LINE('Error processing Parent_IID=' || 201.0 || ', Child_PID=' || 601.0 || ': ' || SQLERRM);
    -- Decide if you want to rollback just this block or let the main exception handler catch it
END;
/
DECLARE
  v_new_child_instance_id productInstance.Instance_ID%TYPE;
  v_child_category        product.Category%TYPE := 'Commodity'; -- Pass category
  v_max_existing_batch_lot NUMBER;
  v_next_batch_lot_num   NUMBER;
  v_serial_number        serialized.Serial_Number%TYPE;
  v_batch_number         serialized.Batch_Number%TYPE; -- Shared batch for serialized children of *this* parent
  v_expiration_date      commodity.Expiration_Date%TYPE;
  v_quantity_to_create   commodity.Quantity%TYPE; -- Quantity for the new child instance

BEGIN
  -- Step 1: Create the new child productInstance
  INSERT INTO productInstance (Product_ID, Date_Manufactured, Is_Recalled)
  VALUES (601.0, TIMESTAMP '2024-08-01 10:44:25', 0)
  RETURNING Instance_ID INTO v_new_child_instance_id;

  -- Step 2: Create the corresponding subtype record
  IF v_child_category = 'Commodity' THEN
    -- Find max existing Batch_Number for this specific Child_PID
    SELECT NVL(MAX(c.Batch_Number), 0) INTO v_max_existing_batch_lot
    FROM commodity c JOIN productInstance pi ON c.Instance_ID = pi.Instance_ID
    WHERE pi.Product_ID = 601.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next batch

    v_expiration_date := TIMESTAMP '2024-08-01 10:44:25' + INTERVAL '281' DAY;
    v_quantity_to_create := ROUND(1.0, 1);

    INSERT INTO commodity (Instance_ID, Batch_Number, Expiration_Date, Quantity)
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Packaged' THEN
    -- Find max existing Lot_Number for this specific Child_PID
    SELECT NVL(MAX(p.Lot_Number), 0) INTO v_max_existing_batch_lot
    FROM packaged p JOIN productInstance pi ON p.Instance_ID = pi.Instance_ID -- Assuming 'packaged' table name
    WHERE pi.Product_ID = 601.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next lot

    v_expiration_date := TIMESTAMP '2024-08-01 10:44:25' + INTERVAL '91' DAY;
    v_quantity_to_create := ROUND(1.0, 1);

    INSERT INTO packaged (Instance_ID, Lot_Number, Expiration_Date, Quantity) -- Assuming 'packaged' table name
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Serialized' THEN
    -- Assign a unique serial number
    -- Using Instance ID guarantees uniqueness within this context
    v_serial_number := 'SN-' || TO_CHAR(601.0) || '-' || TO_CHAR(v_new_child_instance_id) || '-' || SUBSTR(SYS_GUID(),1,8);
    -- Assign a batch number - use Product_ID of the *parent* instance as the batch for simplicity? Or a sequence?
    -- Let's use the Parent_IID itself as a simple batch identifier for this run.
    v_batch_number := 202.0; -- All children created FOR this parent get same batch number

    INSERT INTO serialized (Instance_ID, Serial_Number, Batch_Number)
    VALUES (v_new_child_instance_id, v_serial_number, v_batch_number);

    -- Quantity for usesComponent link for serialized is typically 1
    v_quantity_to_create := 1;

  END IF;

  -- Step 3: Create the usesComponent link
  -- Quantity_Used is the Quantity_Needed from needsComponent (which matches child quantity for non-serialized)
  IF v_child_category IN ('Commodity', 'Packaged', 'Serialized') THEN -- Only insert if subtype was handled
      INSERT INTO usesComponent (Parent_IID, Child_IID, Quantity_Used)
      VALUES (202.0, v_new_child_instance_id, ROUND(1.0, 1)); -- Use rounded quantity needed
  END IF;

EXCEPTION
  WHEN OTHERS THEN
    DBMS_OUTPUT.PUT_LINE('Error processing Parent_IID=' || 202.0 || ', Child_PID=' || 601.0 || ': ' || SQLERRM);
    -- Decide if you want to rollback just this block or let the main exception handler catch it
END;
/
DECLARE
  v_new_child_instance_id productInstance.Instance_ID%TYPE;
  v_child_category        product.Category%TYPE := 'Commodity'; -- Pass category
  v_max_existing_batch_lot NUMBER;
  v_next_batch_lot_num   NUMBER;
  v_serial_number        serialized.Serial_Number%TYPE;
  v_batch_number         serialized.Batch_Number%TYPE; -- Shared batch for serialized children of *this* parent
  v_expiration_date      commodity.Expiration_Date%TYPE;
  v_quantity_to_create   commodity.Quantity%TYPE; -- Quantity for the new child instance

BEGIN
  -- Step 1: Create the new child productInstance
  INSERT INTO productInstance (Product_ID, Date_Manufactured, Is_Recalled)
  VALUES (601.0, TIMESTAMP '2024-12-13 08:49:09', 0)
  RETURNING Instance_ID INTO v_new_child_instance_id;

  -- Step 2: Create the corresponding subtype record
  IF v_child_category = 'Commodity' THEN
    -- Find max existing Batch_Number for this specific Child_PID
    SELECT NVL(MAX(c.Batch_Number), 0) INTO v_max_existing_batch_lot
    FROM commodity c JOIN productInstance pi ON c.Instance_ID = pi.Instance_ID
    WHERE pi.Product_ID = 601.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next batch

    v_expiration_date := TIMESTAMP '2024-12-13 08:49:09' + INTERVAL '634' DAY;
    v_quantity_to_create := ROUND(1.0, 1);

    INSERT INTO commodity (Instance_ID, Batch_Number, Expiration_Date, Quantity)
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Packaged' THEN
    -- Find max existing Lot_Number for this specific Child_PID
    SELECT NVL(MAX(p.Lot_Number), 0) INTO v_max_existing_batch_lot
    FROM packaged p JOIN productInstance pi ON p.Instance_ID = pi.Instance_ID -- Assuming 'packaged' table name
    WHERE pi.Product_ID = 601.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next lot

    v_expiration_date := TIMESTAMP '2024-12-13 08:49:09' + INTERVAL '209' DAY;
    v_quantity_to_create := ROUND(1.0, 1);

    INSERT INTO packaged (Instance_ID, Lot_Number, Expiration_Date, Quantity) -- Assuming 'packaged' table name
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Serialized' THEN
    -- Assign a unique serial number
    -- Using Instance ID guarantees uniqueness within this context
    v_serial_number := 'SN-' || TO_CHAR(601.0) || '-' || TO_CHAR(v_new_child_instance_id) || '-' || SUBSTR(SYS_GUID(),1,8);
    -- Assign a batch number - use Product_ID of the *parent* instance as the batch for simplicity? Or a sequence?
    -- Let's use the Parent_IID itself as a simple batch identifier for this run.
    v_batch_number := 203.0; -- All children created FOR this parent get same batch number

    INSERT INTO serialized (Instance_ID, Serial_Number, Batch_Number)
    VALUES (v_new_child_instance_id, v_serial_number, v_batch_number);

    -- Quantity for usesComponent link for serialized is typically 1
    v_quantity_to_create := 1;

  END IF;

  -- Step 3: Create the usesComponent link
  -- Quantity_Used is the Quantity_Needed from needsComponent (which matches child quantity for non-serialized)
  IF v_child_category IN ('Commodity', 'Packaged', 'Serialized') THEN -- Only insert if subtype was handled
      INSERT INTO usesComponent (Parent_IID, Child_IID, Quantity_Used)
      VALUES (203.0, v_new_child_instance_id, ROUND(1.0, 1)); -- Use rounded quantity needed
  END IF;

EXCEPTION
  WHEN OTHERS THEN
    DBMS_OUTPUT.PUT_LINE('Error processing Parent_IID=' || 203.0 || ', Child_PID=' || 601.0 || ': ' || SQLERRM);
    -- Decide if you want to rollback just this block or let the main exception handler catch it
END;
/
DECLARE
  v_new_child_instance_id productInstance.Instance_ID%TYPE;
  v_child_category        product.Category%TYPE := 'Commodity'; -- Pass category
  v_max_existing_batch_lot NUMBER;
  v_next_batch_lot_num   NUMBER;
  v_serial_number        serialized.Serial_Number%TYPE;
  v_batch_number         serialized.Batch_Number%TYPE; -- Shared batch for serialized children of *this* parent
  v_expiration_date      commodity.Expiration_Date%TYPE;
  v_quantity_to_create   commodity.Quantity%TYPE; -- Quantity for the new child instance

BEGIN
  -- Step 1: Create the new child productInstance
  INSERT INTO productInstance (Product_ID, Date_Manufactured, Is_Recalled)
  VALUES (212.0, TIMESTAMP '2024-09-11 19:36:24', 0)
  RETURNING Instance_ID INTO v_new_child_instance_id;

  -- Step 2: Create the corresponding subtype record
  IF v_child_category = 'Commodity' THEN
    -- Find max existing Batch_Number for this specific Child_PID
    SELECT NVL(MAX(c.Batch_Number), 0) INTO v_max_existing_batch_lot
    FROM commodity c JOIN productInstance pi ON c.Instance_ID = pi.Instance_ID
    WHERE pi.Product_ID = 212.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next batch

    v_expiration_date := TIMESTAMP '2024-09-11 19:36:24' + INTERVAL '468' DAY;
    v_quantity_to_create := ROUND(1.0, 1);

    INSERT INTO commodity (Instance_ID, Batch_Number, Expiration_Date, Quantity)
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Packaged' THEN
    -- Find max existing Lot_Number for this specific Child_PID
    SELECT NVL(MAX(p.Lot_Number), 0) INTO v_max_existing_batch_lot
    FROM packaged p JOIN productInstance pi ON p.Instance_ID = pi.Instance_ID -- Assuming 'packaged' table name
    WHERE pi.Product_ID = 212.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next lot

    v_expiration_date := TIMESTAMP '2024-09-11 19:36:24' + INTERVAL '649' DAY;
    v_quantity_to_create := ROUND(1.0, 1);

    INSERT INTO packaged (Instance_ID, Lot_Number, Expiration_Date, Quantity) -- Assuming 'packaged' table name
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Serialized' THEN
    -- Assign a unique serial number
    -- Using Instance ID guarantees uniqueness within this context
    v_serial_number := 'SN-' || TO_CHAR(212.0) || '-' || TO_CHAR(v_new_child_instance_id) || '-' || SUBSTR(SYS_GUID(),1,8);
    -- Assign a batch number - use Product_ID of the *parent* instance as the batch for simplicity? Or a sequence?
    -- Let's use the Parent_IID itself as a simple batch identifier for this run.
    v_batch_number := 211.0; -- All children created FOR this parent get same batch number

    INSERT INTO serialized (Instance_ID, Serial_Number, Batch_Number)
    VALUES (v_new_child_instance_id, v_serial_number, v_batch_number);

    -- Quantity for usesComponent link for serialized is typically 1
    v_quantity_to_create := 1;

  END IF;

  -- Step 3: Create the usesComponent link
  -- Quantity_Used is the Quantity_Needed from needsComponent (which matches child quantity for non-serialized)
  IF v_child_category IN ('Commodity', 'Packaged', 'Serialized') THEN -- Only insert if subtype was handled
      INSERT INTO usesComponent (Parent_IID, Child_IID, Quantity_Used)
      VALUES (211.0, v_new_child_instance_id, ROUND(1.0, 1)); -- Use rounded quantity needed
  END IF;

EXCEPTION
  WHEN OTHERS THEN
    DBMS_OUTPUT.PUT_LINE('Error processing Parent_IID=' || 211.0 || ', Child_PID=' || 212.0 || ': ' || SQLERRM);
    -- Decide if you want to rollback just this block or let the main exception handler catch it
END;
/
DECLARE
  v_new_child_instance_id productInstance.Instance_ID%TYPE;
  v_child_category        product.Category%TYPE := 'Commodity'; -- Pass category
  v_max_existing_batch_lot NUMBER;
  v_next_batch_lot_num   NUMBER;
  v_serial_number        serialized.Serial_Number%TYPE;
  v_batch_number         serialized.Batch_Number%TYPE; -- Shared batch for serialized children of *this* parent
  v_expiration_date      commodity.Expiration_Date%TYPE;
  v_quantity_to_create   commodity.Quantity%TYPE; -- Quantity for the new child instance

BEGIN
  -- Step 1: Create the new child productInstance
  INSERT INTO productInstance (Product_ID, Date_Manufactured, Is_Recalled)
  VALUES (134.0, TIMESTAMP '2025-01-25 03:19:04', 0)
  RETURNING Instance_ID INTO v_new_child_instance_id;

  -- Step 2: Create the corresponding subtype record
  IF v_child_category = 'Commodity' THEN
    -- Find max existing Batch_Number for this specific Child_PID
    SELECT NVL(MAX(c.Batch_Number), 0) INTO v_max_existing_batch_lot
    FROM commodity c JOIN productInstance pi ON c.Instance_ID = pi.Instance_ID
    WHERE pi.Product_ID = 134.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next batch

    v_expiration_date := TIMESTAMP '2025-01-25 03:19:04' + INTERVAL '603' DAY;
    v_quantity_to_create := ROUND(0.8, 1);

    INSERT INTO commodity (Instance_ID, Batch_Number, Expiration_Date, Quantity)
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Packaged' THEN
    -- Find max existing Lot_Number for this specific Child_PID
    SELECT NVL(MAX(p.Lot_Number), 0) INTO v_max_existing_batch_lot
    FROM packaged p JOIN productInstance pi ON p.Instance_ID = pi.Instance_ID -- Assuming 'packaged' table name
    WHERE pi.Product_ID = 134.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next lot

    v_expiration_date := TIMESTAMP '2025-01-25 03:19:04' + INTERVAL '683' DAY;
    v_quantity_to_create := ROUND(0.8, 1);

    INSERT INTO packaged (Instance_ID, Lot_Number, Expiration_Date, Quantity) -- Assuming 'packaged' table name
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Serialized' THEN
    -- Assign a unique serial number
    -- Using Instance ID guarantees uniqueness within this context
    v_serial_number := 'SN-' || TO_CHAR(134.0) || '-' || TO_CHAR(v_new_child_instance_id) || '-' || SUBSTR(SYS_GUID(),1,8);
    -- Assign a batch number - use Product_ID of the *parent* instance as the batch for simplicity? Or a sequence?
    -- Let's use the Parent_IID itself as a simple batch identifier for this run.
    v_batch_number := 211.0; -- All children created FOR this parent get same batch number

    INSERT INTO serialized (Instance_ID, Serial_Number, Batch_Number)
    VALUES (v_new_child_instance_id, v_serial_number, v_batch_number);

    -- Quantity for usesComponent link for serialized is typically 1
    v_quantity_to_create := 1;

  END IF;

  -- Step 3: Create the usesComponent link
  -- Quantity_Used is the Quantity_Needed from needsComponent (which matches child quantity for non-serialized)
  IF v_child_category IN ('Commodity', 'Packaged', 'Serialized') THEN -- Only insert if subtype was handled
      INSERT INTO usesComponent (Parent_IID, Child_IID, Quantity_Used)
      VALUES (211.0, v_new_child_instance_id, ROUND(0.8, 1)); -- Use rounded quantity needed
  END IF;

EXCEPTION
  WHEN OTHERS THEN
    DBMS_OUTPUT.PUT_LINE('Error processing Parent_IID=' || 211.0 || ', Child_PID=' || 134.0 || ': ' || SQLERRM);
    -- Decide if you want to rollback just this block or let the main exception handler catch it
END;
/
DECLARE
  v_new_child_instance_id productInstance.Instance_ID%TYPE;
  v_child_category        product.Category%TYPE := 'Commodity'; -- Pass category
  v_max_existing_batch_lot NUMBER;
  v_next_batch_lot_num   NUMBER;
  v_serial_number        serialized.Serial_Number%TYPE;
  v_batch_number         serialized.Batch_Number%TYPE; -- Shared batch for serialized children of *this* parent
  v_expiration_date      commodity.Expiration_Date%TYPE;
  v_quantity_to_create   commodity.Quantity%TYPE; -- Quantity for the new child instance

BEGIN
  -- Step 1: Create the new child productInstance
  INSERT INTO productInstance (Product_ID, Date_Manufactured, Is_Recalled)
  VALUES (170.0, TIMESTAMP '2024-11-17 19:57:17', 0)
  RETURNING Instance_ID INTO v_new_child_instance_id;

  -- Step 2: Create the corresponding subtype record
  IF v_child_category = 'Commodity' THEN
    -- Find max existing Batch_Number for this specific Child_PID
    SELECT NVL(MAX(c.Batch_Number), 0) INTO v_max_existing_batch_lot
    FROM commodity c JOIN productInstance pi ON c.Instance_ID = pi.Instance_ID
    WHERE pi.Product_ID = 170.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next batch

    v_expiration_date := TIMESTAMP '2024-11-17 19:57:17' + INTERVAL '92' DAY;
    v_quantity_to_create := ROUND(0.8, 1);

    INSERT INTO commodity (Instance_ID, Batch_Number, Expiration_Date, Quantity)
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Packaged' THEN
    -- Find max existing Lot_Number for this specific Child_PID
    SELECT NVL(MAX(p.Lot_Number), 0) INTO v_max_existing_batch_lot
    FROM packaged p JOIN productInstance pi ON p.Instance_ID = pi.Instance_ID -- Assuming 'packaged' table name
    WHERE pi.Product_ID = 170.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next lot

    v_expiration_date := TIMESTAMP '2024-11-17 19:57:17' + INTERVAL '391' DAY;
    v_quantity_to_create := ROUND(0.8, 1);

    INSERT INTO packaged (Instance_ID, Lot_Number, Expiration_Date, Quantity) -- Assuming 'packaged' table name
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Serialized' THEN
    -- Assign a unique serial number
    -- Using Instance ID guarantees uniqueness within this context
    v_serial_number := 'SN-' || TO_CHAR(170.0) || '-' || TO_CHAR(v_new_child_instance_id) || '-' || SUBSTR(SYS_GUID(),1,8);
    -- Assign a batch number - use Product_ID of the *parent* instance as the batch for simplicity? Or a sequence?
    -- Let's use the Parent_IID itself as a simple batch identifier for this run.
    v_batch_number := 211.0; -- All children created FOR this parent get same batch number

    INSERT INTO serialized (Instance_ID, Serial_Number, Batch_Number)
    VALUES (v_new_child_instance_id, v_serial_number, v_batch_number);

    -- Quantity for usesComponent link for serialized is typically 1
    v_quantity_to_create := 1;

  END IF;

  -- Step 3: Create the usesComponent link
  -- Quantity_Used is the Quantity_Needed from needsComponent (which matches child quantity for non-serialized)
  IF v_child_category IN ('Commodity', 'Packaged', 'Serialized') THEN -- Only insert if subtype was handled
      INSERT INTO usesComponent (Parent_IID, Child_IID, Quantity_Used)
      VALUES (211.0, v_new_child_instance_id, ROUND(0.8, 1)); -- Use rounded quantity needed
  END IF;

EXCEPTION
  WHEN OTHERS THEN
    DBMS_OUTPUT.PUT_LINE('Error processing Parent_IID=' || 211.0 || ', Child_PID=' || 170.0 || ': ' || SQLERRM);
    -- Decide if you want to rollback just this block or let the main exception handler catch it
END;
/
DECLARE
  v_new_child_instance_id productInstance.Instance_ID%TYPE;
  v_child_category        product.Category%TYPE := 'Commodity'; -- Pass category
  v_max_existing_batch_lot NUMBER;
  v_next_batch_lot_num   NUMBER;
  v_serial_number        serialized.Serial_Number%TYPE;
  v_batch_number         serialized.Batch_Number%TYPE; -- Shared batch for serialized children of *this* parent
  v_expiration_date      commodity.Expiration_Date%TYPE;
  v_quantity_to_create   commodity.Quantity%TYPE; -- Quantity for the new child instance

BEGIN
  -- Step 1: Create the new child productInstance
  INSERT INTO productInstance (Product_ID, Date_Manufactured, Is_Recalled)
  VALUES (187.0, TIMESTAMP '2024-11-27 10:40:45', 0)
  RETURNING Instance_ID INTO v_new_child_instance_id;

  -- Step 2: Create the corresponding subtype record
  IF v_child_category = 'Commodity' THEN
    -- Find max existing Batch_Number for this specific Child_PID
    SELECT NVL(MAX(c.Batch_Number), 0) INTO v_max_existing_batch_lot
    FROM commodity c JOIN productInstance pi ON c.Instance_ID = pi.Instance_ID
    WHERE pi.Product_ID = 187.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next batch

    v_expiration_date := TIMESTAMP '2024-11-27 10:40:45' + INTERVAL '452' DAY;
    v_quantity_to_create := ROUND(1.1, 1);

    INSERT INTO commodity (Instance_ID, Batch_Number, Expiration_Date, Quantity)
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Packaged' THEN
    -- Find max existing Lot_Number for this specific Child_PID
    SELECT NVL(MAX(p.Lot_Number), 0) INTO v_max_existing_batch_lot
    FROM packaged p JOIN productInstance pi ON p.Instance_ID = pi.Instance_ID -- Assuming 'packaged' table name
    WHERE pi.Product_ID = 187.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next lot

    v_expiration_date := TIMESTAMP '2024-11-27 10:40:45' + INTERVAL '581' DAY;
    v_quantity_to_create := ROUND(1.1, 1);

    INSERT INTO packaged (Instance_ID, Lot_Number, Expiration_Date, Quantity) -- Assuming 'packaged' table name
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Serialized' THEN
    -- Assign a unique serial number
    -- Using Instance ID guarantees uniqueness within this context
    v_serial_number := 'SN-' || TO_CHAR(187.0) || '-' || TO_CHAR(v_new_child_instance_id) || '-' || SUBSTR(SYS_GUID(),1,8);
    -- Assign a batch number - use Product_ID of the *parent* instance as the batch for simplicity? Or a sequence?
    -- Let's use the Parent_IID itself as a simple batch identifier for this run.
    v_batch_number := 211.0; -- All children created FOR this parent get same batch number

    INSERT INTO serialized (Instance_ID, Serial_Number, Batch_Number)
    VALUES (v_new_child_instance_id, v_serial_number, v_batch_number);

    -- Quantity for usesComponent link for serialized is typically 1
    v_quantity_to_create := 1;

  END IF;

  -- Step 3: Create the usesComponent link
  -- Quantity_Used is the Quantity_Needed from needsComponent (which matches child quantity for non-serialized)
  IF v_child_category IN ('Commodity', 'Packaged', 'Serialized') THEN -- Only insert if subtype was handled
      INSERT INTO usesComponent (Parent_IID, Child_IID, Quantity_Used)
      VALUES (211.0, v_new_child_instance_id, ROUND(1.1, 1)); -- Use rounded quantity needed
  END IF;

EXCEPTION
  WHEN OTHERS THEN
    DBMS_OUTPUT.PUT_LINE('Error processing Parent_IID=' || 211.0 || ', Child_PID=' || 187.0 || ': ' || SQLERRM);
    -- Decide if you want to rollback just this block or let the main exception handler catch it
END;
/
DECLARE
  v_new_child_instance_id productInstance.Instance_ID%TYPE;
  v_child_category        product.Category%TYPE := 'Commodity'; -- Pass category
  v_max_existing_batch_lot NUMBER;
  v_next_batch_lot_num   NUMBER;
  v_serial_number        serialized.Serial_Number%TYPE;
  v_batch_number         serialized.Batch_Number%TYPE; -- Shared batch for serialized children of *this* parent
  v_expiration_date      commodity.Expiration_Date%TYPE;
  v_quantity_to_create   commodity.Quantity%TYPE; -- Quantity for the new child instance

BEGIN
  -- Step 1: Create the new child productInstance
  INSERT INTO productInstance (Product_ID, Date_Manufactured, Is_Recalled)
  VALUES (172.0, TIMESTAMP '2024-07-15 11:12:31', 0)
  RETURNING Instance_ID INTO v_new_child_instance_id;

  -- Step 2: Create the corresponding subtype record
  IF v_child_category = 'Commodity' THEN
    -- Find max existing Batch_Number for this specific Child_PID
    SELECT NVL(MAX(c.Batch_Number), 0) INTO v_max_existing_batch_lot
    FROM commodity c JOIN productInstance pi ON c.Instance_ID = pi.Instance_ID
    WHERE pi.Product_ID = 172.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next batch

    v_expiration_date := TIMESTAMP '2024-07-15 11:12:31' + INTERVAL '579' DAY;
    v_quantity_to_create := ROUND(1.5, 1);

    INSERT INTO commodity (Instance_ID, Batch_Number, Expiration_Date, Quantity)
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Packaged' THEN
    -- Find max existing Lot_Number for this specific Child_PID
    SELECT NVL(MAX(p.Lot_Number), 0) INTO v_max_existing_batch_lot
    FROM packaged p JOIN productInstance pi ON p.Instance_ID = pi.Instance_ID -- Assuming 'packaged' table name
    WHERE pi.Product_ID = 172.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next lot

    v_expiration_date := TIMESTAMP '2024-07-15 11:12:31' + INTERVAL '464' DAY;
    v_quantity_to_create := ROUND(1.5, 1);

    INSERT INTO packaged (Instance_ID, Lot_Number, Expiration_Date, Quantity) -- Assuming 'packaged' table name
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Serialized' THEN
    -- Assign a unique serial number
    -- Using Instance ID guarantees uniqueness within this context
    v_serial_number := 'SN-' || TO_CHAR(172.0) || '-' || TO_CHAR(v_new_child_instance_id) || '-' || SUBSTR(SYS_GUID(),1,8);
    -- Assign a batch number - use Product_ID of the *parent* instance as the batch for simplicity? Or a sequence?
    -- Let's use the Parent_IID itself as a simple batch identifier for this run.
    v_batch_number := 223.0; -- All children created FOR this parent get same batch number

    INSERT INTO serialized (Instance_ID, Serial_Number, Batch_Number)
    VALUES (v_new_child_instance_id, v_serial_number, v_batch_number);

    -- Quantity for usesComponent link for serialized is typically 1
    v_quantity_to_create := 1;

  END IF;

  -- Step 3: Create the usesComponent link
  -- Quantity_Used is the Quantity_Needed from needsComponent (which matches child quantity for non-serialized)
  IF v_child_category IN ('Commodity', 'Packaged', 'Serialized') THEN -- Only insert if subtype was handled
      INSERT INTO usesComponent (Parent_IID, Child_IID, Quantity_Used)
      VALUES (223.0, v_new_child_instance_id, ROUND(1.5, 1)); -- Use rounded quantity needed
  END IF;

EXCEPTION
  WHEN OTHERS THEN
    DBMS_OUTPUT.PUT_LINE('Error processing Parent_IID=' || 223.0 || ', Child_PID=' || 172.0 || ': ' || SQLERRM);
    -- Decide if you want to rollback just this block or let the main exception handler catch it
END;
/
DECLARE
  v_new_child_instance_id productInstance.Instance_ID%TYPE;
  v_child_category        product.Category%TYPE := 'Commodity'; -- Pass category
  v_max_existing_batch_lot NUMBER;
  v_next_batch_lot_num   NUMBER;
  v_serial_number        serialized.Serial_Number%TYPE;
  v_batch_number         serialized.Batch_Number%TYPE; -- Shared batch for serialized children of *this* parent
  v_expiration_date      commodity.Expiration_Date%TYPE;
  v_quantity_to_create   commodity.Quantity%TYPE; -- Quantity for the new child instance

BEGIN
  -- Step 1: Create the new child productInstance
  INSERT INTO productInstance (Product_ID, Date_Manufactured, Is_Recalled)
  VALUES (104.0, TIMESTAMP '2025-04-21 07:14:37', 0)
  RETURNING Instance_ID INTO v_new_child_instance_id;

  -- Step 2: Create the corresponding subtype record
  IF v_child_category = 'Commodity' THEN
    -- Find max existing Batch_Number for this specific Child_PID
    SELECT NVL(MAX(c.Batch_Number), 0) INTO v_max_existing_batch_lot
    FROM commodity c JOIN productInstance pi ON c.Instance_ID = pi.Instance_ID
    WHERE pi.Product_ID = 104.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next batch

    v_expiration_date := TIMESTAMP '2025-04-21 07:14:37' + INTERVAL '708' DAY;
    v_quantity_to_create := ROUND(0.9, 1);

    INSERT INTO commodity (Instance_ID, Batch_Number, Expiration_Date, Quantity)
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Packaged' THEN
    -- Find max existing Lot_Number for this specific Child_PID
    SELECT NVL(MAX(p.Lot_Number), 0) INTO v_max_existing_batch_lot
    FROM packaged p JOIN productInstance pi ON p.Instance_ID = pi.Instance_ID -- Assuming 'packaged' table name
    WHERE pi.Product_ID = 104.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next lot

    v_expiration_date := TIMESTAMP '2025-04-21 07:14:37' + INTERVAL '101' DAY;
    v_quantity_to_create := ROUND(0.9, 1);

    INSERT INTO packaged (Instance_ID, Lot_Number, Expiration_Date, Quantity) -- Assuming 'packaged' table name
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Serialized' THEN
    -- Assign a unique serial number
    -- Using Instance ID guarantees uniqueness within this context
    v_serial_number := 'SN-' || TO_CHAR(104.0) || '-' || TO_CHAR(v_new_child_instance_id) || '-' || SUBSTR(SYS_GUID(),1,8);
    -- Assign a batch number - use Product_ID of the *parent* instance as the batch for simplicity? Or a sequence?
    -- Let's use the Parent_IID itself as a simple batch identifier for this run.
    v_batch_number := 223.0; -- All children created FOR this parent get same batch number

    INSERT INTO serialized (Instance_ID, Serial_Number, Batch_Number)
    VALUES (v_new_child_instance_id, v_serial_number, v_batch_number);

    -- Quantity for usesComponent link for serialized is typically 1
    v_quantity_to_create := 1;

  END IF;

  -- Step 3: Create the usesComponent link
  -- Quantity_Used is the Quantity_Needed from needsComponent (which matches child quantity for non-serialized)
  IF v_child_category IN ('Commodity', 'Packaged', 'Serialized') THEN -- Only insert if subtype was handled
      INSERT INTO usesComponent (Parent_IID, Child_IID, Quantity_Used)
      VALUES (223.0, v_new_child_instance_id, ROUND(0.9, 1)); -- Use rounded quantity needed
  END IF;

EXCEPTION
  WHEN OTHERS THEN
    DBMS_OUTPUT.PUT_LINE('Error processing Parent_IID=' || 223.0 || ', Child_PID=' || 104.0 || ': ' || SQLERRM);
    -- Decide if you want to rollback just this block or let the main exception handler catch it
END;
/
DECLARE
  v_new_child_instance_id productInstance.Instance_ID%TYPE;
  v_child_category        product.Category%TYPE := 'Commodity'; -- Pass category
  v_max_existing_batch_lot NUMBER;
  v_next_batch_lot_num   NUMBER;
  v_serial_number        serialized.Serial_Number%TYPE;
  v_batch_number         serialized.Batch_Number%TYPE; -- Shared batch for serialized children of *this* parent
  v_expiration_date      commodity.Expiration_Date%TYPE;
  v_quantity_to_create   commodity.Quantity%TYPE; -- Quantity for the new child instance

BEGIN
  -- Step 1: Create the new child productInstance
  INSERT INTO productInstance (Product_ID, Date_Manufactured, Is_Recalled)
  VALUES (172.0, TIMESTAMP '2025-01-31 03:41:45', 0)
  RETURNING Instance_ID INTO v_new_child_instance_id;

  -- Step 2: Create the corresponding subtype record
  IF v_child_category = 'Commodity' THEN
    -- Find max existing Batch_Number for this specific Child_PID
    SELECT NVL(MAX(c.Batch_Number), 0) INTO v_max_existing_batch_lot
    FROM commodity c JOIN productInstance pi ON c.Instance_ID = pi.Instance_ID
    WHERE pi.Product_ID = 172.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next batch

    v_expiration_date := TIMESTAMP '2025-01-31 03:41:45' + INTERVAL '303' DAY;
    v_quantity_to_create := ROUND(1.5, 1);

    INSERT INTO commodity (Instance_ID, Batch_Number, Expiration_Date, Quantity)
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Packaged' THEN
    -- Find max existing Lot_Number for this specific Child_PID
    SELECT NVL(MAX(p.Lot_Number), 0) INTO v_max_existing_batch_lot
    FROM packaged p JOIN productInstance pi ON p.Instance_ID = pi.Instance_ID -- Assuming 'packaged' table name
    WHERE pi.Product_ID = 172.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next lot

    v_expiration_date := TIMESTAMP '2025-01-31 03:41:45' + INTERVAL '655' DAY;
    v_quantity_to_create := ROUND(1.5, 1);

    INSERT INTO packaged (Instance_ID, Lot_Number, Expiration_Date, Quantity) -- Assuming 'packaged' table name
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Serialized' THEN
    -- Assign a unique serial number
    -- Using Instance ID guarantees uniqueness within this context
    v_serial_number := 'SN-' || TO_CHAR(172.0) || '-' || TO_CHAR(v_new_child_instance_id) || '-' || SUBSTR(SYS_GUID(),1,8);
    -- Assign a batch number - use Product_ID of the *parent* instance as the batch for simplicity? Or a sequence?
    -- Let's use the Parent_IID itself as a simple batch identifier for this run.
    v_batch_number := 224.0; -- All children created FOR this parent get same batch number

    INSERT INTO serialized (Instance_ID, Serial_Number, Batch_Number)
    VALUES (v_new_child_instance_id, v_serial_number, v_batch_number);

    -- Quantity for usesComponent link for serialized is typically 1
    v_quantity_to_create := 1;

  END IF;

  -- Step 3: Create the usesComponent link
  -- Quantity_Used is the Quantity_Needed from needsComponent (which matches child quantity for non-serialized)
  IF v_child_category IN ('Commodity', 'Packaged', 'Serialized') THEN -- Only insert if subtype was handled
      INSERT INTO usesComponent (Parent_IID, Child_IID, Quantity_Used)
      VALUES (224.0, v_new_child_instance_id, ROUND(1.5, 1)); -- Use rounded quantity needed
  END IF;

EXCEPTION
  WHEN OTHERS THEN
    DBMS_OUTPUT.PUT_LINE('Error processing Parent_IID=' || 224.0 || ', Child_PID=' || 172.0 || ': ' || SQLERRM);
    -- Decide if you want to rollback just this block or let the main exception handler catch it
END;
/
DECLARE
  v_new_child_instance_id productInstance.Instance_ID%TYPE;
  v_child_category        product.Category%TYPE := 'Commodity'; -- Pass category
  v_max_existing_batch_lot NUMBER;
  v_next_batch_lot_num   NUMBER;
  v_serial_number        serialized.Serial_Number%TYPE;
  v_batch_number         serialized.Batch_Number%TYPE; -- Shared batch for serialized children of *this* parent
  v_expiration_date      commodity.Expiration_Date%TYPE;
  v_quantity_to_create   commodity.Quantity%TYPE; -- Quantity for the new child instance

BEGIN
  -- Step 1: Create the new child productInstance
  INSERT INTO productInstance (Product_ID, Date_Manufactured, Is_Recalled)
  VALUES (104.0, TIMESTAMP '2025-02-03 02:14:33', 0)
  RETURNING Instance_ID INTO v_new_child_instance_id;

  -- Step 2: Create the corresponding subtype record
  IF v_child_category = 'Commodity' THEN
    -- Find max existing Batch_Number for this specific Child_PID
    SELECT NVL(MAX(c.Batch_Number), 0) INTO v_max_existing_batch_lot
    FROM commodity c JOIN productInstance pi ON c.Instance_ID = pi.Instance_ID
    WHERE pi.Product_ID = 104.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next batch

    v_expiration_date := TIMESTAMP '2025-02-03 02:14:33' + INTERVAL '104' DAY;
    v_quantity_to_create := ROUND(0.9, 1);

    INSERT INTO commodity (Instance_ID, Batch_Number, Expiration_Date, Quantity)
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Packaged' THEN
    -- Find max existing Lot_Number for this specific Child_PID
    SELECT NVL(MAX(p.Lot_Number), 0) INTO v_max_existing_batch_lot
    FROM packaged p JOIN productInstance pi ON p.Instance_ID = pi.Instance_ID -- Assuming 'packaged' table name
    WHERE pi.Product_ID = 104.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next lot

    v_expiration_date := TIMESTAMP '2025-02-03 02:14:33' + INTERVAL '287' DAY;
    v_quantity_to_create := ROUND(0.9, 1);

    INSERT INTO packaged (Instance_ID, Lot_Number, Expiration_Date, Quantity) -- Assuming 'packaged' table name
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Serialized' THEN
    -- Assign a unique serial number
    -- Using Instance ID guarantees uniqueness within this context
    v_serial_number := 'SN-' || TO_CHAR(104.0) || '-' || TO_CHAR(v_new_child_instance_id) || '-' || SUBSTR(SYS_GUID(),1,8);
    -- Assign a batch number - use Product_ID of the *parent* instance as the batch for simplicity? Or a sequence?
    -- Let's use the Parent_IID itself as a simple batch identifier for this run.
    v_batch_number := 224.0; -- All children created FOR this parent get same batch number

    INSERT INTO serialized (Instance_ID, Serial_Number, Batch_Number)
    VALUES (v_new_child_instance_id, v_serial_number, v_batch_number);

    -- Quantity for usesComponent link for serialized is typically 1
    v_quantity_to_create := 1;

  END IF;

  -- Step 3: Create the usesComponent link
  -- Quantity_Used is the Quantity_Needed from needsComponent (which matches child quantity for non-serialized)
  IF v_child_category IN ('Commodity', 'Packaged', 'Serialized') THEN -- Only insert if subtype was handled
      INSERT INTO usesComponent (Parent_IID, Child_IID, Quantity_Used)
      VALUES (224.0, v_new_child_instance_id, ROUND(0.9, 1)); -- Use rounded quantity needed
  END IF;

EXCEPTION
  WHEN OTHERS THEN
    DBMS_OUTPUT.PUT_LINE('Error processing Parent_IID=' || 224.0 || ', Child_PID=' || 104.0 || ': ' || SQLERRM);
    -- Decide if you want to rollback just this block or let the main exception handler catch it
END;
/
DECLARE
  v_new_child_instance_id productInstance.Instance_ID%TYPE;
  v_child_category        product.Category%TYPE := 'Commodity'; -- Pass category
  v_max_existing_batch_lot NUMBER;
  v_next_batch_lot_num   NUMBER;
  v_serial_number        serialized.Serial_Number%TYPE;
  v_batch_number         serialized.Batch_Number%TYPE; -- Shared batch for serialized children of *this* parent
  v_expiration_date      commodity.Expiration_Date%TYPE;
  v_quantity_to_create   commodity.Quantity%TYPE; -- Quantity for the new child instance

BEGIN
  -- Step 1: Create the new child productInstance
  INSERT INTO productInstance (Product_ID, Date_Manufactured, Is_Recalled)
  VALUES (172.0, TIMESTAMP '2024-07-07 00:06:44', 0)
  RETURNING Instance_ID INTO v_new_child_instance_id;

  -- Step 2: Create the corresponding subtype record
  IF v_child_category = 'Commodity' THEN
    -- Find max existing Batch_Number for this specific Child_PID
    SELECT NVL(MAX(c.Batch_Number), 0) INTO v_max_existing_batch_lot
    FROM commodity c JOIN productInstance pi ON c.Instance_ID = pi.Instance_ID
    WHERE pi.Product_ID = 172.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next batch

    v_expiration_date := TIMESTAMP '2024-07-07 00:06:44' + INTERVAL '128' DAY;
    v_quantity_to_create := ROUND(1.5, 1);

    INSERT INTO commodity (Instance_ID, Batch_Number, Expiration_Date, Quantity)
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Packaged' THEN
    -- Find max existing Lot_Number for this specific Child_PID
    SELECT NVL(MAX(p.Lot_Number), 0) INTO v_max_existing_batch_lot
    FROM packaged p JOIN productInstance pi ON p.Instance_ID = pi.Instance_ID -- Assuming 'packaged' table name
    WHERE pi.Product_ID = 172.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next lot

    v_expiration_date := TIMESTAMP '2024-07-07 00:06:44' + INTERVAL '184' DAY;
    v_quantity_to_create := ROUND(1.5, 1);

    INSERT INTO packaged (Instance_ID, Lot_Number, Expiration_Date, Quantity) -- Assuming 'packaged' table name
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Serialized' THEN
    -- Assign a unique serial number
    -- Using Instance ID guarantees uniqueness within this context
    v_serial_number := 'SN-' || TO_CHAR(172.0) || '-' || TO_CHAR(v_new_child_instance_id) || '-' || SUBSTR(SYS_GUID(),1,8);
    -- Assign a batch number - use Product_ID of the *parent* instance as the batch for simplicity? Or a sequence?
    -- Let's use the Parent_IID itself as a simple batch identifier for this run.
    v_batch_number := 225.0; -- All children created FOR this parent get same batch number

    INSERT INTO serialized (Instance_ID, Serial_Number, Batch_Number)
    VALUES (v_new_child_instance_id, v_serial_number, v_batch_number);

    -- Quantity for usesComponent link for serialized is typically 1
    v_quantity_to_create := 1;

  END IF;

  -- Step 3: Create the usesComponent link
  -- Quantity_Used is the Quantity_Needed from needsComponent (which matches child quantity for non-serialized)
  IF v_child_category IN ('Commodity', 'Packaged', 'Serialized') THEN -- Only insert if subtype was handled
      INSERT INTO usesComponent (Parent_IID, Child_IID, Quantity_Used)
      VALUES (225.0, v_new_child_instance_id, ROUND(1.5, 1)); -- Use rounded quantity needed
  END IF;

EXCEPTION
  WHEN OTHERS THEN
    DBMS_OUTPUT.PUT_LINE('Error processing Parent_IID=' || 225.0 || ', Child_PID=' || 172.0 || ': ' || SQLERRM);
    -- Decide if you want to rollback just this block or let the main exception handler catch it
END;
/
DECLARE
  v_new_child_instance_id productInstance.Instance_ID%TYPE;
  v_child_category        product.Category%TYPE := 'Commodity'; -- Pass category
  v_max_existing_batch_lot NUMBER;
  v_next_batch_lot_num   NUMBER;
  v_serial_number        serialized.Serial_Number%TYPE;
  v_batch_number         serialized.Batch_Number%TYPE; -- Shared batch for serialized children of *this* parent
  v_expiration_date      commodity.Expiration_Date%TYPE;
  v_quantity_to_create   commodity.Quantity%TYPE; -- Quantity for the new child instance

BEGIN
  -- Step 1: Create the new child productInstance
  INSERT INTO productInstance (Product_ID, Date_Manufactured, Is_Recalled)
  VALUES (104.0, TIMESTAMP '2024-05-21 20:10:10', 0)
  RETURNING Instance_ID INTO v_new_child_instance_id;

  -- Step 2: Create the corresponding subtype record
  IF v_child_category = 'Commodity' THEN
    -- Find max existing Batch_Number for this specific Child_PID
    SELECT NVL(MAX(c.Batch_Number), 0) INTO v_max_existing_batch_lot
    FROM commodity c JOIN productInstance pi ON c.Instance_ID = pi.Instance_ID
    WHERE pi.Product_ID = 104.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next batch

    v_expiration_date := TIMESTAMP '2024-05-21 20:10:10' + INTERVAL '238' DAY;
    v_quantity_to_create := ROUND(0.9, 1);

    INSERT INTO commodity (Instance_ID, Batch_Number, Expiration_Date, Quantity)
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Packaged' THEN
    -- Find max existing Lot_Number for this specific Child_PID
    SELECT NVL(MAX(p.Lot_Number), 0) INTO v_max_existing_batch_lot
    FROM packaged p JOIN productInstance pi ON p.Instance_ID = pi.Instance_ID -- Assuming 'packaged' table name
    WHERE pi.Product_ID = 104.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next lot

    v_expiration_date := TIMESTAMP '2024-05-21 20:10:10' + INTERVAL '468' DAY;
    v_quantity_to_create := ROUND(0.9, 1);

    INSERT INTO packaged (Instance_ID, Lot_Number, Expiration_Date, Quantity) -- Assuming 'packaged' table name
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Serialized' THEN
    -- Assign a unique serial number
    -- Using Instance ID guarantees uniqueness within this context
    v_serial_number := 'SN-' || TO_CHAR(104.0) || '-' || TO_CHAR(v_new_child_instance_id) || '-' || SUBSTR(SYS_GUID(),1,8);
    -- Assign a batch number - use Product_ID of the *parent* instance as the batch for simplicity? Or a sequence?
    -- Let's use the Parent_IID itself as a simple batch identifier for this run.
    v_batch_number := 225.0; -- All children created FOR this parent get same batch number

    INSERT INTO serialized (Instance_ID, Serial_Number, Batch_Number)
    VALUES (v_new_child_instance_id, v_serial_number, v_batch_number);

    -- Quantity for usesComponent link for serialized is typically 1
    v_quantity_to_create := 1;

  END IF;

  -- Step 3: Create the usesComponent link
  -- Quantity_Used is the Quantity_Needed from needsComponent (which matches child quantity for non-serialized)
  IF v_child_category IN ('Commodity', 'Packaged', 'Serialized') THEN -- Only insert if subtype was handled
      INSERT INTO usesComponent (Parent_IID, Child_IID, Quantity_Used)
      VALUES (225.0, v_new_child_instance_id, ROUND(0.9, 1)); -- Use rounded quantity needed
  END IF;

EXCEPTION
  WHEN OTHERS THEN
    DBMS_OUTPUT.PUT_LINE('Error processing Parent_IID=' || 225.0 || ', Child_PID=' || 104.0 || ': ' || SQLERRM);
    -- Decide if you want to rollback just this block or let the main exception handler catch it
END;
/
DECLARE
  v_new_child_instance_id productInstance.Instance_ID%TYPE;
  v_child_category        product.Category%TYPE := 'Commodity'; -- Pass category
  v_max_existing_batch_lot NUMBER;
  v_next_batch_lot_num   NUMBER;
  v_serial_number        serialized.Serial_Number%TYPE;
  v_batch_number         serialized.Batch_Number%TYPE; -- Shared batch for serialized children of *this* parent
  v_expiration_date      commodity.Expiration_Date%TYPE;
  v_quantity_to_create   commodity.Quantity%TYPE; -- Quantity for the new child instance

BEGIN
  -- Step 1: Create the new child productInstance
  INSERT INTO productInstance (Product_ID, Date_Manufactured, Is_Recalled)
  VALUES (172.0, TIMESTAMP '2025-03-25 23:42:28', 0)
  RETURNING Instance_ID INTO v_new_child_instance_id;

  -- Step 2: Create the corresponding subtype record
  IF v_child_category = 'Commodity' THEN
    -- Find max existing Batch_Number for this specific Child_PID
    SELECT NVL(MAX(c.Batch_Number), 0) INTO v_max_existing_batch_lot
    FROM commodity c JOIN productInstance pi ON c.Instance_ID = pi.Instance_ID
    WHERE pi.Product_ID = 172.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next batch

    v_expiration_date := TIMESTAMP '2025-03-25 23:42:28' + INTERVAL '75' DAY;
    v_quantity_to_create := ROUND(1.5, 1);

    INSERT INTO commodity (Instance_ID, Batch_Number, Expiration_Date, Quantity)
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Packaged' THEN
    -- Find max existing Lot_Number for this specific Child_PID
    SELECT NVL(MAX(p.Lot_Number), 0) INTO v_max_existing_batch_lot
    FROM packaged p JOIN productInstance pi ON p.Instance_ID = pi.Instance_ID -- Assuming 'packaged' table name
    WHERE pi.Product_ID = 172.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next lot

    v_expiration_date := TIMESTAMP '2025-03-25 23:42:28' + INTERVAL '84' DAY;
    v_quantity_to_create := ROUND(1.5, 1);

    INSERT INTO packaged (Instance_ID, Lot_Number, Expiration_Date, Quantity) -- Assuming 'packaged' table name
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Serialized' THEN
    -- Assign a unique serial number
    -- Using Instance ID guarantees uniqueness within this context
    v_serial_number := 'SN-' || TO_CHAR(172.0) || '-' || TO_CHAR(v_new_child_instance_id) || '-' || SUBSTR(SYS_GUID(),1,8);
    -- Assign a batch number - use Product_ID of the *parent* instance as the batch for simplicity? Or a sequence?
    -- Let's use the Parent_IID itself as a simple batch identifier for this run.
    v_batch_number := 226.0; -- All children created FOR this parent get same batch number

    INSERT INTO serialized (Instance_ID, Serial_Number, Batch_Number)
    VALUES (v_new_child_instance_id, v_serial_number, v_batch_number);

    -- Quantity for usesComponent link for serialized is typically 1
    v_quantity_to_create := 1;

  END IF;

  -- Step 3: Create the usesComponent link
  -- Quantity_Used is the Quantity_Needed from needsComponent (which matches child quantity for non-serialized)
  IF v_child_category IN ('Commodity', 'Packaged', 'Serialized') THEN -- Only insert if subtype was handled
      INSERT INTO usesComponent (Parent_IID, Child_IID, Quantity_Used)
      VALUES (226.0, v_new_child_instance_id, ROUND(1.5, 1)); -- Use rounded quantity needed
  END IF;

EXCEPTION
  WHEN OTHERS THEN
    DBMS_OUTPUT.PUT_LINE('Error processing Parent_IID=' || 226.0 || ', Child_PID=' || 172.0 || ': ' || SQLERRM);
    -- Decide if you want to rollback just this block or let the main exception handler catch it
END;
/
DECLARE
  v_new_child_instance_id productInstance.Instance_ID%TYPE;
  v_child_category        product.Category%TYPE := 'Commodity'; -- Pass category
  v_max_existing_batch_lot NUMBER;
  v_next_batch_lot_num   NUMBER;
  v_serial_number        serialized.Serial_Number%TYPE;
  v_batch_number         serialized.Batch_Number%TYPE; -- Shared batch for serialized children of *this* parent
  v_expiration_date      commodity.Expiration_Date%TYPE;
  v_quantity_to_create   commodity.Quantity%TYPE; -- Quantity for the new child instance

BEGIN
  -- Step 1: Create the new child productInstance
  INSERT INTO productInstance (Product_ID, Date_Manufactured, Is_Recalled)
  VALUES (104.0, TIMESTAMP '2025-01-01 11:22:34', 0)
  RETURNING Instance_ID INTO v_new_child_instance_id;

  -- Step 2: Create the corresponding subtype record
  IF v_child_category = 'Commodity' THEN
    -- Find max existing Batch_Number for this specific Child_PID
    SELECT NVL(MAX(c.Batch_Number), 0) INTO v_max_existing_batch_lot
    FROM commodity c JOIN productInstance pi ON c.Instance_ID = pi.Instance_ID
    WHERE pi.Product_ID = 104.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next batch

    v_expiration_date := TIMESTAMP '2025-01-01 11:22:34' + INTERVAL '123' DAY;
    v_quantity_to_create := ROUND(0.9, 1);

    INSERT INTO commodity (Instance_ID, Batch_Number, Expiration_Date, Quantity)
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Packaged' THEN
    -- Find max existing Lot_Number for this specific Child_PID
    SELECT NVL(MAX(p.Lot_Number), 0) INTO v_max_existing_batch_lot
    FROM packaged p JOIN productInstance pi ON p.Instance_ID = pi.Instance_ID -- Assuming 'packaged' table name
    WHERE pi.Product_ID = 104.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next lot

    v_expiration_date := TIMESTAMP '2025-01-01 11:22:34' + INTERVAL '555' DAY;
    v_quantity_to_create := ROUND(0.9, 1);

    INSERT INTO packaged (Instance_ID, Lot_Number, Expiration_Date, Quantity) -- Assuming 'packaged' table name
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Serialized' THEN
    -- Assign a unique serial number
    -- Using Instance ID guarantees uniqueness within this context
    v_serial_number := 'SN-' || TO_CHAR(104.0) || '-' || TO_CHAR(v_new_child_instance_id) || '-' || SUBSTR(SYS_GUID(),1,8);
    -- Assign a batch number - use Product_ID of the *parent* instance as the batch for simplicity? Or a sequence?
    -- Let's use the Parent_IID itself as a simple batch identifier for this run.
    v_batch_number := 226.0; -- All children created FOR this parent get same batch number

    INSERT INTO serialized (Instance_ID, Serial_Number, Batch_Number)
    VALUES (v_new_child_instance_id, v_serial_number, v_batch_number);

    -- Quantity for usesComponent link for serialized is typically 1
    v_quantity_to_create := 1;

  END IF;

  -- Step 3: Create the usesComponent link
  -- Quantity_Used is the Quantity_Needed from needsComponent (which matches child quantity for non-serialized)
  IF v_child_category IN ('Commodity', 'Packaged', 'Serialized') THEN -- Only insert if subtype was handled
      INSERT INTO usesComponent (Parent_IID, Child_IID, Quantity_Used)
      VALUES (226.0, v_new_child_instance_id, ROUND(0.9, 1)); -- Use rounded quantity needed
  END IF;

EXCEPTION
  WHEN OTHERS THEN
    DBMS_OUTPUT.PUT_LINE('Error processing Parent_IID=' || 226.0 || ', Child_PID=' || 104.0 || ': ' || SQLERRM);
    -- Decide if you want to rollback just this block or let the main exception handler catch it
END;
/
DECLARE
  v_new_child_instance_id productInstance.Instance_ID%TYPE;
  v_child_category        product.Category%TYPE := 'Commodity'; -- Pass category
  v_max_existing_batch_lot NUMBER;
  v_next_batch_lot_num   NUMBER;
  v_serial_number        serialized.Serial_Number%TYPE;
  v_batch_number         serialized.Batch_Number%TYPE; -- Shared batch for serialized children of *this* parent
  v_expiration_date      commodity.Expiration_Date%TYPE;
  v_quantity_to_create   commodity.Quantity%TYPE; -- Quantity for the new child instance

BEGIN
  -- Step 1: Create the new child productInstance
  INSERT INTO productInstance (Product_ID, Date_Manufactured, Is_Recalled)
  VALUES (161.0, TIMESTAMP '2024-10-28 05:54:46', 0)
  RETURNING Instance_ID INTO v_new_child_instance_id;

  -- Step 2: Create the corresponding subtype record
  IF v_child_category = 'Commodity' THEN
    -- Find max existing Batch_Number for this specific Child_PID
    SELECT NVL(MAX(c.Batch_Number), 0) INTO v_max_existing_batch_lot
    FROM commodity c JOIN productInstance pi ON c.Instance_ID = pi.Instance_ID
    WHERE pi.Product_ID = 161.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next batch

    v_expiration_date := TIMESTAMP '2024-10-28 05:54:46' + INTERVAL '543' DAY;
    v_quantity_to_create := ROUND(0.5, 1);

    INSERT INTO commodity (Instance_ID, Batch_Number, Expiration_Date, Quantity)
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Packaged' THEN
    -- Find max existing Lot_Number for this specific Child_PID
    SELECT NVL(MAX(p.Lot_Number), 0) INTO v_max_existing_batch_lot
    FROM packaged p JOIN productInstance pi ON p.Instance_ID = pi.Instance_ID -- Assuming 'packaged' table name
    WHERE pi.Product_ID = 161.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next lot

    v_expiration_date := TIMESTAMP '2024-10-28 05:54:46' + INTERVAL '409' DAY;
    v_quantity_to_create := ROUND(0.5, 1);

    INSERT INTO packaged (Instance_ID, Lot_Number, Expiration_Date, Quantity) -- Assuming 'packaged' table name
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Serialized' THEN
    -- Assign a unique serial number
    -- Using Instance ID guarantees uniqueness within this context
    v_serial_number := 'SN-' || TO_CHAR(161.0) || '-' || TO_CHAR(v_new_child_instance_id) || '-' || SUBSTR(SYS_GUID(),1,8);
    -- Assign a batch number - use Product_ID of the *parent* instance as the batch for simplicity? Or a sequence?
    -- Let's use the Parent_IID itself as a simple batch identifier for this run.
    v_batch_number := 234.0; -- All children created FOR this parent get same batch number

    INSERT INTO serialized (Instance_ID, Serial_Number, Batch_Number)
    VALUES (v_new_child_instance_id, v_serial_number, v_batch_number);

    -- Quantity for usesComponent link for serialized is typically 1
    v_quantity_to_create := 1;

  END IF;

  -- Step 3: Create the usesComponent link
  -- Quantity_Used is the Quantity_Needed from needsComponent (which matches child quantity for non-serialized)
  IF v_child_category IN ('Commodity', 'Packaged', 'Serialized') THEN -- Only insert if subtype was handled
      INSERT INTO usesComponent (Parent_IID, Child_IID, Quantity_Used)
      VALUES (234.0, v_new_child_instance_id, ROUND(0.5, 1)); -- Use rounded quantity needed
  END IF;

EXCEPTION
  WHEN OTHERS THEN
    DBMS_OUTPUT.PUT_LINE('Error processing Parent_IID=' || 234.0 || ', Child_PID=' || 161.0 || ': ' || SQLERRM);
    -- Decide if you want to rollback just this block or let the main exception handler catch it
END;
/
DECLARE
  v_new_child_instance_id productInstance.Instance_ID%TYPE;
  v_child_category        product.Category%TYPE := 'Commodity'; -- Pass category
  v_max_existing_batch_lot NUMBER;
  v_next_batch_lot_num   NUMBER;
  v_serial_number        serialized.Serial_Number%TYPE;
  v_batch_number         serialized.Batch_Number%TYPE; -- Shared batch for serialized children of *this* parent
  v_expiration_date      commodity.Expiration_Date%TYPE;
  v_quantity_to_create   commodity.Quantity%TYPE; -- Quantity for the new child instance

BEGIN
  -- Step 1: Create the new child productInstance
  INSERT INTO productInstance (Product_ID, Date_Manufactured, Is_Recalled)
  VALUES (133.0, TIMESTAMP '2024-06-06 14:20:15', 0)
  RETURNING Instance_ID INTO v_new_child_instance_id;

  -- Step 2: Create the corresponding subtype record
  IF v_child_category = 'Commodity' THEN
    -- Find max existing Batch_Number for this specific Child_PID
    SELECT NVL(MAX(c.Batch_Number), 0) INTO v_max_existing_batch_lot
    FROM commodity c JOIN productInstance pi ON c.Instance_ID = pi.Instance_ID
    WHERE pi.Product_ID = 133.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next batch

    v_expiration_date := TIMESTAMP '2024-06-06 14:20:15' + INTERVAL '350' DAY;
    v_quantity_to_create := ROUND(1.2, 1);

    INSERT INTO commodity (Instance_ID, Batch_Number, Expiration_Date, Quantity)
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Packaged' THEN
    -- Find max existing Lot_Number for this specific Child_PID
    SELECT NVL(MAX(p.Lot_Number), 0) INTO v_max_existing_batch_lot
    FROM packaged p JOIN productInstance pi ON p.Instance_ID = pi.Instance_ID -- Assuming 'packaged' table name
    WHERE pi.Product_ID = 133.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next lot

    v_expiration_date := TIMESTAMP '2024-06-06 14:20:15' + INTERVAL '71' DAY;
    v_quantity_to_create := ROUND(1.2, 1);

    INSERT INTO packaged (Instance_ID, Lot_Number, Expiration_Date, Quantity) -- Assuming 'packaged' table name
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Serialized' THEN
    -- Assign a unique serial number
    -- Using Instance ID guarantees uniqueness within this context
    v_serial_number := 'SN-' || TO_CHAR(133.0) || '-' || TO_CHAR(v_new_child_instance_id) || '-' || SUBSTR(SYS_GUID(),1,8);
    -- Assign a batch number - use Product_ID of the *parent* instance as the batch for simplicity? Or a sequence?
    -- Let's use the Parent_IID itself as a simple batch identifier for this run.
    v_batch_number := 270.0; -- All children created FOR this parent get same batch number

    INSERT INTO serialized (Instance_ID, Serial_Number, Batch_Number)
    VALUES (v_new_child_instance_id, v_serial_number, v_batch_number);

    -- Quantity for usesComponent link for serialized is typically 1
    v_quantity_to_create := 1;

  END IF;

  -- Step 3: Create the usesComponent link
  -- Quantity_Used is the Quantity_Needed from needsComponent (which matches child quantity for non-serialized)
  IF v_child_category IN ('Commodity', 'Packaged', 'Serialized') THEN -- Only insert if subtype was handled
      INSERT INTO usesComponent (Parent_IID, Child_IID, Quantity_Used)
      VALUES (270.0, v_new_child_instance_id, ROUND(1.2, 1)); -- Use rounded quantity needed
  END IF;

EXCEPTION
  WHEN OTHERS THEN
    DBMS_OUTPUT.PUT_LINE('Error processing Parent_IID=' || 270.0 || ', Child_PID=' || 133.0 || ': ' || SQLERRM);
    -- Decide if you want to rollback just this block or let the main exception handler catch it
END;
/
DECLARE
  v_new_child_instance_id productInstance.Instance_ID%TYPE;
  v_child_category        product.Category%TYPE := 'Commodity'; -- Pass category
  v_max_existing_batch_lot NUMBER;
  v_next_batch_lot_num   NUMBER;
  v_serial_number        serialized.Serial_Number%TYPE;
  v_batch_number         serialized.Batch_Number%TYPE; -- Shared batch for serialized children of *this* parent
  v_expiration_date      commodity.Expiration_Date%TYPE;
  v_quantity_to_create   commodity.Quantity%TYPE; -- Quantity for the new child instance

BEGIN
  -- Step 1: Create the new child productInstance
  INSERT INTO productInstance (Product_ID, Date_Manufactured, Is_Recalled)
  VALUES (133.0, TIMESTAMP '2024-06-17 05:12:20', 0)
  RETURNING Instance_ID INTO v_new_child_instance_id;

  -- Step 2: Create the corresponding subtype record
  IF v_child_category = 'Commodity' THEN
    -- Find max existing Batch_Number for this specific Child_PID
    SELECT NVL(MAX(c.Batch_Number), 0) INTO v_max_existing_batch_lot
    FROM commodity c JOIN productInstance pi ON c.Instance_ID = pi.Instance_ID
    WHERE pi.Product_ID = 133.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next batch

    v_expiration_date := TIMESTAMP '2024-06-17 05:12:20' + INTERVAL '574' DAY;
    v_quantity_to_create := ROUND(1.2, 1);

    INSERT INTO commodity (Instance_ID, Batch_Number, Expiration_Date, Quantity)
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Packaged' THEN
    -- Find max existing Lot_Number for this specific Child_PID
    SELECT NVL(MAX(p.Lot_Number), 0) INTO v_max_existing_batch_lot
    FROM packaged p JOIN productInstance pi ON p.Instance_ID = pi.Instance_ID -- Assuming 'packaged' table name
    WHERE pi.Product_ID = 133.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next lot

    v_expiration_date := TIMESTAMP '2024-06-17 05:12:20' + INTERVAL '63' DAY;
    v_quantity_to_create := ROUND(1.2, 1);

    INSERT INTO packaged (Instance_ID, Lot_Number, Expiration_Date, Quantity) -- Assuming 'packaged' table name
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Serialized' THEN
    -- Assign a unique serial number
    -- Using Instance ID guarantees uniqueness within this context
    v_serial_number := 'SN-' || TO_CHAR(133.0) || '-' || TO_CHAR(v_new_child_instance_id) || '-' || SUBSTR(SYS_GUID(),1,8);
    -- Assign a batch number - use Product_ID of the *parent* instance as the batch for simplicity? Or a sequence?
    -- Let's use the Parent_IID itself as a simple batch identifier for this run.
    v_batch_number := 271.0; -- All children created FOR this parent get same batch number

    INSERT INTO serialized (Instance_ID, Serial_Number, Batch_Number)
    VALUES (v_new_child_instance_id, v_serial_number, v_batch_number);

    -- Quantity for usesComponent link for serialized is typically 1
    v_quantity_to_create := 1;

  END IF;

  -- Step 3: Create the usesComponent link
  -- Quantity_Used is the Quantity_Needed from needsComponent (which matches child quantity for non-serialized)
  IF v_child_category IN ('Commodity', 'Packaged', 'Serialized') THEN -- Only insert if subtype was handled
      INSERT INTO usesComponent (Parent_IID, Child_IID, Quantity_Used)
      VALUES (271.0, v_new_child_instance_id, ROUND(1.2, 1)); -- Use rounded quantity needed
  END IF;

EXCEPTION
  WHEN OTHERS THEN
    DBMS_OUTPUT.PUT_LINE('Error processing Parent_IID=' || 271.0 || ', Child_PID=' || 133.0 || ': ' || SQLERRM);
    -- Decide if you want to rollback just this block or let the main exception handler catch it
END;
/
DECLARE
  v_new_child_instance_id productInstance.Instance_ID%TYPE;
  v_child_category        product.Category%TYPE := 'Commodity'; -- Pass category
  v_max_existing_batch_lot NUMBER;
  v_next_batch_lot_num   NUMBER;
  v_serial_number        serialized.Serial_Number%TYPE;
  v_batch_number         serialized.Batch_Number%TYPE; -- Shared batch for serialized children of *this* parent
  v_expiration_date      commodity.Expiration_Date%TYPE;
  v_quantity_to_create   commodity.Quantity%TYPE; -- Quantity for the new child instance

BEGIN
  -- Step 1: Create the new child productInstance
  INSERT INTO productInstance (Product_ID, Date_Manufactured, Is_Recalled)
  VALUES (133.0, TIMESTAMP '2024-10-18 05:16:49', 0)
  RETURNING Instance_ID INTO v_new_child_instance_id;

  -- Step 2: Create the corresponding subtype record
  IF v_child_category = 'Commodity' THEN
    -- Find max existing Batch_Number for this specific Child_PID
    SELECT NVL(MAX(c.Batch_Number), 0) INTO v_max_existing_batch_lot
    FROM commodity c JOIN productInstance pi ON c.Instance_ID = pi.Instance_ID
    WHERE pi.Product_ID = 133.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next batch

    v_expiration_date := TIMESTAMP '2024-10-18 05:16:49' + INTERVAL '710' DAY;
    v_quantity_to_create := ROUND(1.2, 1);

    INSERT INTO commodity (Instance_ID, Batch_Number, Expiration_Date, Quantity)
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Packaged' THEN
    -- Find max existing Lot_Number for this specific Child_PID
    SELECT NVL(MAX(p.Lot_Number), 0) INTO v_max_existing_batch_lot
    FROM packaged p JOIN productInstance pi ON p.Instance_ID = pi.Instance_ID -- Assuming 'packaged' table name
    WHERE pi.Product_ID = 133.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next lot

    v_expiration_date := TIMESTAMP '2024-10-18 05:16:49' + INTERVAL '161' DAY;
    v_quantity_to_create := ROUND(1.2, 1);

    INSERT INTO packaged (Instance_ID, Lot_Number, Expiration_Date, Quantity) -- Assuming 'packaged' table name
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Serialized' THEN
    -- Assign a unique serial number
    -- Using Instance ID guarantees uniqueness within this context
    v_serial_number := 'SN-' || TO_CHAR(133.0) || '-' || TO_CHAR(v_new_child_instance_id) || '-' || SUBSTR(SYS_GUID(),1,8);
    -- Assign a batch number - use Product_ID of the *parent* instance as the batch for simplicity? Or a sequence?
    -- Let's use the Parent_IID itself as a simple batch identifier for this run.
    v_batch_number := 272.0; -- All children created FOR this parent get same batch number

    INSERT INTO serialized (Instance_ID, Serial_Number, Batch_Number)
    VALUES (v_new_child_instance_id, v_serial_number, v_batch_number);

    -- Quantity for usesComponent link for serialized is typically 1
    v_quantity_to_create := 1;

  END IF;

  -- Step 3: Create the usesComponent link
  -- Quantity_Used is the Quantity_Needed from needsComponent (which matches child quantity for non-serialized)
  IF v_child_category IN ('Commodity', 'Packaged', 'Serialized') THEN -- Only insert if subtype was handled
      INSERT INTO usesComponent (Parent_IID, Child_IID, Quantity_Used)
      VALUES (272.0, v_new_child_instance_id, ROUND(1.2, 1)); -- Use rounded quantity needed
  END IF;

EXCEPTION
  WHEN OTHERS THEN
    DBMS_OUTPUT.PUT_LINE('Error processing Parent_IID=' || 272.0 || ', Child_PID=' || 133.0 || ': ' || SQLERRM);
    -- Decide if you want to rollback just this block or let the main exception handler catch it
END;
/
DECLARE
  v_new_child_instance_id productInstance.Instance_ID%TYPE;
  v_child_category        product.Category%TYPE := 'Commodity'; -- Pass category
  v_max_existing_batch_lot NUMBER;
  v_next_batch_lot_num   NUMBER;
  v_serial_number        serialized.Serial_Number%TYPE;
  v_batch_number         serialized.Batch_Number%TYPE; -- Shared batch for serialized children of *this* parent
  v_expiration_date      commodity.Expiration_Date%TYPE;
  v_quantity_to_create   commodity.Quantity%TYPE; -- Quantity for the new child instance

BEGIN
  -- Step 1: Create the new child productInstance
  INSERT INTO productInstance (Product_ID, Date_Manufactured, Is_Recalled)
  VALUES (188.0, TIMESTAMP '2025-04-11 18:49:14', 0)
  RETURNING Instance_ID INTO v_new_child_instance_id;

  -- Step 2: Create the corresponding subtype record
  IF v_child_category = 'Commodity' THEN
    -- Find max existing Batch_Number for this specific Child_PID
    SELECT NVL(MAX(c.Batch_Number), 0) INTO v_max_existing_batch_lot
    FROM commodity c JOIN productInstance pi ON c.Instance_ID = pi.Instance_ID
    WHERE pi.Product_ID = 188.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next batch

    v_expiration_date := TIMESTAMP '2025-04-11 18:49:14' + INTERVAL '434' DAY;
    v_quantity_to_create := ROUND(1.1, 1);

    INSERT INTO commodity (Instance_ID, Batch_Number, Expiration_Date, Quantity)
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Packaged' THEN
    -- Find max existing Lot_Number for this specific Child_PID
    SELECT NVL(MAX(p.Lot_Number), 0) INTO v_max_existing_batch_lot
    FROM packaged p JOIN productInstance pi ON p.Instance_ID = pi.Instance_ID -- Assuming 'packaged' table name
    WHERE pi.Product_ID = 188.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next lot

    v_expiration_date := TIMESTAMP '2025-04-11 18:49:14' + INTERVAL '486' DAY;
    v_quantity_to_create := ROUND(1.1, 1);

    INSERT INTO packaged (Instance_ID, Lot_Number, Expiration_Date, Quantity) -- Assuming 'packaged' table name
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Serialized' THEN
    -- Assign a unique serial number
    -- Using Instance ID guarantees uniqueness within this context
    v_serial_number := 'SN-' || TO_CHAR(188.0) || '-' || TO_CHAR(v_new_child_instance_id) || '-' || SUBSTR(SYS_GUID(),1,8);
    -- Assign a batch number - use Product_ID of the *parent* instance as the batch for simplicity? Or a sequence?
    -- Let's use the Parent_IID itself as a simple batch identifier for this run.
    v_batch_number := 282.0; -- All children created FOR this parent get same batch number

    INSERT INTO serialized (Instance_ID, Serial_Number, Batch_Number)
    VALUES (v_new_child_instance_id, v_serial_number, v_batch_number);

    -- Quantity for usesComponent link for serialized is typically 1
    v_quantity_to_create := 1;

  END IF;

  -- Step 3: Create the usesComponent link
  -- Quantity_Used is the Quantity_Needed from needsComponent (which matches child quantity for non-serialized)
  IF v_child_category IN ('Commodity', 'Packaged', 'Serialized') THEN -- Only insert if subtype was handled
      INSERT INTO usesComponent (Parent_IID, Child_IID, Quantity_Used)
      VALUES (282.0, v_new_child_instance_id, ROUND(1.1, 1)); -- Use rounded quantity needed
  END IF;

EXCEPTION
  WHEN OTHERS THEN
    DBMS_OUTPUT.PUT_LINE('Error processing Parent_IID=' || 282.0 || ', Child_PID=' || 188.0 || ': ' || SQLERRM);
    -- Decide if you want to rollback just this block or let the main exception handler catch it
END;
/
DECLARE
  v_new_child_instance_id productInstance.Instance_ID%TYPE;
  v_child_category        product.Category%TYPE := 'Commodity'; -- Pass category
  v_max_existing_batch_lot NUMBER;
  v_next_batch_lot_num   NUMBER;
  v_serial_number        serialized.Serial_Number%TYPE;
  v_batch_number         serialized.Batch_Number%TYPE; -- Shared batch for serialized children of *this* parent
  v_expiration_date      commodity.Expiration_Date%TYPE;
  v_quantity_to_create   commodity.Quantity%TYPE; -- Quantity for the new child instance

BEGIN
  -- Step 1: Create the new child productInstance
  INSERT INTO productInstance (Product_ID, Date_Manufactured, Is_Recalled)
  VALUES (222.0, TIMESTAMP '2024-05-08 14:26:00', 0)
  RETURNING Instance_ID INTO v_new_child_instance_id;

  -- Step 2: Create the corresponding subtype record
  IF v_child_category = 'Commodity' THEN
    -- Find max existing Batch_Number for this specific Child_PID
    SELECT NVL(MAX(c.Batch_Number), 0) INTO v_max_existing_batch_lot
    FROM commodity c JOIN productInstance pi ON c.Instance_ID = pi.Instance_ID
    WHERE pi.Product_ID = 222.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next batch

    v_expiration_date := TIMESTAMP '2024-05-08 14:26:00' + INTERVAL '567' DAY;
    v_quantity_to_create := ROUND(1.7, 1);

    INSERT INTO commodity (Instance_ID, Batch_Number, Expiration_Date, Quantity)
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Packaged' THEN
    -- Find max existing Lot_Number for this specific Child_PID
    SELECT NVL(MAX(p.Lot_Number), 0) INTO v_max_existing_batch_lot
    FROM packaged p JOIN productInstance pi ON p.Instance_ID = pi.Instance_ID -- Assuming 'packaged' table name
    WHERE pi.Product_ID = 222.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next lot

    v_expiration_date := TIMESTAMP '2024-05-08 14:26:00' + INTERVAL '306' DAY;
    v_quantity_to_create := ROUND(1.7, 1);

    INSERT INTO packaged (Instance_ID, Lot_Number, Expiration_Date, Quantity) -- Assuming 'packaged' table name
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Serialized' THEN
    -- Assign a unique serial number
    -- Using Instance ID guarantees uniqueness within this context
    v_serial_number := 'SN-' || TO_CHAR(222.0) || '-' || TO_CHAR(v_new_child_instance_id) || '-' || SUBSTR(SYS_GUID(),1,8);
    -- Assign a batch number - use Product_ID of the *parent* instance as the batch for simplicity? Or a sequence?
    -- Let's use the Parent_IID itself as a simple batch identifier for this run.
    v_batch_number := 282.0; -- All children created FOR this parent get same batch number

    INSERT INTO serialized (Instance_ID, Serial_Number, Batch_Number)
    VALUES (v_new_child_instance_id, v_serial_number, v_batch_number);

    -- Quantity for usesComponent link for serialized is typically 1
    v_quantity_to_create := 1;

  END IF;

  -- Step 3: Create the usesComponent link
  -- Quantity_Used is the Quantity_Needed from needsComponent (which matches child quantity for non-serialized)
  IF v_child_category IN ('Commodity', 'Packaged', 'Serialized') THEN -- Only insert if subtype was handled
      INSERT INTO usesComponent (Parent_IID, Child_IID, Quantity_Used)
      VALUES (282.0, v_new_child_instance_id, ROUND(1.7, 1)); -- Use rounded quantity needed
  END IF;

EXCEPTION
  WHEN OTHERS THEN
    DBMS_OUTPUT.PUT_LINE('Error processing Parent_IID=' || 282.0 || ', Child_PID=' || 222.0 || ': ' || SQLERRM);
    -- Decide if you want to rollback just this block or let the main exception handler catch it
END;
/
DECLARE
  v_new_child_instance_id productInstance.Instance_ID%TYPE;
  v_child_category        product.Category%TYPE := 'Commodity'; -- Pass category
  v_max_existing_batch_lot NUMBER;
  v_next_batch_lot_num   NUMBER;
  v_serial_number        serialized.Serial_Number%TYPE;
  v_batch_number         serialized.Batch_Number%TYPE; -- Shared batch for serialized children of *this* parent
  v_expiration_date      commodity.Expiration_Date%TYPE;
  v_quantity_to_create   commodity.Quantity%TYPE; -- Quantity for the new child instance

BEGIN
  -- Step 1: Create the new child productInstance
  INSERT INTO productInstance (Product_ID, Date_Manufactured, Is_Recalled)
  VALUES (601.0, TIMESTAMP '2024-06-03 03:19:55', 0)
  RETURNING Instance_ID INTO v_new_child_instance_id;

  -- Step 2: Create the corresponding subtype record
  IF v_child_category = 'Commodity' THEN
    -- Find max existing Batch_Number for this specific Child_PID
    SELECT NVL(MAX(c.Batch_Number), 0) INTO v_max_existing_batch_lot
    FROM commodity c JOIN productInstance pi ON c.Instance_ID = pi.Instance_ID
    WHERE pi.Product_ID = 601.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next batch

    v_expiration_date := TIMESTAMP '2024-06-03 03:19:55' + INTERVAL '286' DAY;
    v_quantity_to_create := ROUND(0.3, 1);

    INSERT INTO commodity (Instance_ID, Batch_Number, Expiration_Date, Quantity)
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Packaged' THEN
    -- Find max existing Lot_Number for this specific Child_PID
    SELECT NVL(MAX(p.Lot_Number), 0) INTO v_max_existing_batch_lot
    FROM packaged p JOIN productInstance pi ON p.Instance_ID = pi.Instance_ID -- Assuming 'packaged' table name
    WHERE pi.Product_ID = 601.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next lot

    v_expiration_date := TIMESTAMP '2024-06-03 03:19:55' + INTERVAL '363' DAY;
    v_quantity_to_create := ROUND(0.3, 1);

    INSERT INTO packaged (Instance_ID, Lot_Number, Expiration_Date, Quantity) -- Assuming 'packaged' table name
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Serialized' THEN
    -- Assign a unique serial number
    -- Using Instance ID guarantees uniqueness within this context
    v_serial_number := 'SN-' || TO_CHAR(601.0) || '-' || TO_CHAR(v_new_child_instance_id) || '-' || SUBSTR(SYS_GUID(),1,8);
    -- Assign a batch number - use Product_ID of the *parent* instance as the batch for simplicity? Or a sequence?
    -- Let's use the Parent_IID itself as a simple batch identifier for this run.
    v_batch_number := 292.0; -- All children created FOR this parent get same batch number

    INSERT INTO serialized (Instance_ID, Serial_Number, Batch_Number)
    VALUES (v_new_child_instance_id, v_serial_number, v_batch_number);

    -- Quantity for usesComponent link for serialized is typically 1
    v_quantity_to_create := 1;

  END IF;

  -- Step 3: Create the usesComponent link
  -- Quantity_Used is the Quantity_Needed from needsComponent (which matches child quantity for non-serialized)
  IF v_child_category IN ('Commodity', 'Packaged', 'Serialized') THEN -- Only insert if subtype was handled
      INSERT INTO usesComponent (Parent_IID, Child_IID, Quantity_Used)
      VALUES (292.0, v_new_child_instance_id, ROUND(0.3, 1)); -- Use rounded quantity needed
  END IF;

EXCEPTION
  WHEN OTHERS THEN
    DBMS_OUTPUT.PUT_LINE('Error processing Parent_IID=' || 292.0 || ', Child_PID=' || 601.0 || ': ' || SQLERRM);
    -- Decide if you want to rollback just this block or let the main exception handler catch it
END;
/
DECLARE
  v_new_child_instance_id productInstance.Instance_ID%TYPE;
  v_child_category        product.Category%TYPE := 'Commodity'; -- Pass category
  v_max_existing_batch_lot NUMBER;
  v_next_batch_lot_num   NUMBER;
  v_serial_number        serialized.Serial_Number%TYPE;
  v_batch_number         serialized.Batch_Number%TYPE; -- Shared batch for serialized children of *this* parent
  v_expiration_date      commodity.Expiration_Date%TYPE;
  v_quantity_to_create   commodity.Quantity%TYPE; -- Quantity for the new child instance

BEGIN
  -- Step 1: Create the new child productInstance
  INSERT INTO productInstance (Product_ID, Date_Manufactured, Is_Recalled)
  VALUES (601.0, TIMESTAMP '2024-06-01 08:32:16', 0)
  RETURNING Instance_ID INTO v_new_child_instance_id;

  -- Step 2: Create the corresponding subtype record
  IF v_child_category = 'Commodity' THEN
    -- Find max existing Batch_Number for this specific Child_PID
    SELECT NVL(MAX(c.Batch_Number), 0) INTO v_max_existing_batch_lot
    FROM commodity c JOIN productInstance pi ON c.Instance_ID = pi.Instance_ID
    WHERE pi.Product_ID = 601.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next batch

    v_expiration_date := TIMESTAMP '2024-06-01 08:32:16' + INTERVAL '339' DAY;
    v_quantity_to_create := ROUND(0.3, 1);

    INSERT INTO commodity (Instance_ID, Batch_Number, Expiration_Date, Quantity)
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Packaged' THEN
    -- Find max existing Lot_Number for this specific Child_PID
    SELECT NVL(MAX(p.Lot_Number), 0) INTO v_max_existing_batch_lot
    FROM packaged p JOIN productInstance pi ON p.Instance_ID = pi.Instance_ID -- Assuming 'packaged' table name
    WHERE pi.Product_ID = 601.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next lot

    v_expiration_date := TIMESTAMP '2024-06-01 08:32:16' + INTERVAL '65' DAY;
    v_quantity_to_create := ROUND(0.3, 1);

    INSERT INTO packaged (Instance_ID, Lot_Number, Expiration_Date, Quantity) -- Assuming 'packaged' table name
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Serialized' THEN
    -- Assign a unique serial number
    -- Using Instance ID guarantees uniqueness within this context
    v_serial_number := 'SN-' || TO_CHAR(601.0) || '-' || TO_CHAR(v_new_child_instance_id) || '-' || SUBSTR(SYS_GUID(),1,8);
    -- Assign a batch number - use Product_ID of the *parent* instance as the batch for simplicity? Or a sequence?
    -- Let's use the Parent_IID itself as a simple batch identifier for this run.
    v_batch_number := 293.0; -- All children created FOR this parent get same batch number

    INSERT INTO serialized (Instance_ID, Serial_Number, Batch_Number)
    VALUES (v_new_child_instance_id, v_serial_number, v_batch_number);

    -- Quantity for usesComponent link for serialized is typically 1
    v_quantity_to_create := 1;

  END IF;

  -- Step 3: Create the usesComponent link
  -- Quantity_Used is the Quantity_Needed from needsComponent (which matches child quantity for non-serialized)
  IF v_child_category IN ('Commodity', 'Packaged', 'Serialized') THEN -- Only insert if subtype was handled
      INSERT INTO usesComponent (Parent_IID, Child_IID, Quantity_Used)
      VALUES (293.0, v_new_child_instance_id, ROUND(0.3, 1)); -- Use rounded quantity needed
  END IF;

EXCEPTION
  WHEN OTHERS THEN
    DBMS_OUTPUT.PUT_LINE('Error processing Parent_IID=' || 293.0 || ', Child_PID=' || 601.0 || ': ' || SQLERRM);
    -- Decide if you want to rollback just this block or let the main exception handler catch it
END;
/
DECLARE
  v_new_child_instance_id productInstance.Instance_ID%TYPE;
  v_child_category        product.Category%TYPE := 'Commodity'; -- Pass category
  v_max_existing_batch_lot NUMBER;
  v_next_batch_lot_num   NUMBER;
  v_serial_number        serialized.Serial_Number%TYPE;
  v_batch_number         serialized.Batch_Number%TYPE; -- Shared batch for serialized children of *this* parent
  v_expiration_date      commodity.Expiration_Date%TYPE;
  v_quantity_to_create   commodity.Quantity%TYPE; -- Quantity for the new child instance

BEGIN
  -- Step 1: Create the new child productInstance
  INSERT INTO productInstance (Product_ID, Date_Manufactured, Is_Recalled)
  VALUES (601.0, TIMESTAMP '2025-03-28 21:53:56', 0)
  RETURNING Instance_ID INTO v_new_child_instance_id;

  -- Step 2: Create the corresponding subtype record
  IF v_child_category = 'Commodity' THEN
    -- Find max existing Batch_Number for this specific Child_PID
    SELECT NVL(MAX(c.Batch_Number), 0) INTO v_max_existing_batch_lot
    FROM commodity c JOIN productInstance pi ON c.Instance_ID = pi.Instance_ID
    WHERE pi.Product_ID = 601.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next batch

    v_expiration_date := TIMESTAMP '2025-03-28 21:53:56' + INTERVAL '423' DAY;
    v_quantity_to_create := ROUND(0.3, 1);

    INSERT INTO commodity (Instance_ID, Batch_Number, Expiration_Date, Quantity)
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Packaged' THEN
    -- Find max existing Lot_Number for this specific Child_PID
    SELECT NVL(MAX(p.Lot_Number), 0) INTO v_max_existing_batch_lot
    FROM packaged p JOIN productInstance pi ON p.Instance_ID = pi.Instance_ID -- Assuming 'packaged' table name
    WHERE pi.Product_ID = 601.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next lot

    v_expiration_date := TIMESTAMP '2025-03-28 21:53:56' + INTERVAL '89' DAY;
    v_quantity_to_create := ROUND(0.3, 1);

    INSERT INTO packaged (Instance_ID, Lot_Number, Expiration_Date, Quantity) -- Assuming 'packaged' table name
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Serialized' THEN
    -- Assign a unique serial number
    -- Using Instance ID guarantees uniqueness within this context
    v_serial_number := 'SN-' || TO_CHAR(601.0) || '-' || TO_CHAR(v_new_child_instance_id) || '-' || SUBSTR(SYS_GUID(),1,8);
    -- Assign a batch number - use Product_ID of the *parent* instance as the batch for simplicity? Or a sequence?
    -- Let's use the Parent_IID itself as a simple batch identifier for this run.
    v_batch_number := 294.0; -- All children created FOR this parent get same batch number

    INSERT INTO serialized (Instance_ID, Serial_Number, Batch_Number)
    VALUES (v_new_child_instance_id, v_serial_number, v_batch_number);

    -- Quantity for usesComponent link for serialized is typically 1
    v_quantity_to_create := 1;

  END IF;

  -- Step 3: Create the usesComponent link
  -- Quantity_Used is the Quantity_Needed from needsComponent (which matches child quantity for non-serialized)
  IF v_child_category IN ('Commodity', 'Packaged', 'Serialized') THEN -- Only insert if subtype was handled
      INSERT INTO usesComponent (Parent_IID, Child_IID, Quantity_Used)
      VALUES (294.0, v_new_child_instance_id, ROUND(0.3, 1)); -- Use rounded quantity needed
  END IF;

EXCEPTION
  WHEN OTHERS THEN
    DBMS_OUTPUT.PUT_LINE('Error processing Parent_IID=' || 294.0 || ', Child_PID=' || 601.0 || ': ' || SQLERRM);
    -- Decide if you want to rollback just this block or let the main exception handler catch it
END;
/
DECLARE
  v_new_child_instance_id productInstance.Instance_ID%TYPE;
  v_child_category        product.Category%TYPE := 'Commodity'; -- Pass category
  v_max_existing_batch_lot NUMBER;
  v_next_batch_lot_num   NUMBER;
  v_serial_number        serialized.Serial_Number%TYPE;
  v_batch_number         serialized.Batch_Number%TYPE; -- Shared batch for serialized children of *this* parent
  v_expiration_date      commodity.Expiration_Date%TYPE;
  v_quantity_to_create   commodity.Quantity%TYPE; -- Quantity for the new child instance

BEGIN
  -- Step 1: Create the new child productInstance
  INSERT INTO productInstance (Product_ID, Date_Manufactured, Is_Recalled)
  VALUES (228.0, TIMESTAMP '2025-02-07 13:20:44', 0)
  RETURNING Instance_ID INTO v_new_child_instance_id;

  -- Step 2: Create the corresponding subtype record
  IF v_child_category = 'Commodity' THEN
    -- Find max existing Batch_Number for this specific Child_PID
    SELECT NVL(MAX(c.Batch_Number), 0) INTO v_max_existing_batch_lot
    FROM commodity c JOIN productInstance pi ON c.Instance_ID = pi.Instance_ID
    WHERE pi.Product_ID = 228.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next batch

    v_expiration_date := TIMESTAMP '2025-02-07 13:20:44' + INTERVAL '297' DAY;
    v_quantity_to_create := ROUND(0.8, 1);

    INSERT INTO commodity (Instance_ID, Batch_Number, Expiration_Date, Quantity)
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Packaged' THEN
    -- Find max existing Lot_Number for this specific Child_PID
    SELECT NVL(MAX(p.Lot_Number), 0) INTO v_max_existing_batch_lot
    FROM packaged p JOIN productInstance pi ON p.Instance_ID = pi.Instance_ID -- Assuming 'packaged' table name
    WHERE pi.Product_ID = 228.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next lot

    v_expiration_date := TIMESTAMP '2025-02-07 13:20:44' + INTERVAL '350' DAY;
    v_quantity_to_create := ROUND(0.8, 1);

    INSERT INTO packaged (Instance_ID, Lot_Number, Expiration_Date, Quantity) -- Assuming 'packaged' table name
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Serialized' THEN
    -- Assign a unique serial number
    -- Using Instance ID guarantees uniqueness within this context
    v_serial_number := 'SN-' || TO_CHAR(228.0) || '-' || TO_CHAR(v_new_child_instance_id) || '-' || SUBSTR(SYS_GUID(),1,8);
    -- Assign a batch number - use Product_ID of the *parent* instance as the batch for simplicity? Or a sequence?
    -- Let's use the Parent_IID itself as a simple batch identifier for this run.
    v_batch_number := 314.0; -- All children created FOR this parent get same batch number

    INSERT INTO serialized (Instance_ID, Serial_Number, Batch_Number)
    VALUES (v_new_child_instance_id, v_serial_number, v_batch_number);

    -- Quantity for usesComponent link for serialized is typically 1
    v_quantity_to_create := 1;

  END IF;

  -- Step 3: Create the usesComponent link
  -- Quantity_Used is the Quantity_Needed from needsComponent (which matches child quantity for non-serialized)
  IF v_child_category IN ('Commodity', 'Packaged', 'Serialized') THEN -- Only insert if subtype was handled
      INSERT INTO usesComponent (Parent_IID, Child_IID, Quantity_Used)
      VALUES (314.0, v_new_child_instance_id, ROUND(0.8, 1)); -- Use rounded quantity needed
  END IF;

EXCEPTION
  WHEN OTHERS THEN
    DBMS_OUTPUT.PUT_LINE('Error processing Parent_IID=' || 314.0 || ', Child_PID=' || 228.0 || ': ' || SQLERRM);
    -- Decide if you want to rollback just this block or let the main exception handler catch it
END;
/
DECLARE
  v_new_child_instance_id productInstance.Instance_ID%TYPE;
  v_child_category        product.Category%TYPE := 'Commodity'; -- Pass category
  v_max_existing_batch_lot NUMBER;
  v_next_batch_lot_num   NUMBER;
  v_serial_number        serialized.Serial_Number%TYPE;
  v_batch_number         serialized.Batch_Number%TYPE; -- Shared batch for serialized children of *this* parent
  v_expiration_date      commodity.Expiration_Date%TYPE;
  v_quantity_to_create   commodity.Quantity%TYPE; -- Quantity for the new child instance

BEGIN
  -- Step 1: Create the new child productInstance
  INSERT INTO productInstance (Product_ID, Date_Manufactured, Is_Recalled)
  VALUES (228.0, TIMESTAMP '2025-02-08 13:43:30', 0)
  RETURNING Instance_ID INTO v_new_child_instance_id;

  -- Step 2: Create the corresponding subtype record
  IF v_child_category = 'Commodity' THEN
    -- Find max existing Batch_Number for this specific Child_PID
    SELECT NVL(MAX(c.Batch_Number), 0) INTO v_max_existing_batch_lot
    FROM commodity c JOIN productInstance pi ON c.Instance_ID = pi.Instance_ID
    WHERE pi.Product_ID = 228.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next batch

    v_expiration_date := TIMESTAMP '2025-02-08 13:43:30' + INTERVAL '163' DAY;
    v_quantity_to_create := ROUND(0.8, 1);

    INSERT INTO commodity (Instance_ID, Batch_Number, Expiration_Date, Quantity)
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Packaged' THEN
    -- Find max existing Lot_Number for this specific Child_PID
    SELECT NVL(MAX(p.Lot_Number), 0) INTO v_max_existing_batch_lot
    FROM packaged p JOIN productInstance pi ON p.Instance_ID = pi.Instance_ID -- Assuming 'packaged' table name
    WHERE pi.Product_ID = 228.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next lot

    v_expiration_date := TIMESTAMP '2025-02-08 13:43:30' + INTERVAL '296' DAY;
    v_quantity_to_create := ROUND(0.8, 1);

    INSERT INTO packaged (Instance_ID, Lot_Number, Expiration_Date, Quantity) -- Assuming 'packaged' table name
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Serialized' THEN
    -- Assign a unique serial number
    -- Using Instance ID guarantees uniqueness within this context
    v_serial_number := 'SN-' || TO_CHAR(228.0) || '-' || TO_CHAR(v_new_child_instance_id) || '-' || SUBSTR(SYS_GUID(),1,8);
    -- Assign a batch number - use Product_ID of the *parent* instance as the batch for simplicity? Or a sequence?
    -- Let's use the Parent_IID itself as a simple batch identifier for this run.
    v_batch_number := 315.0; -- All children created FOR this parent get same batch number

    INSERT INTO serialized (Instance_ID, Serial_Number, Batch_Number)
    VALUES (v_new_child_instance_id, v_serial_number, v_batch_number);

    -- Quantity for usesComponent link for serialized is typically 1
    v_quantity_to_create := 1;

  END IF;

  -- Step 3: Create the usesComponent link
  -- Quantity_Used is the Quantity_Needed from needsComponent (which matches child quantity for non-serialized)
  IF v_child_category IN ('Commodity', 'Packaged', 'Serialized') THEN -- Only insert if subtype was handled
      INSERT INTO usesComponent (Parent_IID, Child_IID, Quantity_Used)
      VALUES (315.0, v_new_child_instance_id, ROUND(0.8, 1)); -- Use rounded quantity needed
  END IF;

EXCEPTION
  WHEN OTHERS THEN
    DBMS_OUTPUT.PUT_LINE('Error processing Parent_IID=' || 315.0 || ', Child_PID=' || 228.0 || ': ' || SQLERRM);
    -- Decide if you want to rollback just this block or let the main exception handler catch it
END;
/
DECLARE
  v_new_child_instance_id productInstance.Instance_ID%TYPE;
  v_child_category        product.Category%TYPE := 'Commodity'; -- Pass category
  v_max_existing_batch_lot NUMBER;
  v_next_batch_lot_num   NUMBER;
  v_serial_number        serialized.Serial_Number%TYPE;
  v_batch_number         serialized.Batch_Number%TYPE; -- Shared batch for serialized children of *this* parent
  v_expiration_date      commodity.Expiration_Date%TYPE;
  v_quantity_to_create   commodity.Quantity%TYPE; -- Quantity for the new child instance

BEGIN
  -- Step 1: Create the new child productInstance
  INSERT INTO productInstance (Product_ID, Date_Manufactured, Is_Recalled)
  VALUES (114.0, TIMESTAMP '2025-03-03 14:54:39', 0)
  RETURNING Instance_ID INTO v_new_child_instance_id;

  -- Step 2: Create the corresponding subtype record
  IF v_child_category = 'Commodity' THEN
    -- Find max existing Batch_Number for this specific Child_PID
    SELECT NVL(MAX(c.Batch_Number), 0) INTO v_max_existing_batch_lot
    FROM commodity c JOIN productInstance pi ON c.Instance_ID = pi.Instance_ID
    WHERE pi.Product_ID = 114.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next batch

    v_expiration_date := TIMESTAMP '2025-03-03 14:54:39' + INTERVAL '419' DAY;
    v_quantity_to_create := ROUND(1.1, 1);

    INSERT INTO commodity (Instance_ID, Batch_Number, Expiration_Date, Quantity)
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Packaged' THEN
    -- Find max existing Lot_Number for this specific Child_PID
    SELECT NVL(MAX(p.Lot_Number), 0) INTO v_max_existing_batch_lot
    FROM packaged p JOIN productInstance pi ON p.Instance_ID = pi.Instance_ID -- Assuming 'packaged' table name
    WHERE pi.Product_ID = 114.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next lot

    v_expiration_date := TIMESTAMP '2025-03-03 14:54:39' + INTERVAL '149' DAY;
    v_quantity_to_create := ROUND(1.1, 1);

    INSERT INTO packaged (Instance_ID, Lot_Number, Expiration_Date, Quantity) -- Assuming 'packaged' table name
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Serialized' THEN
    -- Assign a unique serial number
    -- Using Instance ID guarantees uniqueness within this context
    v_serial_number := 'SN-' || TO_CHAR(114.0) || '-' || TO_CHAR(v_new_child_instance_id) || '-' || SUBSTR(SYS_GUID(),1,8);
    -- Assign a batch number - use Product_ID of the *parent* instance as the batch for simplicity? Or a sequence?
    -- Let's use the Parent_IID itself as a simple batch identifier for this run.
    v_batch_number := 331.0; -- All children created FOR this parent get same batch number

    INSERT INTO serialized (Instance_ID, Serial_Number, Batch_Number)
    VALUES (v_new_child_instance_id, v_serial_number, v_batch_number);

    -- Quantity for usesComponent link for serialized is typically 1
    v_quantity_to_create := 1;

  END IF;

  -- Step 3: Create the usesComponent link
  -- Quantity_Used is the Quantity_Needed from needsComponent (which matches child quantity for non-serialized)
  IF v_child_category IN ('Commodity', 'Packaged', 'Serialized') THEN -- Only insert if subtype was handled
      INSERT INTO usesComponent (Parent_IID, Child_IID, Quantity_Used)
      VALUES (331.0, v_new_child_instance_id, ROUND(1.1, 1)); -- Use rounded quantity needed
  END IF;

EXCEPTION
  WHEN OTHERS THEN
    DBMS_OUTPUT.PUT_LINE('Error processing Parent_IID=' || 331.0 || ', Child_PID=' || 114.0 || ': ' || SQLERRM);
    -- Decide if you want to rollback just this block or let the main exception handler catch it
END;
/
DECLARE
  v_new_child_instance_id productInstance.Instance_ID%TYPE;
  v_child_category        product.Category%TYPE := 'Commodity'; -- Pass category
  v_max_existing_batch_lot NUMBER;
  v_next_batch_lot_num   NUMBER;
  v_serial_number        serialized.Serial_Number%TYPE;
  v_batch_number         serialized.Batch_Number%TYPE; -- Shared batch for serialized children of *this* parent
  v_expiration_date      commodity.Expiration_Date%TYPE;
  v_quantity_to_create   commodity.Quantity%TYPE; -- Quantity for the new child instance

BEGIN
  -- Step 1: Create the new child productInstance
  INSERT INTO productInstance (Product_ID, Date_Manufactured, Is_Recalled)
  VALUES (181.0, TIMESTAMP '2025-03-27 10:09:09', 0)
  RETURNING Instance_ID INTO v_new_child_instance_id;

  -- Step 2: Create the corresponding subtype record
  IF v_child_category = 'Commodity' THEN
    -- Find max existing Batch_Number for this specific Child_PID
    SELECT NVL(MAX(c.Batch_Number), 0) INTO v_max_existing_batch_lot
    FROM commodity c JOIN productInstance pi ON c.Instance_ID = pi.Instance_ID
    WHERE pi.Product_ID = 181.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next batch

    v_expiration_date := TIMESTAMP '2025-03-27 10:09:09' + INTERVAL '724' DAY;
    v_quantity_to_create := ROUND(1.2, 1);

    INSERT INTO commodity (Instance_ID, Batch_Number, Expiration_Date, Quantity)
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Packaged' THEN
    -- Find max existing Lot_Number for this specific Child_PID
    SELECT NVL(MAX(p.Lot_Number), 0) INTO v_max_existing_batch_lot
    FROM packaged p JOIN productInstance pi ON p.Instance_ID = pi.Instance_ID -- Assuming 'packaged' table name
    WHERE pi.Product_ID = 181.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next lot

    v_expiration_date := TIMESTAMP '2025-03-27 10:09:09' + INTERVAL '341' DAY;
    v_quantity_to_create := ROUND(1.2, 1);

    INSERT INTO packaged (Instance_ID, Lot_Number, Expiration_Date, Quantity) -- Assuming 'packaged' table name
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Serialized' THEN
    -- Assign a unique serial number
    -- Using Instance ID guarantees uniqueness within this context
    v_serial_number := 'SN-' || TO_CHAR(181.0) || '-' || TO_CHAR(v_new_child_instance_id) || '-' || SUBSTR(SYS_GUID(),1,8);
    -- Assign a batch number - use Product_ID of the *parent* instance as the batch for simplicity? Or a sequence?
    -- Let's use the Parent_IID itself as a simple batch identifier for this run.
    v_batch_number := 331.0; -- All children created FOR this parent get same batch number

    INSERT INTO serialized (Instance_ID, Serial_Number, Batch_Number)
    VALUES (v_new_child_instance_id, v_serial_number, v_batch_number);

    -- Quantity for usesComponent link for serialized is typically 1
    v_quantity_to_create := 1;

  END IF;

  -- Step 3: Create the usesComponent link
  -- Quantity_Used is the Quantity_Needed from needsComponent (which matches child quantity for non-serialized)
  IF v_child_category IN ('Commodity', 'Packaged', 'Serialized') THEN -- Only insert if subtype was handled
      INSERT INTO usesComponent (Parent_IID, Child_IID, Quantity_Used)
      VALUES (331.0, v_new_child_instance_id, ROUND(1.2, 1)); -- Use rounded quantity needed
  END IF;

EXCEPTION
  WHEN OTHERS THEN
    DBMS_OUTPUT.PUT_LINE('Error processing Parent_IID=' || 331.0 || ', Child_PID=' || 181.0 || ': ' || SQLERRM);
    -- Decide if you want to rollback just this block or let the main exception handler catch it
END;
/
DECLARE
  v_new_child_instance_id productInstance.Instance_ID%TYPE;
  v_child_category        product.Category%TYPE := 'Commodity'; -- Pass category
  v_max_existing_batch_lot NUMBER;
  v_next_batch_lot_num   NUMBER;
  v_serial_number        serialized.Serial_Number%TYPE;
  v_batch_number         serialized.Batch_Number%TYPE; -- Shared batch for serialized children of *this* parent
  v_expiration_date      commodity.Expiration_Date%TYPE;
  v_quantity_to_create   commodity.Quantity%TYPE; -- Quantity for the new child instance

BEGIN
  -- Step 1: Create the new child productInstance
  INSERT INTO productInstance (Product_ID, Date_Manufactured, Is_Recalled)
  VALUES (601.0, TIMESTAMP '2024-06-04 13:38:58', 0)
  RETURNING Instance_ID INTO v_new_child_instance_id;

  -- Step 2: Create the corresponding subtype record
  IF v_child_category = 'Commodity' THEN
    -- Find max existing Batch_Number for this specific Child_PID
    SELECT NVL(MAX(c.Batch_Number), 0) INTO v_max_existing_batch_lot
    FROM commodity c JOIN productInstance pi ON c.Instance_ID = pi.Instance_ID
    WHERE pi.Product_ID = 601.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next batch

    v_expiration_date := TIMESTAMP '2024-06-04 13:38:58' + INTERVAL '465' DAY;
    v_quantity_to_create := ROUND(0.6, 1);

    INSERT INTO commodity (Instance_ID, Batch_Number, Expiration_Date, Quantity)
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Packaged' THEN
    -- Find max existing Lot_Number for this specific Child_PID
    SELECT NVL(MAX(p.Lot_Number), 0) INTO v_max_existing_batch_lot
    FROM packaged p JOIN productInstance pi ON p.Instance_ID = pi.Instance_ID -- Assuming 'packaged' table name
    WHERE pi.Product_ID = 601.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next lot

    v_expiration_date := TIMESTAMP '2024-06-04 13:38:58' + INTERVAL '281' DAY;
    v_quantity_to_create := ROUND(0.6, 1);

    INSERT INTO packaged (Instance_ID, Lot_Number, Expiration_Date, Quantity) -- Assuming 'packaged' table name
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Serialized' THEN
    -- Assign a unique serial number
    -- Using Instance ID guarantees uniqueness within this context
    v_serial_number := 'SN-' || TO_CHAR(601.0) || '-' || TO_CHAR(v_new_child_instance_id) || '-' || SUBSTR(SYS_GUID(),1,8);
    -- Assign a batch number - use Product_ID of the *parent* instance as the batch for simplicity? Or a sequence?
    -- Let's use the Parent_IID itself as a simple batch identifier for this run.
    v_batch_number := 350.0; -- All children created FOR this parent get same batch number

    INSERT INTO serialized (Instance_ID, Serial_Number, Batch_Number)
    VALUES (v_new_child_instance_id, v_serial_number, v_batch_number);

    -- Quantity for usesComponent link for serialized is typically 1
    v_quantity_to_create := 1;

  END IF;

  -- Step 3: Create the usesComponent link
  -- Quantity_Used is the Quantity_Needed from needsComponent (which matches child quantity for non-serialized)
  IF v_child_category IN ('Commodity', 'Packaged', 'Serialized') THEN -- Only insert if subtype was handled
      INSERT INTO usesComponent (Parent_IID, Child_IID, Quantity_Used)
      VALUES (350.0, v_new_child_instance_id, ROUND(0.6, 1)); -- Use rounded quantity needed
  END IF;

EXCEPTION
  WHEN OTHERS THEN
    DBMS_OUTPUT.PUT_LINE('Error processing Parent_IID=' || 350.0 || ', Child_PID=' || 601.0 || ': ' || SQLERRM);
    -- Decide if you want to rollback just this block or let the main exception handler catch it
END;
/
DECLARE
  v_new_child_instance_id productInstance.Instance_ID%TYPE;
  v_child_category        product.Category%TYPE := 'Commodity'; -- Pass category
  v_max_existing_batch_lot NUMBER;
  v_next_batch_lot_num   NUMBER;
  v_serial_number        serialized.Serial_Number%TYPE;
  v_batch_number         serialized.Batch_Number%TYPE; -- Shared batch for serialized children of *this* parent
  v_expiration_date      commodity.Expiration_Date%TYPE;
  v_quantity_to_create   commodity.Quantity%TYPE; -- Quantity for the new child instance

BEGIN
  -- Step 1: Create the new child productInstance
  INSERT INTO productInstance (Product_ID, Date_Manufactured, Is_Recalled)
  VALUES (601.0, TIMESTAMP '2024-11-10 06:49:40', 0)
  RETURNING Instance_ID INTO v_new_child_instance_id;

  -- Step 2: Create the corresponding subtype record
  IF v_child_category = 'Commodity' THEN
    -- Find max existing Batch_Number for this specific Child_PID
    SELECT NVL(MAX(c.Batch_Number), 0) INTO v_max_existing_batch_lot
    FROM commodity c JOIN productInstance pi ON c.Instance_ID = pi.Instance_ID
    WHERE pi.Product_ID = 601.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next batch

    v_expiration_date := TIMESTAMP '2024-11-10 06:49:40' + INTERVAL '600' DAY;
    v_quantity_to_create := ROUND(0.6, 1);

    INSERT INTO commodity (Instance_ID, Batch_Number, Expiration_Date, Quantity)
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Packaged' THEN
    -- Find max existing Lot_Number for this specific Child_PID
    SELECT NVL(MAX(p.Lot_Number), 0) INTO v_max_existing_batch_lot
    FROM packaged p JOIN productInstance pi ON p.Instance_ID = pi.Instance_ID -- Assuming 'packaged' table name
    WHERE pi.Product_ID = 601.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next lot

    v_expiration_date := TIMESTAMP '2024-11-10 06:49:40' + INTERVAL '240' DAY;
    v_quantity_to_create := ROUND(0.6, 1);

    INSERT INTO packaged (Instance_ID, Lot_Number, Expiration_Date, Quantity) -- Assuming 'packaged' table name
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Serialized' THEN
    -- Assign a unique serial number
    -- Using Instance ID guarantees uniqueness within this context
    v_serial_number := 'SN-' || TO_CHAR(601.0) || '-' || TO_CHAR(v_new_child_instance_id) || '-' || SUBSTR(SYS_GUID(),1,8);
    -- Assign a batch number - use Product_ID of the *parent* instance as the batch for simplicity? Or a sequence?
    -- Let's use the Parent_IID itself as a simple batch identifier for this run.
    v_batch_number := 351.0; -- All children created FOR this parent get same batch number

    INSERT INTO serialized (Instance_ID, Serial_Number, Batch_Number)
    VALUES (v_new_child_instance_id, v_serial_number, v_batch_number);

    -- Quantity for usesComponent link for serialized is typically 1
    v_quantity_to_create := 1;

  END IF;

  -- Step 3: Create the usesComponent link
  -- Quantity_Used is the Quantity_Needed from needsComponent (which matches child quantity for non-serialized)
  IF v_child_category IN ('Commodity', 'Packaged', 'Serialized') THEN -- Only insert if subtype was handled
      INSERT INTO usesComponent (Parent_IID, Child_IID, Quantity_Used)
      VALUES (351.0, v_new_child_instance_id, ROUND(0.6, 1)); -- Use rounded quantity needed
  END IF;

EXCEPTION
  WHEN OTHERS THEN
    DBMS_OUTPUT.PUT_LINE('Error processing Parent_IID=' || 351.0 || ', Child_PID=' || 601.0 || ': ' || SQLERRM);
    -- Decide if you want to rollback just this block or let the main exception handler catch it
END;
/
DECLARE
  v_new_child_instance_id productInstance.Instance_ID%TYPE;
  v_child_category        product.Category%TYPE := 'Commodity'; -- Pass category
  v_max_existing_batch_lot NUMBER;
  v_next_batch_lot_num   NUMBER;
  v_serial_number        serialized.Serial_Number%TYPE;
  v_batch_number         serialized.Batch_Number%TYPE; -- Shared batch for serialized children of *this* parent
  v_expiration_date      commodity.Expiration_Date%TYPE;
  v_quantity_to_create   commodity.Quantity%TYPE; -- Quantity for the new child instance

BEGIN
  -- Step 1: Create the new child productInstance
  INSERT INTO productInstance (Product_ID, Date_Manufactured, Is_Recalled)
  VALUES (601.0, TIMESTAMP '2024-09-04 05:46:58', 0)
  RETURNING Instance_ID INTO v_new_child_instance_id;

  -- Step 2: Create the corresponding subtype record
  IF v_child_category = 'Commodity' THEN
    -- Find max existing Batch_Number for this specific Child_PID
    SELECT NVL(MAX(c.Batch_Number), 0) INTO v_max_existing_batch_lot
    FROM commodity c JOIN productInstance pi ON c.Instance_ID = pi.Instance_ID
    WHERE pi.Product_ID = 601.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next batch

    v_expiration_date := TIMESTAMP '2024-09-04 05:46:58' + INTERVAL '376' DAY;
    v_quantity_to_create := ROUND(0.6, 1);

    INSERT INTO commodity (Instance_ID, Batch_Number, Expiration_Date, Quantity)
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Packaged' THEN
    -- Find max existing Lot_Number for this specific Child_PID
    SELECT NVL(MAX(p.Lot_Number), 0) INTO v_max_existing_batch_lot
    FROM packaged p JOIN productInstance pi ON p.Instance_ID = pi.Instance_ID -- Assuming 'packaged' table name
    WHERE pi.Product_ID = 601.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next lot

    v_expiration_date := TIMESTAMP '2024-09-04 05:46:58' + INTERVAL '551' DAY;
    v_quantity_to_create := ROUND(0.6, 1);

    INSERT INTO packaged (Instance_ID, Lot_Number, Expiration_Date, Quantity) -- Assuming 'packaged' table name
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Serialized' THEN
    -- Assign a unique serial number
    -- Using Instance ID guarantees uniqueness within this context
    v_serial_number := 'SN-' || TO_CHAR(601.0) || '-' || TO_CHAR(v_new_child_instance_id) || '-' || SUBSTR(SYS_GUID(),1,8);
    -- Assign a batch number - use Product_ID of the *parent* instance as the batch for simplicity? Or a sequence?
    -- Let's use the Parent_IID itself as a simple batch identifier for this run.
    v_batch_number := 352.0; -- All children created FOR this parent get same batch number

    INSERT INTO serialized (Instance_ID, Serial_Number, Batch_Number)
    VALUES (v_new_child_instance_id, v_serial_number, v_batch_number);

    -- Quantity for usesComponent link for serialized is typically 1
    v_quantity_to_create := 1;

  END IF;

  -- Step 3: Create the usesComponent link
  -- Quantity_Used is the Quantity_Needed from needsComponent (which matches child quantity for non-serialized)
  IF v_child_category IN ('Commodity', 'Packaged', 'Serialized') THEN -- Only insert if subtype was handled
      INSERT INTO usesComponent (Parent_IID, Child_IID, Quantity_Used)
      VALUES (352.0, v_new_child_instance_id, ROUND(0.6, 1)); -- Use rounded quantity needed
  END IF;

EXCEPTION
  WHEN OTHERS THEN
    DBMS_OUTPUT.PUT_LINE('Error processing Parent_IID=' || 352.0 || ', Child_PID=' || 601.0 || ': ' || SQLERRM);
    -- Decide if you want to rollback just this block or let the main exception handler catch it
END;
/
DECLARE
  v_new_child_instance_id productInstance.Instance_ID%TYPE;
  v_child_category        product.Category%TYPE := 'Commodity'; -- Pass category
  v_max_existing_batch_lot NUMBER;
  v_next_batch_lot_num   NUMBER;
  v_serial_number        serialized.Serial_Number%TYPE;
  v_batch_number         serialized.Batch_Number%TYPE; -- Shared batch for serialized children of *this* parent
  v_expiration_date      commodity.Expiration_Date%TYPE;
  v_quantity_to_create   commodity.Quantity%TYPE; -- Quantity for the new child instance

BEGIN
  -- Step 1: Create the new child productInstance
  INSERT INTO productInstance (Product_ID, Date_Manufactured, Is_Recalled)
  VALUES (601.0, TIMESTAMP '2025-02-27 08:50:31', 0)
  RETURNING Instance_ID INTO v_new_child_instance_id;

  -- Step 2: Create the corresponding subtype record
  IF v_child_category = 'Commodity' THEN
    -- Find max existing Batch_Number for this specific Child_PID
    SELECT NVL(MAX(c.Batch_Number), 0) INTO v_max_existing_batch_lot
    FROM commodity c JOIN productInstance pi ON c.Instance_ID = pi.Instance_ID
    WHERE pi.Product_ID = 601.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next batch

    v_expiration_date := TIMESTAMP '2025-02-27 08:50:31' + INTERVAL '430' DAY;
    v_quantity_to_create := ROUND(1.0, 1);

    INSERT INTO commodity (Instance_ID, Batch_Number, Expiration_Date, Quantity)
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Packaged' THEN
    -- Find max existing Lot_Number for this specific Child_PID
    SELECT NVL(MAX(p.Lot_Number), 0) INTO v_max_existing_batch_lot
    FROM packaged p JOIN productInstance pi ON p.Instance_ID = pi.Instance_ID -- Assuming 'packaged' table name
    WHERE pi.Product_ID = 601.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next lot

    v_expiration_date := TIMESTAMP '2025-02-27 08:50:31' + INTERVAL '628' DAY;
    v_quantity_to_create := ROUND(1.0, 1);

    INSERT INTO packaged (Instance_ID, Lot_Number, Expiration_Date, Quantity) -- Assuming 'packaged' table name
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Serialized' THEN
    -- Assign a unique serial number
    -- Using Instance ID guarantees uniqueness within this context
    v_serial_number := 'SN-' || TO_CHAR(601.0) || '-' || TO_CHAR(v_new_child_instance_id) || '-' || SUBSTR(SYS_GUID(),1,8);
    -- Assign a batch number - use Product_ID of the *parent* instance as the batch for simplicity? Or a sequence?
    -- Let's use the Parent_IID itself as a simple batch identifier for this run.
    v_batch_number := 358.0; -- All children created FOR this parent get same batch number

    INSERT INTO serialized (Instance_ID, Serial_Number, Batch_Number)
    VALUES (v_new_child_instance_id, v_serial_number, v_batch_number);

    -- Quantity for usesComponent link for serialized is typically 1
    v_quantity_to_create := 1;

  END IF;

  -- Step 3: Create the usesComponent link
  -- Quantity_Used is the Quantity_Needed from needsComponent (which matches child quantity for non-serialized)
  IF v_child_category IN ('Commodity', 'Packaged', 'Serialized') THEN -- Only insert if subtype was handled
      INSERT INTO usesComponent (Parent_IID, Child_IID, Quantity_Used)
      VALUES (358.0, v_new_child_instance_id, ROUND(1.0, 1)); -- Use rounded quantity needed
  END IF;

EXCEPTION
  WHEN OTHERS THEN
    DBMS_OUTPUT.PUT_LINE('Error processing Parent_IID=' || 358.0 || ', Child_PID=' || 601.0 || ': ' || SQLERRM);
    -- Decide if you want to rollback just this block or let the main exception handler catch it
END;
/
DECLARE
  v_new_child_instance_id productInstance.Instance_ID%TYPE;
  v_child_category        product.Category%TYPE := 'Commodity'; -- Pass category
  v_max_existing_batch_lot NUMBER;
  v_next_batch_lot_num   NUMBER;
  v_serial_number        serialized.Serial_Number%TYPE;
  v_batch_number         serialized.Batch_Number%TYPE; -- Shared batch for serialized children of *this* parent
  v_expiration_date      commodity.Expiration_Date%TYPE;
  v_quantity_to_create   commodity.Quantity%TYPE; -- Quantity for the new child instance

BEGIN
  -- Step 1: Create the new child productInstance
  INSERT INTO productInstance (Product_ID, Date_Manufactured, Is_Recalled)
  VALUES (601.0, TIMESTAMP '2024-11-01 21:37:36', 0)
  RETURNING Instance_ID INTO v_new_child_instance_id;

  -- Step 2: Create the corresponding subtype record
  IF v_child_category = 'Commodity' THEN
    -- Find max existing Batch_Number for this specific Child_PID
    SELECT NVL(MAX(c.Batch_Number), 0) INTO v_max_existing_batch_lot
    FROM commodity c JOIN productInstance pi ON c.Instance_ID = pi.Instance_ID
    WHERE pi.Product_ID = 601.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next batch

    v_expiration_date := TIMESTAMP '2024-11-01 21:37:36' + INTERVAL '137' DAY;
    v_quantity_to_create := ROUND(1.0, 1);

    INSERT INTO commodity (Instance_ID, Batch_Number, Expiration_Date, Quantity)
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Packaged' THEN
    -- Find max existing Lot_Number for this specific Child_PID
    SELECT NVL(MAX(p.Lot_Number), 0) INTO v_max_existing_batch_lot
    FROM packaged p JOIN productInstance pi ON p.Instance_ID = pi.Instance_ID -- Assuming 'packaged' table name
    WHERE pi.Product_ID = 601.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next lot

    v_expiration_date := TIMESTAMP '2024-11-01 21:37:36' + INTERVAL '162' DAY;
    v_quantity_to_create := ROUND(1.0, 1);

    INSERT INTO packaged (Instance_ID, Lot_Number, Expiration_Date, Quantity) -- Assuming 'packaged' table name
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Serialized' THEN
    -- Assign a unique serial number
    -- Using Instance ID guarantees uniqueness within this context
    v_serial_number := 'SN-' || TO_CHAR(601.0) || '-' || TO_CHAR(v_new_child_instance_id) || '-' || SUBSTR(SYS_GUID(),1,8);
    -- Assign a batch number - use Product_ID of the *parent* instance as the batch for simplicity? Or a sequence?
    -- Let's use the Parent_IID itself as a simple batch identifier for this run.
    v_batch_number := 359.0; -- All children created FOR this parent get same batch number

    INSERT INTO serialized (Instance_ID, Serial_Number, Batch_Number)
    VALUES (v_new_child_instance_id, v_serial_number, v_batch_number);

    -- Quantity for usesComponent link for serialized is typically 1
    v_quantity_to_create := 1;

  END IF;

  -- Step 3: Create the usesComponent link
  -- Quantity_Used is the Quantity_Needed from needsComponent (which matches child quantity for non-serialized)
  IF v_child_category IN ('Commodity', 'Packaged', 'Serialized') THEN -- Only insert if subtype was handled
      INSERT INTO usesComponent (Parent_IID, Child_IID, Quantity_Used)
      VALUES (359.0, v_new_child_instance_id, ROUND(1.0, 1)); -- Use rounded quantity needed
  END IF;

EXCEPTION
  WHEN OTHERS THEN
    DBMS_OUTPUT.PUT_LINE('Error processing Parent_IID=' || 359.0 || ', Child_PID=' || 601.0 || ': ' || SQLERRM);
    -- Decide if you want to rollback just this block or let the main exception handler catch it
END;
/
DECLARE
  v_new_child_instance_id productInstance.Instance_ID%TYPE;
  v_child_category        product.Category%TYPE := 'Commodity'; -- Pass category
  v_max_existing_batch_lot NUMBER;
  v_next_batch_lot_num   NUMBER;
  v_serial_number        serialized.Serial_Number%TYPE;
  v_batch_number         serialized.Batch_Number%TYPE; -- Shared batch for serialized children of *this* parent
  v_expiration_date      commodity.Expiration_Date%TYPE;
  v_quantity_to_create   commodity.Quantity%TYPE; -- Quantity for the new child instance

BEGIN
  -- Step 1: Create the new child productInstance
  INSERT INTO productInstance (Product_ID, Date_Manufactured, Is_Recalled)
  VALUES (190.0, TIMESTAMP '2025-01-07 11:24:01', 0)
  RETURNING Instance_ID INTO v_new_child_instance_id;

  -- Step 2: Create the corresponding subtype record
  IF v_child_category = 'Commodity' THEN
    -- Find max existing Batch_Number for this specific Child_PID
    SELECT NVL(MAX(c.Batch_Number), 0) INTO v_max_existing_batch_lot
    FROM commodity c JOIN productInstance pi ON c.Instance_ID = pi.Instance_ID
    WHERE pi.Product_ID = 190.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next batch

    v_expiration_date := TIMESTAMP '2025-01-07 11:24:01' + INTERVAL '489' DAY;
    v_quantity_to_create := ROUND(1.9, 1);

    INSERT INTO commodity (Instance_ID, Batch_Number, Expiration_Date, Quantity)
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Packaged' THEN
    -- Find max existing Lot_Number for this specific Child_PID
    SELECT NVL(MAX(p.Lot_Number), 0) INTO v_max_existing_batch_lot
    FROM packaged p JOIN productInstance pi ON p.Instance_ID = pi.Instance_ID -- Assuming 'packaged' table name
    WHERE pi.Product_ID = 190.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next lot

    v_expiration_date := TIMESTAMP '2025-01-07 11:24:01' + INTERVAL '566' DAY;
    v_quantity_to_create := ROUND(1.9, 1);

    INSERT INTO packaged (Instance_ID, Lot_Number, Expiration_Date, Quantity) -- Assuming 'packaged' table name
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Serialized' THEN
    -- Assign a unique serial number
    -- Using Instance ID guarantees uniqueness within this context
    v_serial_number := 'SN-' || TO_CHAR(190.0) || '-' || TO_CHAR(v_new_child_instance_id) || '-' || SUBSTR(SYS_GUID(),1,8);
    -- Assign a batch number - use Product_ID of the *parent* instance as the batch for simplicity? Or a sequence?
    -- Let's use the Parent_IID itself as a simple batch identifier for this run.
    v_batch_number := 382.0; -- All children created FOR this parent get same batch number

    INSERT INTO serialized (Instance_ID, Serial_Number, Batch_Number)
    VALUES (v_new_child_instance_id, v_serial_number, v_batch_number);

    -- Quantity for usesComponent link for serialized is typically 1
    v_quantity_to_create := 1;

  END IF;

  -- Step 3: Create the usesComponent link
  -- Quantity_Used is the Quantity_Needed from needsComponent (which matches child quantity for non-serialized)
  IF v_child_category IN ('Commodity', 'Packaged', 'Serialized') THEN -- Only insert if subtype was handled
      INSERT INTO usesComponent (Parent_IID, Child_IID, Quantity_Used)
      VALUES (382.0, v_new_child_instance_id, ROUND(1.9, 1)); -- Use rounded quantity needed
  END IF;

EXCEPTION
  WHEN OTHERS THEN
    DBMS_OUTPUT.PUT_LINE('Error processing Parent_IID=' || 382.0 || ', Child_PID=' || 190.0 || ': ' || SQLERRM);
    -- Decide if you want to rollback just this block or let the main exception handler catch it
END;
/
DECLARE
  v_new_child_instance_id productInstance.Instance_ID%TYPE;
  v_child_category        product.Category%TYPE := 'Commodity'; -- Pass category
  v_max_existing_batch_lot NUMBER;
  v_next_batch_lot_num   NUMBER;
  v_serial_number        serialized.Serial_Number%TYPE;
  v_batch_number         serialized.Batch_Number%TYPE; -- Shared batch for serialized children of *this* parent
  v_expiration_date      commodity.Expiration_Date%TYPE;
  v_quantity_to_create   commodity.Quantity%TYPE; -- Quantity for the new child instance

BEGIN
  -- Step 1: Create the new child productInstance
  INSERT INTO productInstance (Product_ID, Date_Manufactured, Is_Recalled)
  VALUES (178.0, TIMESTAMP '2024-12-01 23:55:15', 0)
  RETURNING Instance_ID INTO v_new_child_instance_id;

  -- Step 2: Create the corresponding subtype record
  IF v_child_category = 'Commodity' THEN
    -- Find max existing Batch_Number for this specific Child_PID
    SELECT NVL(MAX(c.Batch_Number), 0) INTO v_max_existing_batch_lot
    FROM commodity c JOIN productInstance pi ON c.Instance_ID = pi.Instance_ID
    WHERE pi.Product_ID = 178.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next batch

    v_expiration_date := TIMESTAMP '2024-12-01 23:55:15' + INTERVAL '625' DAY;
    v_quantity_to_create := ROUND(1.8, 1);

    INSERT INTO commodity (Instance_ID, Batch_Number, Expiration_Date, Quantity)
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Packaged' THEN
    -- Find max existing Lot_Number for this specific Child_PID
    SELECT NVL(MAX(p.Lot_Number), 0) INTO v_max_existing_batch_lot
    FROM packaged p JOIN productInstance pi ON p.Instance_ID = pi.Instance_ID -- Assuming 'packaged' table name
    WHERE pi.Product_ID = 178.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next lot

    v_expiration_date := TIMESTAMP '2024-12-01 23:55:15' + INTERVAL '562' DAY;
    v_quantity_to_create := ROUND(1.8, 1);

    INSERT INTO packaged (Instance_ID, Lot_Number, Expiration_Date, Quantity) -- Assuming 'packaged' table name
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Serialized' THEN
    -- Assign a unique serial number
    -- Using Instance ID guarantees uniqueness within this context
    v_serial_number := 'SN-' || TO_CHAR(178.0) || '-' || TO_CHAR(v_new_child_instance_id) || '-' || SUBSTR(SYS_GUID(),1,8);
    -- Assign a batch number - use Product_ID of the *parent* instance as the batch for simplicity? Or a sequence?
    -- Let's use the Parent_IID itself as a simple batch identifier for this run.
    v_batch_number := 382.0; -- All children created FOR this parent get same batch number

    INSERT INTO serialized (Instance_ID, Serial_Number, Batch_Number)
    VALUES (v_new_child_instance_id, v_serial_number, v_batch_number);

    -- Quantity for usesComponent link for serialized is typically 1
    v_quantity_to_create := 1;

  END IF;

  -- Step 3: Create the usesComponent link
  -- Quantity_Used is the Quantity_Needed from needsComponent (which matches child quantity for non-serialized)
  IF v_child_category IN ('Commodity', 'Packaged', 'Serialized') THEN -- Only insert if subtype was handled
      INSERT INTO usesComponent (Parent_IID, Child_IID, Quantity_Used)
      VALUES (382.0, v_new_child_instance_id, ROUND(1.8, 1)); -- Use rounded quantity needed
  END IF;

EXCEPTION
  WHEN OTHERS THEN
    DBMS_OUTPUT.PUT_LINE('Error processing Parent_IID=' || 382.0 || ', Child_PID=' || 178.0 || ': ' || SQLERRM);
    -- Decide if you want to rollback just this block or let the main exception handler catch it
END;
/
DECLARE
  v_new_child_instance_id productInstance.Instance_ID%TYPE;
  v_child_category        product.Category%TYPE := 'Commodity'; -- Pass category
  v_max_existing_batch_lot NUMBER;
  v_next_batch_lot_num   NUMBER;
  v_serial_number        serialized.Serial_Number%TYPE;
  v_batch_number         serialized.Batch_Number%TYPE; -- Shared batch for serialized children of *this* parent
  v_expiration_date      commodity.Expiration_Date%TYPE;
  v_quantity_to_create   commodity.Quantity%TYPE; -- Quantity for the new child instance

BEGIN
  -- Step 1: Create the new child productInstance
  INSERT INTO productInstance (Product_ID, Date_Manufactured, Is_Recalled)
  VALUES (190.0, TIMESTAMP '2024-11-23 01:17:31', 0)
  RETURNING Instance_ID INTO v_new_child_instance_id;

  -- Step 2: Create the corresponding subtype record
  IF v_child_category = 'Commodity' THEN
    -- Find max existing Batch_Number for this specific Child_PID
    SELECT NVL(MAX(c.Batch_Number), 0) INTO v_max_existing_batch_lot
    FROM commodity c JOIN productInstance pi ON c.Instance_ID = pi.Instance_ID
    WHERE pi.Product_ID = 190.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next batch

    v_expiration_date := TIMESTAMP '2024-11-23 01:17:31' + INTERVAL '60' DAY;
    v_quantity_to_create := ROUND(1.9, 1);

    INSERT INTO commodity (Instance_ID, Batch_Number, Expiration_Date, Quantity)
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Packaged' THEN
    -- Find max existing Lot_Number for this specific Child_PID
    SELECT NVL(MAX(p.Lot_Number), 0) INTO v_max_existing_batch_lot
    FROM packaged p JOIN productInstance pi ON p.Instance_ID = pi.Instance_ID -- Assuming 'packaged' table name
    WHERE pi.Product_ID = 190.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next lot

    v_expiration_date := TIMESTAMP '2024-11-23 01:17:31' + INTERVAL '328' DAY;
    v_quantity_to_create := ROUND(1.9, 1);

    INSERT INTO packaged (Instance_ID, Lot_Number, Expiration_Date, Quantity) -- Assuming 'packaged' table name
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Serialized' THEN
    -- Assign a unique serial number
    -- Using Instance ID guarantees uniqueness within this context
    v_serial_number := 'SN-' || TO_CHAR(190.0) || '-' || TO_CHAR(v_new_child_instance_id) || '-' || SUBSTR(SYS_GUID(),1,8);
    -- Assign a batch number - use Product_ID of the *parent* instance as the batch for simplicity? Or a sequence?
    -- Let's use the Parent_IID itself as a simple batch identifier for this run.
    v_batch_number := 383.0; -- All children created FOR this parent get same batch number

    INSERT INTO serialized (Instance_ID, Serial_Number, Batch_Number)
    VALUES (v_new_child_instance_id, v_serial_number, v_batch_number);

    -- Quantity for usesComponent link for serialized is typically 1
    v_quantity_to_create := 1;

  END IF;

  -- Step 3: Create the usesComponent link
  -- Quantity_Used is the Quantity_Needed from needsComponent (which matches child quantity for non-serialized)
  IF v_child_category IN ('Commodity', 'Packaged', 'Serialized') THEN -- Only insert if subtype was handled
      INSERT INTO usesComponent (Parent_IID, Child_IID, Quantity_Used)
      VALUES (383.0, v_new_child_instance_id, ROUND(1.9, 1)); -- Use rounded quantity needed
  END IF;

EXCEPTION
  WHEN OTHERS THEN
    DBMS_OUTPUT.PUT_LINE('Error processing Parent_IID=' || 383.0 || ', Child_PID=' || 190.0 || ': ' || SQLERRM);
    -- Decide if you want to rollback just this block or let the main exception handler catch it
END;
/
DECLARE
  v_new_child_instance_id productInstance.Instance_ID%TYPE;
  v_child_category        product.Category%TYPE := 'Commodity'; -- Pass category
  v_max_existing_batch_lot NUMBER;
  v_next_batch_lot_num   NUMBER;
  v_serial_number        serialized.Serial_Number%TYPE;
  v_batch_number         serialized.Batch_Number%TYPE; -- Shared batch for serialized children of *this* parent
  v_expiration_date      commodity.Expiration_Date%TYPE;
  v_quantity_to_create   commodity.Quantity%TYPE; -- Quantity for the new child instance

BEGIN
  -- Step 1: Create the new child productInstance
  INSERT INTO productInstance (Product_ID, Date_Manufactured, Is_Recalled)
  VALUES (178.0, TIMESTAMP '2025-02-11 15:53:15', 0)
  RETURNING Instance_ID INTO v_new_child_instance_id;

  -- Step 2: Create the corresponding subtype record
  IF v_child_category = 'Commodity' THEN
    -- Find max existing Batch_Number for this specific Child_PID
    SELECT NVL(MAX(c.Batch_Number), 0) INTO v_max_existing_batch_lot
    FROM commodity c JOIN productInstance pi ON c.Instance_ID = pi.Instance_ID
    WHERE pi.Product_ID = 178.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next batch

    v_expiration_date := TIMESTAMP '2025-02-11 15:53:15' + INTERVAL '190' DAY;
    v_quantity_to_create := ROUND(1.8, 1);

    INSERT INTO commodity (Instance_ID, Batch_Number, Expiration_Date, Quantity)
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Packaged' THEN
    -- Find max existing Lot_Number for this specific Child_PID
    SELECT NVL(MAX(p.Lot_Number), 0) INTO v_max_existing_batch_lot
    FROM packaged p JOIN productInstance pi ON p.Instance_ID = pi.Instance_ID -- Assuming 'packaged' table name
    WHERE pi.Product_ID = 178.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next lot

    v_expiration_date := TIMESTAMP '2025-02-11 15:53:15' + INTERVAL '234' DAY;
    v_quantity_to_create := ROUND(1.8, 1);

    INSERT INTO packaged (Instance_ID, Lot_Number, Expiration_Date, Quantity) -- Assuming 'packaged' table name
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Serialized' THEN
    -- Assign a unique serial number
    -- Using Instance ID guarantees uniqueness within this context
    v_serial_number := 'SN-' || TO_CHAR(178.0) || '-' || TO_CHAR(v_new_child_instance_id) || '-' || SUBSTR(SYS_GUID(),1,8);
    -- Assign a batch number - use Product_ID of the *parent* instance as the batch for simplicity? Or a sequence?
    -- Let's use the Parent_IID itself as a simple batch identifier for this run.
    v_batch_number := 383.0; -- All children created FOR this parent get same batch number

    INSERT INTO serialized (Instance_ID, Serial_Number, Batch_Number)
    VALUES (v_new_child_instance_id, v_serial_number, v_batch_number);

    -- Quantity for usesComponent link for serialized is typically 1
    v_quantity_to_create := 1;

  END IF;

  -- Step 3: Create the usesComponent link
  -- Quantity_Used is the Quantity_Needed from needsComponent (which matches child quantity for non-serialized)
  IF v_child_category IN ('Commodity', 'Packaged', 'Serialized') THEN -- Only insert if subtype was handled
      INSERT INTO usesComponent (Parent_IID, Child_IID, Quantity_Used)
      VALUES (383.0, v_new_child_instance_id, ROUND(1.8, 1)); -- Use rounded quantity needed
  END IF;

EXCEPTION
  WHEN OTHERS THEN
    DBMS_OUTPUT.PUT_LINE('Error processing Parent_IID=' || 383.0 || ', Child_PID=' || 178.0 || ': ' || SQLERRM);
    -- Decide if you want to rollback just this block or let the main exception handler catch it
END;
/
DECLARE
  v_new_child_instance_id productInstance.Instance_ID%TYPE;
  v_child_category        product.Category%TYPE := 'Commodity'; -- Pass category
  v_max_existing_batch_lot NUMBER;
  v_next_batch_lot_num   NUMBER;
  v_serial_number        serialized.Serial_Number%TYPE;
  v_batch_number         serialized.Batch_Number%TYPE; -- Shared batch for serialized children of *this* parent
  v_expiration_date      commodity.Expiration_Date%TYPE;
  v_quantity_to_create   commodity.Quantity%TYPE; -- Quantity for the new child instance

BEGIN
  -- Step 1: Create the new child productInstance
  INSERT INTO productInstance (Product_ID, Date_Manufactured, Is_Recalled)
  VALUES (222.0, TIMESTAMP '2024-09-19 20:53:26', 0)
  RETURNING Instance_ID INTO v_new_child_instance_id;

  -- Step 2: Create the corresponding subtype record
  IF v_child_category = 'Commodity' THEN
    -- Find max existing Batch_Number for this specific Child_PID
    SELECT NVL(MAX(c.Batch_Number), 0) INTO v_max_existing_batch_lot
    FROM commodity c JOIN productInstance pi ON c.Instance_ID = pi.Instance_ID
    WHERE pi.Product_ID = 222.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next batch

    v_expiration_date := TIMESTAMP '2024-09-19 20:53:26' + INTERVAL '428' DAY;
    v_quantity_to_create := ROUND(0.3, 1);

    INSERT INTO commodity (Instance_ID, Batch_Number, Expiration_Date, Quantity)
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Packaged' THEN
    -- Find max existing Lot_Number for this specific Child_PID
    SELECT NVL(MAX(p.Lot_Number), 0) INTO v_max_existing_batch_lot
    FROM packaged p JOIN productInstance pi ON p.Instance_ID = pi.Instance_ID -- Assuming 'packaged' table name
    WHERE pi.Product_ID = 222.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next lot

    v_expiration_date := TIMESTAMP '2024-09-19 20:53:26' + INTERVAL '563' DAY;
    v_quantity_to_create := ROUND(0.3, 1);

    INSERT INTO packaged (Instance_ID, Lot_Number, Expiration_Date, Quantity) -- Assuming 'packaged' table name
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Serialized' THEN
    -- Assign a unique serial number
    -- Using Instance ID guarantees uniqueness within this context
    v_serial_number := 'SN-' || TO_CHAR(222.0) || '-' || TO_CHAR(v_new_child_instance_id) || '-' || SUBSTR(SYS_GUID(),1,8);
    -- Assign a batch number - use Product_ID of the *parent* instance as the batch for simplicity? Or a sequence?
    -- Let's use the Parent_IID itself as a simple batch identifier for this run.
    v_batch_number := 402.0; -- All children created FOR this parent get same batch number

    INSERT INTO serialized (Instance_ID, Serial_Number, Batch_Number)
    VALUES (v_new_child_instance_id, v_serial_number, v_batch_number);

    -- Quantity for usesComponent link for serialized is typically 1
    v_quantity_to_create := 1;

  END IF;

  -- Step 3: Create the usesComponent link
  -- Quantity_Used is the Quantity_Needed from needsComponent (which matches child quantity for non-serialized)
  IF v_child_category IN ('Commodity', 'Packaged', 'Serialized') THEN -- Only insert if subtype was handled
      INSERT INTO usesComponent (Parent_IID, Child_IID, Quantity_Used)
      VALUES (402.0, v_new_child_instance_id, ROUND(0.3, 1)); -- Use rounded quantity needed
  END IF;

EXCEPTION
  WHEN OTHERS THEN
    DBMS_OUTPUT.PUT_LINE('Error processing Parent_IID=' || 402.0 || ', Child_PID=' || 222.0 || ': ' || SQLERRM);
    -- Decide if you want to rollback just this block or let the main exception handler catch it
END;
/
DECLARE
  v_new_child_instance_id productInstance.Instance_ID%TYPE;
  v_child_category        product.Category%TYPE := 'Commodity'; -- Pass category
  v_max_existing_batch_lot NUMBER;
  v_next_batch_lot_num   NUMBER;
  v_serial_number        serialized.Serial_Number%TYPE;
  v_batch_number         serialized.Batch_Number%TYPE; -- Shared batch for serialized children of *this* parent
  v_expiration_date      commodity.Expiration_Date%TYPE;
  v_quantity_to_create   commodity.Quantity%TYPE; -- Quantity for the new child instance

BEGIN
  -- Step 1: Create the new child productInstance
  INSERT INTO productInstance (Product_ID, Date_Manufactured, Is_Recalled)
  VALUES (204.0, TIMESTAMP '2024-09-01 22:54:50', 0)
  RETURNING Instance_ID INTO v_new_child_instance_id;

  -- Step 2: Create the corresponding subtype record
  IF v_child_category = 'Commodity' THEN
    -- Find max existing Batch_Number for this specific Child_PID
    SELECT NVL(MAX(c.Batch_Number), 0) INTO v_max_existing_batch_lot
    FROM commodity c JOIN productInstance pi ON c.Instance_ID = pi.Instance_ID
    WHERE pi.Product_ID = 204.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next batch

    v_expiration_date := TIMESTAMP '2024-09-01 22:54:50' + INTERVAL '129' DAY;
    v_quantity_to_create := ROUND(1.2, 1);

    INSERT INTO commodity (Instance_ID, Batch_Number, Expiration_Date, Quantity)
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Packaged' THEN
    -- Find max existing Lot_Number for this specific Child_PID
    SELECT NVL(MAX(p.Lot_Number), 0) INTO v_max_existing_batch_lot
    FROM packaged p JOIN productInstance pi ON p.Instance_ID = pi.Instance_ID -- Assuming 'packaged' table name
    WHERE pi.Product_ID = 204.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next lot

    v_expiration_date := TIMESTAMP '2024-09-01 22:54:50' + INTERVAL '449' DAY;
    v_quantity_to_create := ROUND(1.2, 1);

    INSERT INTO packaged (Instance_ID, Lot_Number, Expiration_Date, Quantity) -- Assuming 'packaged' table name
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Serialized' THEN
    -- Assign a unique serial number
    -- Using Instance ID guarantees uniqueness within this context
    v_serial_number := 'SN-' || TO_CHAR(204.0) || '-' || TO_CHAR(v_new_child_instance_id) || '-' || SUBSTR(SYS_GUID(),1,8);
    -- Assign a batch number - use Product_ID of the *parent* instance as the batch for simplicity? Or a sequence?
    -- Let's use the Parent_IID itself as a simple batch identifier for this run.
    v_batch_number := 402.0; -- All children created FOR this parent get same batch number

    INSERT INTO serialized (Instance_ID, Serial_Number, Batch_Number)
    VALUES (v_new_child_instance_id, v_serial_number, v_batch_number);

    -- Quantity for usesComponent link for serialized is typically 1
    v_quantity_to_create := 1;

  END IF;

  -- Step 3: Create the usesComponent link
  -- Quantity_Used is the Quantity_Needed from needsComponent (which matches child quantity for non-serialized)
  IF v_child_category IN ('Commodity', 'Packaged', 'Serialized') THEN -- Only insert if subtype was handled
      INSERT INTO usesComponent (Parent_IID, Child_IID, Quantity_Used)
      VALUES (402.0, v_new_child_instance_id, ROUND(1.2, 1)); -- Use rounded quantity needed
  END IF;

EXCEPTION
  WHEN OTHERS THEN
    DBMS_OUTPUT.PUT_LINE('Error processing Parent_IID=' || 402.0 || ', Child_PID=' || 204.0 || ': ' || SQLERRM);
    -- Decide if you want to rollback just this block or let the main exception handler catch it
END;
/
DECLARE
  v_new_child_instance_id productInstance.Instance_ID%TYPE;
  v_child_category        product.Category%TYPE := 'Commodity'; -- Pass category
  v_max_existing_batch_lot NUMBER;
  v_next_batch_lot_num   NUMBER;
  v_serial_number        serialized.Serial_Number%TYPE;
  v_batch_number         serialized.Batch_Number%TYPE; -- Shared batch for serialized children of *this* parent
  v_expiration_date      commodity.Expiration_Date%TYPE;
  v_quantity_to_create   commodity.Quantity%TYPE; -- Quantity for the new child instance

BEGIN
  -- Step 1: Create the new child productInstance
  INSERT INTO productInstance (Product_ID, Date_Manufactured, Is_Recalled)
  VALUES (244.0, TIMESTAMP '2024-09-10 04:07:45', 0)
  RETURNING Instance_ID INTO v_new_child_instance_id;

  -- Step 2: Create the corresponding subtype record
  IF v_child_category = 'Commodity' THEN
    -- Find max existing Batch_Number for this specific Child_PID
    SELECT NVL(MAX(c.Batch_Number), 0) INTO v_max_existing_batch_lot
    FROM commodity c JOIN productInstance pi ON c.Instance_ID = pi.Instance_ID
    WHERE pi.Product_ID = 244.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next batch

    v_expiration_date := TIMESTAMP '2024-09-10 04:07:45' + INTERVAL '159' DAY;
    v_quantity_to_create := ROUND(1.8, 1);

    INSERT INTO commodity (Instance_ID, Batch_Number, Expiration_Date, Quantity)
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Packaged' THEN
    -- Find max existing Lot_Number for this specific Child_PID
    SELECT NVL(MAX(p.Lot_Number), 0) INTO v_max_existing_batch_lot
    FROM packaged p JOIN productInstance pi ON p.Instance_ID = pi.Instance_ID -- Assuming 'packaged' table name
    WHERE pi.Product_ID = 244.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next lot

    v_expiration_date := TIMESTAMP '2024-09-10 04:07:45' + INTERVAL '618' DAY;
    v_quantity_to_create := ROUND(1.8, 1);

    INSERT INTO packaged (Instance_ID, Lot_Number, Expiration_Date, Quantity) -- Assuming 'packaged' table name
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Serialized' THEN
    -- Assign a unique serial number
    -- Using Instance ID guarantees uniqueness within this context
    v_serial_number := 'SN-' || TO_CHAR(244.0) || '-' || TO_CHAR(v_new_child_instance_id) || '-' || SUBSTR(SYS_GUID(),1,8);
    -- Assign a batch number - use Product_ID of the *parent* instance as the batch for simplicity? Or a sequence?
    -- Let's use the Parent_IID itself as a simple batch identifier for this run.
    v_batch_number := 402.0; -- All children created FOR this parent get same batch number

    INSERT INTO serialized (Instance_ID, Serial_Number, Batch_Number)
    VALUES (v_new_child_instance_id, v_serial_number, v_batch_number);

    -- Quantity for usesComponent link for serialized is typically 1
    v_quantity_to_create := 1;

  END IF;

  -- Step 3: Create the usesComponent link
  -- Quantity_Used is the Quantity_Needed from needsComponent (which matches child quantity for non-serialized)
  IF v_child_category IN ('Commodity', 'Packaged', 'Serialized') THEN -- Only insert if subtype was handled
      INSERT INTO usesComponent (Parent_IID, Child_IID, Quantity_Used)
      VALUES (402.0, v_new_child_instance_id, ROUND(1.8, 1)); -- Use rounded quantity needed
  END IF;

EXCEPTION
  WHEN OTHERS THEN
    DBMS_OUTPUT.PUT_LINE('Error processing Parent_IID=' || 402.0 || ', Child_PID=' || 244.0 || ': ' || SQLERRM);
    -- Decide if you want to rollback just this block or let the main exception handler catch it
END;
/
DECLARE
  v_new_child_instance_id productInstance.Instance_ID%TYPE;
  v_child_category        product.Category%TYPE := 'Commodity'; -- Pass category
  v_max_existing_batch_lot NUMBER;
  v_next_batch_lot_num   NUMBER;
  v_serial_number        serialized.Serial_Number%TYPE;
  v_batch_number         serialized.Batch_Number%TYPE; -- Shared batch for serialized children of *this* parent
  v_expiration_date      commodity.Expiration_Date%TYPE;
  v_quantity_to_create   commodity.Quantity%TYPE; -- Quantity for the new child instance

BEGIN
  -- Step 1: Create the new child productInstance
  INSERT INTO productInstance (Product_ID, Date_Manufactured, Is_Recalled)
  VALUES (222.0, TIMESTAMP '2024-05-24 05:31:36', 0)
  RETURNING Instance_ID INTO v_new_child_instance_id;

  -- Step 2: Create the corresponding subtype record
  IF v_child_category = 'Commodity' THEN
    -- Find max existing Batch_Number for this specific Child_PID
    SELECT NVL(MAX(c.Batch_Number), 0) INTO v_max_existing_batch_lot
    FROM commodity c JOIN productInstance pi ON c.Instance_ID = pi.Instance_ID
    WHERE pi.Product_ID = 222.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next batch

    v_expiration_date := TIMESTAMP '2024-05-24 05:31:36' + INTERVAL '74' DAY;
    v_quantity_to_create := ROUND(0.3, 1);

    INSERT INTO commodity (Instance_ID, Batch_Number, Expiration_Date, Quantity)
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Packaged' THEN
    -- Find max existing Lot_Number for this specific Child_PID
    SELECT NVL(MAX(p.Lot_Number), 0) INTO v_max_existing_batch_lot
    FROM packaged p JOIN productInstance pi ON p.Instance_ID = pi.Instance_ID -- Assuming 'packaged' table name
    WHERE pi.Product_ID = 222.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next lot

    v_expiration_date := TIMESTAMP '2024-05-24 05:31:36' + INTERVAL '337' DAY;
    v_quantity_to_create := ROUND(0.3, 1);

    INSERT INTO packaged (Instance_ID, Lot_Number, Expiration_Date, Quantity) -- Assuming 'packaged' table name
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Serialized' THEN
    -- Assign a unique serial number
    -- Using Instance ID guarantees uniqueness within this context
    v_serial_number := 'SN-' || TO_CHAR(222.0) || '-' || TO_CHAR(v_new_child_instance_id) || '-' || SUBSTR(SYS_GUID(),1,8);
    -- Assign a batch number - use Product_ID of the *parent* instance as the batch for simplicity? Or a sequence?
    -- Let's use the Parent_IID itself as a simple batch identifier for this run.
    v_batch_number := 403.0; -- All children created FOR this parent get same batch number

    INSERT INTO serialized (Instance_ID, Serial_Number, Batch_Number)
    VALUES (v_new_child_instance_id, v_serial_number, v_batch_number);

    -- Quantity for usesComponent link for serialized is typically 1
    v_quantity_to_create := 1;

  END IF;

  -- Step 3: Create the usesComponent link
  -- Quantity_Used is the Quantity_Needed from needsComponent (which matches child quantity for non-serialized)
  IF v_child_category IN ('Commodity', 'Packaged', 'Serialized') THEN -- Only insert if subtype was handled
      INSERT INTO usesComponent (Parent_IID, Child_IID, Quantity_Used)
      VALUES (403.0, v_new_child_instance_id, ROUND(0.3, 1)); -- Use rounded quantity needed
  END IF;

EXCEPTION
  WHEN OTHERS THEN
    DBMS_OUTPUT.PUT_LINE('Error processing Parent_IID=' || 403.0 || ', Child_PID=' || 222.0 || ': ' || SQLERRM);
    -- Decide if you want to rollback just this block or let the main exception handler catch it
END;
/
DECLARE
  v_new_child_instance_id productInstance.Instance_ID%TYPE;
  v_child_category        product.Category%TYPE := 'Commodity'; -- Pass category
  v_max_existing_batch_lot NUMBER;
  v_next_batch_lot_num   NUMBER;
  v_serial_number        serialized.Serial_Number%TYPE;
  v_batch_number         serialized.Batch_Number%TYPE; -- Shared batch for serialized children of *this* parent
  v_expiration_date      commodity.Expiration_Date%TYPE;
  v_quantity_to_create   commodity.Quantity%TYPE; -- Quantity for the new child instance

BEGIN
  -- Step 1: Create the new child productInstance
  INSERT INTO productInstance (Product_ID, Date_Manufactured, Is_Recalled)
  VALUES (204.0, TIMESTAMP '2025-03-11 12:49:59', 0)
  RETURNING Instance_ID INTO v_new_child_instance_id;

  -- Step 2: Create the corresponding subtype record
  IF v_child_category = 'Commodity' THEN
    -- Find max existing Batch_Number for this specific Child_PID
    SELECT NVL(MAX(c.Batch_Number), 0) INTO v_max_existing_batch_lot
    FROM commodity c JOIN productInstance pi ON c.Instance_ID = pi.Instance_ID
    WHERE pi.Product_ID = 204.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next batch

    v_expiration_date := TIMESTAMP '2025-03-11 12:49:59' + INTERVAL '696' DAY;
    v_quantity_to_create := ROUND(1.2, 1);

    INSERT INTO commodity (Instance_ID, Batch_Number, Expiration_Date, Quantity)
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Packaged' THEN
    -- Find max existing Lot_Number for this specific Child_PID
    SELECT NVL(MAX(p.Lot_Number), 0) INTO v_max_existing_batch_lot
    FROM packaged p JOIN productInstance pi ON p.Instance_ID = pi.Instance_ID -- Assuming 'packaged' table name
    WHERE pi.Product_ID = 204.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next lot

    v_expiration_date := TIMESTAMP '2025-03-11 12:49:59' + INTERVAL '576' DAY;
    v_quantity_to_create := ROUND(1.2, 1);

    INSERT INTO packaged (Instance_ID, Lot_Number, Expiration_Date, Quantity) -- Assuming 'packaged' table name
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Serialized' THEN
    -- Assign a unique serial number
    -- Using Instance ID guarantees uniqueness within this context
    v_serial_number := 'SN-' || TO_CHAR(204.0) || '-' || TO_CHAR(v_new_child_instance_id) || '-' || SUBSTR(SYS_GUID(),1,8);
    -- Assign a batch number - use Product_ID of the *parent* instance as the batch for simplicity? Or a sequence?
    -- Let's use the Parent_IID itself as a simple batch identifier for this run.
    v_batch_number := 403.0; -- All children created FOR this parent get same batch number

    INSERT INTO serialized (Instance_ID, Serial_Number, Batch_Number)
    VALUES (v_new_child_instance_id, v_serial_number, v_batch_number);

    -- Quantity for usesComponent link for serialized is typically 1
    v_quantity_to_create := 1;

  END IF;

  -- Step 3: Create the usesComponent link
  -- Quantity_Used is the Quantity_Needed from needsComponent (which matches child quantity for non-serialized)
  IF v_child_category IN ('Commodity', 'Packaged', 'Serialized') THEN -- Only insert if subtype was handled
      INSERT INTO usesComponent (Parent_IID, Child_IID, Quantity_Used)
      VALUES (403.0, v_new_child_instance_id, ROUND(1.2, 1)); -- Use rounded quantity needed
  END IF;

EXCEPTION
  WHEN OTHERS THEN
    DBMS_OUTPUT.PUT_LINE('Error processing Parent_IID=' || 403.0 || ', Child_PID=' || 204.0 || ': ' || SQLERRM);
    -- Decide if you want to rollback just this block or let the main exception handler catch it
END;
/
DECLARE
  v_new_child_instance_id productInstance.Instance_ID%TYPE;
  v_child_category        product.Category%TYPE := 'Commodity'; -- Pass category
  v_max_existing_batch_lot NUMBER;
  v_next_batch_lot_num   NUMBER;
  v_serial_number        serialized.Serial_Number%TYPE;
  v_batch_number         serialized.Batch_Number%TYPE; -- Shared batch for serialized children of *this* parent
  v_expiration_date      commodity.Expiration_Date%TYPE;
  v_quantity_to_create   commodity.Quantity%TYPE; -- Quantity for the new child instance

BEGIN
  -- Step 1: Create the new child productInstance
  INSERT INTO productInstance (Product_ID, Date_Manufactured, Is_Recalled)
  VALUES (244.0, TIMESTAMP '2024-08-28 20:23:33', 0)
  RETURNING Instance_ID INTO v_new_child_instance_id;

  -- Step 2: Create the corresponding subtype record
  IF v_child_category = 'Commodity' THEN
    -- Find max existing Batch_Number for this specific Child_PID
    SELECT NVL(MAX(c.Batch_Number), 0) INTO v_max_existing_batch_lot
    FROM commodity c JOIN productInstance pi ON c.Instance_ID = pi.Instance_ID
    WHERE pi.Product_ID = 244.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next batch

    v_expiration_date := TIMESTAMP '2024-08-28 20:23:33' + INTERVAL '457' DAY;
    v_quantity_to_create := ROUND(1.8, 1);

    INSERT INTO commodity (Instance_ID, Batch_Number, Expiration_Date, Quantity)
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Packaged' THEN
    -- Find max existing Lot_Number for this specific Child_PID
    SELECT NVL(MAX(p.Lot_Number), 0) INTO v_max_existing_batch_lot
    FROM packaged p JOIN productInstance pi ON p.Instance_ID = pi.Instance_ID -- Assuming 'packaged' table name
    WHERE pi.Product_ID = 244.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next lot

    v_expiration_date := TIMESTAMP '2024-08-28 20:23:33' + INTERVAL '335' DAY;
    v_quantity_to_create := ROUND(1.8, 1);

    INSERT INTO packaged (Instance_ID, Lot_Number, Expiration_Date, Quantity) -- Assuming 'packaged' table name
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Serialized' THEN
    -- Assign a unique serial number
    -- Using Instance ID guarantees uniqueness within this context
    v_serial_number := 'SN-' || TO_CHAR(244.0) || '-' || TO_CHAR(v_new_child_instance_id) || '-' || SUBSTR(SYS_GUID(),1,8);
    -- Assign a batch number - use Product_ID of the *parent* instance as the batch for simplicity? Or a sequence?
    -- Let's use the Parent_IID itself as a simple batch identifier for this run.
    v_batch_number := 403.0; -- All children created FOR this parent get same batch number

    INSERT INTO serialized (Instance_ID, Serial_Number, Batch_Number)
    VALUES (v_new_child_instance_id, v_serial_number, v_batch_number);

    -- Quantity for usesComponent link for serialized is typically 1
    v_quantity_to_create := 1;

  END IF;

  -- Step 3: Create the usesComponent link
  -- Quantity_Used is the Quantity_Needed from needsComponent (which matches child quantity for non-serialized)
  IF v_child_category IN ('Commodity', 'Packaged', 'Serialized') THEN -- Only insert if subtype was handled
      INSERT INTO usesComponent (Parent_IID, Child_IID, Quantity_Used)
      VALUES (403.0, v_new_child_instance_id, ROUND(1.8, 1)); -- Use rounded quantity needed
  END IF;

EXCEPTION
  WHEN OTHERS THEN
    DBMS_OUTPUT.PUT_LINE('Error processing Parent_IID=' || 403.0 || ', Child_PID=' || 244.0 || ': ' || SQLERRM);
    -- Decide if you want to rollback just this block or let the main exception handler catch it
END;
/
DECLARE
  v_new_child_instance_id productInstance.Instance_ID%TYPE;
  v_child_category        product.Category%TYPE := 'Commodity'; -- Pass category
  v_max_existing_batch_lot NUMBER;
  v_next_batch_lot_num   NUMBER;
  v_serial_number        serialized.Serial_Number%TYPE;
  v_batch_number         serialized.Batch_Number%TYPE; -- Shared batch for serialized children of *this* parent
  v_expiration_date      commodity.Expiration_Date%TYPE;
  v_quantity_to_create   commodity.Quantity%TYPE; -- Quantity for the new child instance

BEGIN
  -- Step 1: Create the new child productInstance
  INSERT INTO productInstance (Product_ID, Date_Manufactured, Is_Recalled)
  VALUES (222.0, TIMESTAMP '2024-08-30 20:23:09', 0)
  RETURNING Instance_ID INTO v_new_child_instance_id;

  -- Step 2: Create the corresponding subtype record
  IF v_child_category = 'Commodity' THEN
    -- Find max existing Batch_Number for this specific Child_PID
    SELECT NVL(MAX(c.Batch_Number), 0) INTO v_max_existing_batch_lot
    FROM commodity c JOIN productInstance pi ON c.Instance_ID = pi.Instance_ID
    WHERE pi.Product_ID = 222.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next batch

    v_expiration_date := TIMESTAMP '2024-08-30 20:23:09' + INTERVAL '391' DAY;
    v_quantity_to_create := ROUND(0.3, 1);

    INSERT INTO commodity (Instance_ID, Batch_Number, Expiration_Date, Quantity)
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Packaged' THEN
    -- Find max existing Lot_Number for this specific Child_PID
    SELECT NVL(MAX(p.Lot_Number), 0) INTO v_max_existing_batch_lot
    FROM packaged p JOIN productInstance pi ON p.Instance_ID = pi.Instance_ID -- Assuming 'packaged' table name
    WHERE pi.Product_ID = 222.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next lot

    v_expiration_date := TIMESTAMP '2024-08-30 20:23:09' + INTERVAL '309' DAY;
    v_quantity_to_create := ROUND(0.3, 1);

    INSERT INTO packaged (Instance_ID, Lot_Number, Expiration_Date, Quantity) -- Assuming 'packaged' table name
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Serialized' THEN
    -- Assign a unique serial number
    -- Using Instance ID guarantees uniqueness within this context
    v_serial_number := 'SN-' || TO_CHAR(222.0) || '-' || TO_CHAR(v_new_child_instance_id) || '-' || SUBSTR(SYS_GUID(),1,8);
    -- Assign a batch number - use Product_ID of the *parent* instance as the batch for simplicity? Or a sequence?
    -- Let's use the Parent_IID itself as a simple batch identifier for this run.
    v_batch_number := 404.0; -- All children created FOR this parent get same batch number

    INSERT INTO serialized (Instance_ID, Serial_Number, Batch_Number)
    VALUES (v_new_child_instance_id, v_serial_number, v_batch_number);

    -- Quantity for usesComponent link for serialized is typically 1
    v_quantity_to_create := 1;

  END IF;

  -- Step 3: Create the usesComponent link
  -- Quantity_Used is the Quantity_Needed from needsComponent (which matches child quantity for non-serialized)
  IF v_child_category IN ('Commodity', 'Packaged', 'Serialized') THEN -- Only insert if subtype was handled
      INSERT INTO usesComponent (Parent_IID, Child_IID, Quantity_Used)
      VALUES (404.0, v_new_child_instance_id, ROUND(0.3, 1)); -- Use rounded quantity needed
  END IF;

EXCEPTION
  WHEN OTHERS THEN
    DBMS_OUTPUT.PUT_LINE('Error processing Parent_IID=' || 404.0 || ', Child_PID=' || 222.0 || ': ' || SQLERRM);
    -- Decide if you want to rollback just this block or let the main exception handler catch it
END;
/
DECLARE
  v_new_child_instance_id productInstance.Instance_ID%TYPE;
  v_child_category        product.Category%TYPE := 'Commodity'; -- Pass category
  v_max_existing_batch_lot NUMBER;
  v_next_batch_lot_num   NUMBER;
  v_serial_number        serialized.Serial_Number%TYPE;
  v_batch_number         serialized.Batch_Number%TYPE; -- Shared batch for serialized children of *this* parent
  v_expiration_date      commodity.Expiration_Date%TYPE;
  v_quantity_to_create   commodity.Quantity%TYPE; -- Quantity for the new child instance

BEGIN
  -- Step 1: Create the new child productInstance
  INSERT INTO productInstance (Product_ID, Date_Manufactured, Is_Recalled)
  VALUES (204.0, TIMESTAMP '2024-09-02 08:52:17', 0)
  RETURNING Instance_ID INTO v_new_child_instance_id;

  -- Step 2: Create the corresponding subtype record
  IF v_child_category = 'Commodity' THEN
    -- Find max existing Batch_Number for this specific Child_PID
    SELECT NVL(MAX(c.Batch_Number), 0) INTO v_max_existing_batch_lot
    FROM commodity c JOIN productInstance pi ON c.Instance_ID = pi.Instance_ID
    WHERE pi.Product_ID = 204.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next batch

    v_expiration_date := TIMESTAMP '2024-09-02 08:52:17' + INTERVAL '562' DAY;
    v_quantity_to_create := ROUND(1.2, 1);

    INSERT INTO commodity (Instance_ID, Batch_Number, Expiration_Date, Quantity)
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Packaged' THEN
    -- Find max existing Lot_Number for this specific Child_PID
    SELECT NVL(MAX(p.Lot_Number), 0) INTO v_max_existing_batch_lot
    FROM packaged p JOIN productInstance pi ON p.Instance_ID = pi.Instance_ID -- Assuming 'packaged' table name
    WHERE pi.Product_ID = 204.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next lot

    v_expiration_date := TIMESTAMP '2024-09-02 08:52:17' + INTERVAL '543' DAY;
    v_quantity_to_create := ROUND(1.2, 1);

    INSERT INTO packaged (Instance_ID, Lot_Number, Expiration_Date, Quantity) -- Assuming 'packaged' table name
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Serialized' THEN
    -- Assign a unique serial number
    -- Using Instance ID guarantees uniqueness within this context
    v_serial_number := 'SN-' || TO_CHAR(204.0) || '-' || TO_CHAR(v_new_child_instance_id) || '-' || SUBSTR(SYS_GUID(),1,8);
    -- Assign a batch number - use Product_ID of the *parent* instance as the batch for simplicity? Or a sequence?
    -- Let's use the Parent_IID itself as a simple batch identifier for this run.
    v_batch_number := 404.0; -- All children created FOR this parent get same batch number

    INSERT INTO serialized (Instance_ID, Serial_Number, Batch_Number)
    VALUES (v_new_child_instance_id, v_serial_number, v_batch_number);

    -- Quantity for usesComponent link for serialized is typically 1
    v_quantity_to_create := 1;

  END IF;

  -- Step 3: Create the usesComponent link
  -- Quantity_Used is the Quantity_Needed from needsComponent (which matches child quantity for non-serialized)
  IF v_child_category IN ('Commodity', 'Packaged', 'Serialized') THEN -- Only insert if subtype was handled
      INSERT INTO usesComponent (Parent_IID, Child_IID, Quantity_Used)
      VALUES (404.0, v_new_child_instance_id, ROUND(1.2, 1)); -- Use rounded quantity needed
  END IF;

EXCEPTION
  WHEN OTHERS THEN
    DBMS_OUTPUT.PUT_LINE('Error processing Parent_IID=' || 404.0 || ', Child_PID=' || 204.0 || ': ' || SQLERRM);
    -- Decide if you want to rollback just this block or let the main exception handler catch it
END;
/
DECLARE
  v_new_child_instance_id productInstance.Instance_ID%TYPE;
  v_child_category        product.Category%TYPE := 'Commodity'; -- Pass category
  v_max_existing_batch_lot NUMBER;
  v_next_batch_lot_num   NUMBER;
  v_serial_number        serialized.Serial_Number%TYPE;
  v_batch_number         serialized.Batch_Number%TYPE; -- Shared batch for serialized children of *this* parent
  v_expiration_date      commodity.Expiration_Date%TYPE;
  v_quantity_to_create   commodity.Quantity%TYPE; -- Quantity for the new child instance

BEGIN
  -- Step 1: Create the new child productInstance
  INSERT INTO productInstance (Product_ID, Date_Manufactured, Is_Recalled)
  VALUES (244.0, TIMESTAMP '2024-05-02 09:13:29', 0)
  RETURNING Instance_ID INTO v_new_child_instance_id;

  -- Step 2: Create the corresponding subtype record
  IF v_child_category = 'Commodity' THEN
    -- Find max existing Batch_Number for this specific Child_PID
    SELECT NVL(MAX(c.Batch_Number), 0) INTO v_max_existing_batch_lot
    FROM commodity c JOIN productInstance pi ON c.Instance_ID = pi.Instance_ID
    WHERE pi.Product_ID = 244.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next batch

    v_expiration_date := TIMESTAMP '2024-05-02 09:13:29' + INTERVAL '568' DAY;
    v_quantity_to_create := ROUND(1.8, 1);

    INSERT INTO commodity (Instance_ID, Batch_Number, Expiration_Date, Quantity)
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Packaged' THEN
    -- Find max existing Lot_Number for this specific Child_PID
    SELECT NVL(MAX(p.Lot_Number), 0) INTO v_max_existing_batch_lot
    FROM packaged p JOIN productInstance pi ON p.Instance_ID = pi.Instance_ID -- Assuming 'packaged' table name
    WHERE pi.Product_ID = 244.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next lot

    v_expiration_date := TIMESTAMP '2024-05-02 09:13:29' + INTERVAL '154' DAY;
    v_quantity_to_create := ROUND(1.8, 1);

    INSERT INTO packaged (Instance_ID, Lot_Number, Expiration_Date, Quantity) -- Assuming 'packaged' table name
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Serialized' THEN
    -- Assign a unique serial number
    -- Using Instance ID guarantees uniqueness within this context
    v_serial_number := 'SN-' || TO_CHAR(244.0) || '-' || TO_CHAR(v_new_child_instance_id) || '-' || SUBSTR(SYS_GUID(),1,8);
    -- Assign a batch number - use Product_ID of the *parent* instance as the batch for simplicity? Or a sequence?
    -- Let's use the Parent_IID itself as a simple batch identifier for this run.
    v_batch_number := 404.0; -- All children created FOR this parent get same batch number

    INSERT INTO serialized (Instance_ID, Serial_Number, Batch_Number)
    VALUES (v_new_child_instance_id, v_serial_number, v_batch_number);

    -- Quantity for usesComponent link for serialized is typically 1
    v_quantity_to_create := 1;

  END IF;

  -- Step 3: Create the usesComponent link
  -- Quantity_Used is the Quantity_Needed from needsComponent (which matches child quantity for non-serialized)
  IF v_child_category IN ('Commodity', 'Packaged', 'Serialized') THEN -- Only insert if subtype was handled
      INSERT INTO usesComponent (Parent_IID, Child_IID, Quantity_Used)
      VALUES (404.0, v_new_child_instance_id, ROUND(1.8, 1)); -- Use rounded quantity needed
  END IF;

EXCEPTION
  WHEN OTHERS THEN
    DBMS_OUTPUT.PUT_LINE('Error processing Parent_IID=' || 404.0 || ', Child_PID=' || 244.0 || ': ' || SQLERRM);
    -- Decide if you want to rollback just this block or let the main exception handler catch it
END;
/
DECLARE
  v_new_child_instance_id productInstance.Instance_ID%TYPE;
  v_child_category        product.Category%TYPE := 'Commodity'; -- Pass category
  v_max_existing_batch_lot NUMBER;
  v_next_batch_lot_num   NUMBER;
  v_serial_number        serialized.Serial_Number%TYPE;
  v_batch_number         serialized.Batch_Number%TYPE; -- Shared batch for serialized children of *this* parent
  v_expiration_date      commodity.Expiration_Date%TYPE;
  v_quantity_to_create   commodity.Quantity%TYPE; -- Quantity for the new child instance

BEGIN
  -- Step 1: Create the new child productInstance
  INSERT INTO productInstance (Product_ID, Date_Manufactured, Is_Recalled)
  VALUES (222.0, TIMESTAMP '2024-06-25 19:28:19', 0)
  RETURNING Instance_ID INTO v_new_child_instance_id;

  -- Step 2: Create the corresponding subtype record
  IF v_child_category = 'Commodity' THEN
    -- Find max existing Batch_Number for this specific Child_PID
    SELECT NVL(MAX(c.Batch_Number), 0) INTO v_max_existing_batch_lot
    FROM commodity c JOIN productInstance pi ON c.Instance_ID = pi.Instance_ID
    WHERE pi.Product_ID = 222.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next batch

    v_expiration_date := TIMESTAMP '2024-06-25 19:28:19' + INTERVAL '354' DAY;
    v_quantity_to_create := ROUND(0.3, 1);

    INSERT INTO commodity (Instance_ID, Batch_Number, Expiration_Date, Quantity)
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Packaged' THEN
    -- Find max existing Lot_Number for this specific Child_PID
    SELECT NVL(MAX(p.Lot_Number), 0) INTO v_max_existing_batch_lot
    FROM packaged p JOIN productInstance pi ON p.Instance_ID = pi.Instance_ID -- Assuming 'packaged' table name
    WHERE pi.Product_ID = 222.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next lot

    v_expiration_date := TIMESTAMP '2024-06-25 19:28:19' + INTERVAL '363' DAY;
    v_quantity_to_create := ROUND(0.3, 1);

    INSERT INTO packaged (Instance_ID, Lot_Number, Expiration_Date, Quantity) -- Assuming 'packaged' table name
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Serialized' THEN
    -- Assign a unique serial number
    -- Using Instance ID guarantees uniqueness within this context
    v_serial_number := 'SN-' || TO_CHAR(222.0) || '-' || TO_CHAR(v_new_child_instance_id) || '-' || SUBSTR(SYS_GUID(),1,8);
    -- Assign a batch number - use Product_ID of the *parent* instance as the batch for simplicity? Or a sequence?
    -- Let's use the Parent_IID itself as a simple batch identifier for this run.
    v_batch_number := 405.0; -- All children created FOR this parent get same batch number

    INSERT INTO serialized (Instance_ID, Serial_Number, Batch_Number)
    VALUES (v_new_child_instance_id, v_serial_number, v_batch_number);

    -- Quantity for usesComponent link for serialized is typically 1
    v_quantity_to_create := 1;

  END IF;

  -- Step 3: Create the usesComponent link
  -- Quantity_Used is the Quantity_Needed from needsComponent (which matches child quantity for non-serialized)
  IF v_child_category IN ('Commodity', 'Packaged', 'Serialized') THEN -- Only insert if subtype was handled
      INSERT INTO usesComponent (Parent_IID, Child_IID, Quantity_Used)
      VALUES (405.0, v_new_child_instance_id, ROUND(0.3, 1)); -- Use rounded quantity needed
  END IF;

EXCEPTION
  WHEN OTHERS THEN
    DBMS_OUTPUT.PUT_LINE('Error processing Parent_IID=' || 405.0 || ', Child_PID=' || 222.0 || ': ' || SQLERRM);
    -- Decide if you want to rollback just this block or let the main exception handler catch it
END;
/
DECLARE
  v_new_child_instance_id productInstance.Instance_ID%TYPE;
  v_child_category        product.Category%TYPE := 'Commodity'; -- Pass category
  v_max_existing_batch_lot NUMBER;
  v_next_batch_lot_num   NUMBER;
  v_serial_number        serialized.Serial_Number%TYPE;
  v_batch_number         serialized.Batch_Number%TYPE; -- Shared batch for serialized children of *this* parent
  v_expiration_date      commodity.Expiration_Date%TYPE;
  v_quantity_to_create   commodity.Quantity%TYPE; -- Quantity for the new child instance

BEGIN
  -- Step 1: Create the new child productInstance
  INSERT INTO productInstance (Product_ID, Date_Manufactured, Is_Recalled)
  VALUES (204.0, TIMESTAMP '2025-02-27 18:57:26', 0)
  RETURNING Instance_ID INTO v_new_child_instance_id;

  -- Step 2: Create the corresponding subtype record
  IF v_child_category = 'Commodity' THEN
    -- Find max existing Batch_Number for this specific Child_PID
    SELECT NVL(MAX(c.Batch_Number), 0) INTO v_max_existing_batch_lot
    FROM commodity c JOIN productInstance pi ON c.Instance_ID = pi.Instance_ID
    WHERE pi.Product_ID = 204.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next batch

    v_expiration_date := TIMESTAMP '2025-02-27 18:57:26' + INTERVAL '365' DAY;
    v_quantity_to_create := ROUND(1.2, 1);

    INSERT INTO commodity (Instance_ID, Batch_Number, Expiration_Date, Quantity)
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Packaged' THEN
    -- Find max existing Lot_Number for this specific Child_PID
    SELECT NVL(MAX(p.Lot_Number), 0) INTO v_max_existing_batch_lot
    FROM packaged p JOIN productInstance pi ON p.Instance_ID = pi.Instance_ID -- Assuming 'packaged' table name
    WHERE pi.Product_ID = 204.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next lot

    v_expiration_date := TIMESTAMP '2025-02-27 18:57:26' + INTERVAL '616' DAY;
    v_quantity_to_create := ROUND(1.2, 1);

    INSERT INTO packaged (Instance_ID, Lot_Number, Expiration_Date, Quantity) -- Assuming 'packaged' table name
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Serialized' THEN
    -- Assign a unique serial number
    -- Using Instance ID guarantees uniqueness within this context
    v_serial_number := 'SN-' || TO_CHAR(204.0) || '-' || TO_CHAR(v_new_child_instance_id) || '-' || SUBSTR(SYS_GUID(),1,8);
    -- Assign a batch number - use Product_ID of the *parent* instance as the batch for simplicity? Or a sequence?
    -- Let's use the Parent_IID itself as a simple batch identifier for this run.
    v_batch_number := 405.0; -- All children created FOR this parent get same batch number

    INSERT INTO serialized (Instance_ID, Serial_Number, Batch_Number)
    VALUES (v_new_child_instance_id, v_serial_number, v_batch_number);

    -- Quantity for usesComponent link for serialized is typically 1
    v_quantity_to_create := 1;

  END IF;

  -- Step 3: Create the usesComponent link
  -- Quantity_Used is the Quantity_Needed from needsComponent (which matches child quantity for non-serialized)
  IF v_child_category IN ('Commodity', 'Packaged', 'Serialized') THEN -- Only insert if subtype was handled
      INSERT INTO usesComponent (Parent_IID, Child_IID, Quantity_Used)
      VALUES (405.0, v_new_child_instance_id, ROUND(1.2, 1)); -- Use rounded quantity needed
  END IF;

EXCEPTION
  WHEN OTHERS THEN
    DBMS_OUTPUT.PUT_LINE('Error processing Parent_IID=' || 405.0 || ', Child_PID=' || 204.0 || ': ' || SQLERRM);
    -- Decide if you want to rollback just this block or let the main exception handler catch it
END;
/
DECLARE
  v_new_child_instance_id productInstance.Instance_ID%TYPE;
  v_child_category        product.Category%TYPE := 'Commodity'; -- Pass category
  v_max_existing_batch_lot NUMBER;
  v_next_batch_lot_num   NUMBER;
  v_serial_number        serialized.Serial_Number%TYPE;
  v_batch_number         serialized.Batch_Number%TYPE; -- Shared batch for serialized children of *this* parent
  v_expiration_date      commodity.Expiration_Date%TYPE;
  v_quantity_to_create   commodity.Quantity%TYPE; -- Quantity for the new child instance

BEGIN
  -- Step 1: Create the new child productInstance
  INSERT INTO productInstance (Product_ID, Date_Manufactured, Is_Recalled)
  VALUES (244.0, TIMESTAMP '2024-05-25 18:39:13', 0)
  RETURNING Instance_ID INTO v_new_child_instance_id;

  -- Step 2: Create the corresponding subtype record
  IF v_child_category = 'Commodity' THEN
    -- Find max existing Batch_Number for this specific Child_PID
    SELECT NVL(MAX(c.Batch_Number), 0) INTO v_max_existing_batch_lot
    FROM commodity c JOIN productInstance pi ON c.Instance_ID = pi.Instance_ID
    WHERE pi.Product_ID = 244.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next batch

    v_expiration_date := TIMESTAMP '2024-05-25 18:39:13' + INTERVAL '492' DAY;
    v_quantity_to_create := ROUND(1.8, 1);

    INSERT INTO commodity (Instance_ID, Batch_Number, Expiration_Date, Quantity)
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Packaged' THEN
    -- Find max existing Lot_Number for this specific Child_PID
    SELECT NVL(MAX(p.Lot_Number), 0) INTO v_max_existing_batch_lot
    FROM packaged p JOIN productInstance pi ON p.Instance_ID = pi.Instance_ID -- Assuming 'packaged' table name
    WHERE pi.Product_ID = 244.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next lot

    v_expiration_date := TIMESTAMP '2024-05-25 18:39:13' + INTERVAL '316' DAY;
    v_quantity_to_create := ROUND(1.8, 1);

    INSERT INTO packaged (Instance_ID, Lot_Number, Expiration_Date, Quantity) -- Assuming 'packaged' table name
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Serialized' THEN
    -- Assign a unique serial number
    -- Using Instance ID guarantees uniqueness within this context
    v_serial_number := 'SN-' || TO_CHAR(244.0) || '-' || TO_CHAR(v_new_child_instance_id) || '-' || SUBSTR(SYS_GUID(),1,8);
    -- Assign a batch number - use Product_ID of the *parent* instance as the batch for simplicity? Or a sequence?
    -- Let's use the Parent_IID itself as a simple batch identifier for this run.
    v_batch_number := 405.0; -- All children created FOR this parent get same batch number

    INSERT INTO serialized (Instance_ID, Serial_Number, Batch_Number)
    VALUES (v_new_child_instance_id, v_serial_number, v_batch_number);

    -- Quantity for usesComponent link for serialized is typically 1
    v_quantity_to_create := 1;

  END IF;

  -- Step 3: Create the usesComponent link
  -- Quantity_Used is the Quantity_Needed from needsComponent (which matches child quantity for non-serialized)
  IF v_child_category IN ('Commodity', 'Packaged', 'Serialized') THEN -- Only insert if subtype was handled
      INSERT INTO usesComponent (Parent_IID, Child_IID, Quantity_Used)
      VALUES (405.0, v_new_child_instance_id, ROUND(1.8, 1)); -- Use rounded quantity needed
  END IF;

EXCEPTION
  WHEN OTHERS THEN
    DBMS_OUTPUT.PUT_LINE('Error processing Parent_IID=' || 405.0 || ', Child_PID=' || 244.0 || ': ' || SQLERRM);
    -- Decide if you want to rollback just this block or let the main exception handler catch it
END;
/
DECLARE
  v_new_child_instance_id productInstance.Instance_ID%TYPE;
  v_child_category        product.Category%TYPE := 'Commodity'; -- Pass category
  v_max_existing_batch_lot NUMBER;
  v_next_batch_lot_num   NUMBER;
  v_serial_number        serialized.Serial_Number%TYPE;
  v_batch_number         serialized.Batch_Number%TYPE; -- Shared batch for serialized children of *this* parent
  v_expiration_date      commodity.Expiration_Date%TYPE;
  v_quantity_to_create   commodity.Quantity%TYPE; -- Quantity for the new child instance

BEGIN
  -- Step 1: Create the new child productInstance
  INSERT INTO productInstance (Product_ID, Date_Manufactured, Is_Recalled)
  VALUES (128.0, TIMESTAMP '2024-11-01 08:04:08', 0)
  RETURNING Instance_ID INTO v_new_child_instance_id;

  -- Step 2: Create the corresponding subtype record
  IF v_child_category = 'Commodity' THEN
    -- Find max existing Batch_Number for this specific Child_PID
    SELECT NVL(MAX(c.Batch_Number), 0) INTO v_max_existing_batch_lot
    FROM commodity c JOIN productInstance pi ON c.Instance_ID = pi.Instance_ID
    WHERE pi.Product_ID = 128.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next batch

    v_expiration_date := TIMESTAMP '2024-11-01 08:04:08' + INTERVAL '495' DAY;
    v_quantity_to_create := ROUND(1.7, 1);

    INSERT INTO commodity (Instance_ID, Batch_Number, Expiration_Date, Quantity)
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Packaged' THEN
    -- Find max existing Lot_Number for this specific Child_PID
    SELECT NVL(MAX(p.Lot_Number), 0) INTO v_max_existing_batch_lot
    FROM packaged p JOIN productInstance pi ON p.Instance_ID = pi.Instance_ID -- Assuming 'packaged' table name
    WHERE pi.Product_ID = 128.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next lot

    v_expiration_date := TIMESTAMP '2024-11-01 08:04:08' + INTERVAL '402' DAY;
    v_quantity_to_create := ROUND(1.7, 1);

    INSERT INTO packaged (Instance_ID, Lot_Number, Expiration_Date, Quantity) -- Assuming 'packaged' table name
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Serialized' THEN
    -- Assign a unique serial number
    -- Using Instance ID guarantees uniqueness within this context
    v_serial_number := 'SN-' || TO_CHAR(128.0) || '-' || TO_CHAR(v_new_child_instance_id) || '-' || SUBSTR(SYS_GUID(),1,8);
    -- Assign a batch number - use Product_ID of the *parent* instance as the batch for simplicity? Or a sequence?
    -- Let's use the Parent_IID itself as a simple batch identifier for this run.
    v_batch_number := 450.0; -- All children created FOR this parent get same batch number

    INSERT INTO serialized (Instance_ID, Serial_Number, Batch_Number)
    VALUES (v_new_child_instance_id, v_serial_number, v_batch_number);

    -- Quantity for usesComponent link for serialized is typically 1
    v_quantity_to_create := 1;

  END IF;

  -- Step 3: Create the usesComponent link
  -- Quantity_Used is the Quantity_Needed from needsComponent (which matches child quantity for non-serialized)
  IF v_child_category IN ('Commodity', 'Packaged', 'Serialized') THEN -- Only insert if subtype was handled
      INSERT INTO usesComponent (Parent_IID, Child_IID, Quantity_Used)
      VALUES (450.0, v_new_child_instance_id, ROUND(1.7, 1)); -- Use rounded quantity needed
  END IF;

EXCEPTION
  WHEN OTHERS THEN
    DBMS_OUTPUT.PUT_LINE('Error processing Parent_IID=' || 450.0 || ', Child_PID=' || 128.0 || ': ' || SQLERRM);
    -- Decide if you want to rollback just this block or let the main exception handler catch it
END;
/
DECLARE
  v_new_child_instance_id productInstance.Instance_ID%TYPE;
  v_child_category        product.Category%TYPE := 'Commodity'; -- Pass category
  v_max_existing_batch_lot NUMBER;
  v_next_batch_lot_num   NUMBER;
  v_serial_number        serialized.Serial_Number%TYPE;
  v_batch_number         serialized.Batch_Number%TYPE; -- Shared batch for serialized children of *this* parent
  v_expiration_date      commodity.Expiration_Date%TYPE;
  v_quantity_to_create   commodity.Quantity%TYPE; -- Quantity for the new child instance

BEGIN
  -- Step 1: Create the new child productInstance
  INSERT INTO productInstance (Product_ID, Date_Manufactured, Is_Recalled)
  VALUES (119.0, TIMESTAMP '2025-04-24 06:58:49', 0)
  RETURNING Instance_ID INTO v_new_child_instance_id;

  -- Step 2: Create the corresponding subtype record
  IF v_child_category = 'Commodity' THEN
    -- Find max existing Batch_Number for this specific Child_PID
    SELECT NVL(MAX(c.Batch_Number), 0) INTO v_max_existing_batch_lot
    FROM commodity c JOIN productInstance pi ON c.Instance_ID = pi.Instance_ID
    WHERE pi.Product_ID = 119.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next batch

    v_expiration_date := TIMESTAMP '2025-04-24 06:58:49' + INTERVAL '419' DAY;
    v_quantity_to_create := ROUND(1.8, 1);

    INSERT INTO commodity (Instance_ID, Batch_Number, Expiration_Date, Quantity)
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Packaged' THEN
    -- Find max existing Lot_Number for this specific Child_PID
    SELECT NVL(MAX(p.Lot_Number), 0) INTO v_max_existing_batch_lot
    FROM packaged p JOIN productInstance pi ON p.Instance_ID = pi.Instance_ID -- Assuming 'packaged' table name
    WHERE pi.Product_ID = 119.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next lot

    v_expiration_date := TIMESTAMP '2025-04-24 06:58:49' + INTERVAL '110' DAY;
    v_quantity_to_create := ROUND(1.8, 1);

    INSERT INTO packaged (Instance_ID, Lot_Number, Expiration_Date, Quantity) -- Assuming 'packaged' table name
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Serialized' THEN
    -- Assign a unique serial number
    -- Using Instance ID guarantees uniqueness within this context
    v_serial_number := 'SN-' || TO_CHAR(119.0) || '-' || TO_CHAR(v_new_child_instance_id) || '-' || SUBSTR(SYS_GUID(),1,8);
    -- Assign a batch number - use Product_ID of the *parent* instance as the batch for simplicity? Or a sequence?
    -- Let's use the Parent_IID itself as a simple batch identifier for this run.
    v_batch_number := 450.0; -- All children created FOR this parent get same batch number

    INSERT INTO serialized (Instance_ID, Serial_Number, Batch_Number)
    VALUES (v_new_child_instance_id, v_serial_number, v_batch_number);

    -- Quantity for usesComponent link for serialized is typically 1
    v_quantity_to_create := 1;

  END IF;

  -- Step 3: Create the usesComponent link
  -- Quantity_Used is the Quantity_Needed from needsComponent (which matches child quantity for non-serialized)
  IF v_child_category IN ('Commodity', 'Packaged', 'Serialized') THEN -- Only insert if subtype was handled
      INSERT INTO usesComponent (Parent_IID, Child_IID, Quantity_Used)
      VALUES (450.0, v_new_child_instance_id, ROUND(1.8, 1)); -- Use rounded quantity needed
  END IF;

EXCEPTION
  WHEN OTHERS THEN
    DBMS_OUTPUT.PUT_LINE('Error processing Parent_IID=' || 450.0 || ', Child_PID=' || 119.0 || ': ' || SQLERRM);
    -- Decide if you want to rollback just this block or let the main exception handler catch it
END;
/
DECLARE
  v_new_child_instance_id productInstance.Instance_ID%TYPE;
  v_child_category        product.Category%TYPE := 'Commodity'; -- Pass category
  v_max_existing_batch_lot NUMBER;
  v_next_batch_lot_num   NUMBER;
  v_serial_number        serialized.Serial_Number%TYPE;
  v_batch_number         serialized.Batch_Number%TYPE; -- Shared batch for serialized children of *this* parent
  v_expiration_date      commodity.Expiration_Date%TYPE;
  v_quantity_to_create   commodity.Quantity%TYPE; -- Quantity for the new child instance

BEGIN
  -- Step 1: Create the new child productInstance
  INSERT INTO productInstance (Product_ID, Date_Manufactured, Is_Recalled)
  VALUES (128.0, TIMESTAMP '2025-04-22 05:19:14', 0)
  RETURNING Instance_ID INTO v_new_child_instance_id;

  -- Step 2: Create the corresponding subtype record
  IF v_child_category = 'Commodity' THEN
    -- Find max existing Batch_Number for this specific Child_PID
    SELECT NVL(MAX(c.Batch_Number), 0) INTO v_max_existing_batch_lot
    FROM commodity c JOIN productInstance pi ON c.Instance_ID = pi.Instance_ID
    WHERE pi.Product_ID = 128.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next batch

    v_expiration_date := TIMESTAMP '2025-04-22 05:19:14' + INTERVAL '622' DAY;
    v_quantity_to_create := ROUND(1.7, 1);

    INSERT INTO commodity (Instance_ID, Batch_Number, Expiration_Date, Quantity)
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Packaged' THEN
    -- Find max existing Lot_Number for this specific Child_PID
    SELECT NVL(MAX(p.Lot_Number), 0) INTO v_max_existing_batch_lot
    FROM packaged p JOIN productInstance pi ON p.Instance_ID = pi.Instance_ID -- Assuming 'packaged' table name
    WHERE pi.Product_ID = 128.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next lot

    v_expiration_date := TIMESTAMP '2025-04-22 05:19:14' + INTERVAL '87' DAY;
    v_quantity_to_create := ROUND(1.7, 1);

    INSERT INTO packaged (Instance_ID, Lot_Number, Expiration_Date, Quantity) -- Assuming 'packaged' table name
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Serialized' THEN
    -- Assign a unique serial number
    -- Using Instance ID guarantees uniqueness within this context
    v_serial_number := 'SN-' || TO_CHAR(128.0) || '-' || TO_CHAR(v_new_child_instance_id) || '-' || SUBSTR(SYS_GUID(),1,8);
    -- Assign a batch number - use Product_ID of the *parent* instance as the batch for simplicity? Or a sequence?
    -- Let's use the Parent_IID itself as a simple batch identifier for this run.
    v_batch_number := 451.0; -- All children created FOR this parent get same batch number

    INSERT INTO serialized (Instance_ID, Serial_Number, Batch_Number)
    VALUES (v_new_child_instance_id, v_serial_number, v_batch_number);

    -- Quantity for usesComponent link for serialized is typically 1
    v_quantity_to_create := 1;

  END IF;

  -- Step 3: Create the usesComponent link
  -- Quantity_Used is the Quantity_Needed from needsComponent (which matches child quantity for non-serialized)
  IF v_child_category IN ('Commodity', 'Packaged', 'Serialized') THEN -- Only insert if subtype was handled
      INSERT INTO usesComponent (Parent_IID, Child_IID, Quantity_Used)
      VALUES (451.0, v_new_child_instance_id, ROUND(1.7, 1)); -- Use rounded quantity needed
  END IF;

EXCEPTION
  WHEN OTHERS THEN
    DBMS_OUTPUT.PUT_LINE('Error processing Parent_IID=' || 451.0 || ', Child_PID=' || 128.0 || ': ' || SQLERRM);
    -- Decide if you want to rollback just this block or let the main exception handler catch it
END;
/
DECLARE
  v_new_child_instance_id productInstance.Instance_ID%TYPE;
  v_child_category        product.Category%TYPE := 'Commodity'; -- Pass category
  v_max_existing_batch_lot NUMBER;
  v_next_batch_lot_num   NUMBER;
  v_serial_number        serialized.Serial_Number%TYPE;
  v_batch_number         serialized.Batch_Number%TYPE; -- Shared batch for serialized children of *this* parent
  v_expiration_date      commodity.Expiration_Date%TYPE;
  v_quantity_to_create   commodity.Quantity%TYPE; -- Quantity for the new child instance

BEGIN
  -- Step 1: Create the new child productInstance
  INSERT INTO productInstance (Product_ID, Date_Manufactured, Is_Recalled)
  VALUES (119.0, TIMESTAMP '2024-06-20 07:20:56', 0)
  RETURNING Instance_ID INTO v_new_child_instance_id;

  -- Step 2: Create the corresponding subtype record
  IF v_child_category = 'Commodity' THEN
    -- Find max existing Batch_Number for this specific Child_PID
    SELECT NVL(MAX(c.Batch_Number), 0) INTO v_max_existing_batch_lot
    FROM commodity c JOIN productInstance pi ON c.Instance_ID = pi.Instance_ID
    WHERE pi.Product_ID = 119.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next batch

    v_expiration_date := TIMESTAMP '2024-06-20 07:20:56' + INTERVAL '79' DAY;
    v_quantity_to_create := ROUND(1.8, 1);

    INSERT INTO commodity (Instance_ID, Batch_Number, Expiration_Date, Quantity)
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Packaged' THEN
    -- Find max existing Lot_Number for this specific Child_PID
    SELECT NVL(MAX(p.Lot_Number), 0) INTO v_max_existing_batch_lot
    FROM packaged p JOIN productInstance pi ON p.Instance_ID = pi.Instance_ID -- Assuming 'packaged' table name
    WHERE pi.Product_ID = 119.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next lot

    v_expiration_date := TIMESTAMP '2024-06-20 07:20:56' + INTERVAL '566' DAY;
    v_quantity_to_create := ROUND(1.8, 1);

    INSERT INTO packaged (Instance_ID, Lot_Number, Expiration_Date, Quantity) -- Assuming 'packaged' table name
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Serialized' THEN
    -- Assign a unique serial number
    -- Using Instance ID guarantees uniqueness within this context
    v_serial_number := 'SN-' || TO_CHAR(119.0) || '-' || TO_CHAR(v_new_child_instance_id) || '-' || SUBSTR(SYS_GUID(),1,8);
    -- Assign a batch number - use Product_ID of the *parent* instance as the batch for simplicity? Or a sequence?
    -- Let's use the Parent_IID itself as a simple batch identifier for this run.
    v_batch_number := 451.0; -- All children created FOR this parent get same batch number

    INSERT INTO serialized (Instance_ID, Serial_Number, Batch_Number)
    VALUES (v_new_child_instance_id, v_serial_number, v_batch_number);

    -- Quantity for usesComponent link for serialized is typically 1
    v_quantity_to_create := 1;

  END IF;

  -- Step 3: Create the usesComponent link
  -- Quantity_Used is the Quantity_Needed from needsComponent (which matches child quantity for non-serialized)
  IF v_child_category IN ('Commodity', 'Packaged', 'Serialized') THEN -- Only insert if subtype was handled
      INSERT INTO usesComponent (Parent_IID, Child_IID, Quantity_Used)
      VALUES (451.0, v_new_child_instance_id, ROUND(1.8, 1)); -- Use rounded quantity needed
  END IF;

EXCEPTION
  WHEN OTHERS THEN
    DBMS_OUTPUT.PUT_LINE('Error processing Parent_IID=' || 451.0 || ', Child_PID=' || 119.0 || ': ' || SQLERRM);
    -- Decide if you want to rollback just this block or let the main exception handler catch it
END;
/
DECLARE
  v_new_child_instance_id productInstance.Instance_ID%TYPE;
  v_child_category        product.Category%TYPE := 'Commodity'; -- Pass category
  v_max_existing_batch_lot NUMBER;
  v_next_batch_lot_num   NUMBER;
  v_serial_number        serialized.Serial_Number%TYPE;
  v_batch_number         serialized.Batch_Number%TYPE; -- Shared batch for serialized children of *this* parent
  v_expiration_date      commodity.Expiration_Date%TYPE;
  v_quantity_to_create   commodity.Quantity%TYPE; -- Quantity for the new child instance

BEGIN
  -- Step 1: Create the new child productInstance
  INSERT INTO productInstance (Product_ID, Date_Manufactured, Is_Recalled)
  VALUES (601.0, TIMESTAMP '2024-11-06 04:20:29', 0)
  RETURNING Instance_ID INTO v_new_child_instance_id;

  -- Step 2: Create the corresponding subtype record
  IF v_child_category = 'Commodity' THEN
    -- Find max existing Batch_Number for this specific Child_PID
    SELECT NVL(MAX(c.Batch_Number), 0) INTO v_max_existing_batch_lot
    FROM commodity c JOIN productInstance pi ON c.Instance_ID = pi.Instance_ID
    WHERE pi.Product_ID = 601.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next batch

    v_expiration_date := TIMESTAMP '2024-11-06 04:20:29' + INTERVAL '619' DAY;
    v_quantity_to_create := ROUND(1.3, 1);

    INSERT INTO commodity (Instance_ID, Batch_Number, Expiration_Date, Quantity)
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Packaged' THEN
    -- Find max existing Lot_Number for this specific Child_PID
    SELECT NVL(MAX(p.Lot_Number), 0) INTO v_max_existing_batch_lot
    FROM packaged p JOIN productInstance pi ON p.Instance_ID = pi.Instance_ID -- Assuming 'packaged' table name
    WHERE pi.Product_ID = 601.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next lot

    v_expiration_date := TIMESTAMP '2024-11-06 04:20:29' + INTERVAL '287' DAY;
    v_quantity_to_create := ROUND(1.3, 1);

    INSERT INTO packaged (Instance_ID, Lot_Number, Expiration_Date, Quantity) -- Assuming 'packaged' table name
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Serialized' THEN
    -- Assign a unique serial number
    -- Using Instance ID guarantees uniqueness within this context
    v_serial_number := 'SN-' || TO_CHAR(601.0) || '-' || TO_CHAR(v_new_child_instance_id) || '-' || SUBSTR(SYS_GUID(),1,8);
    -- Assign a batch number - use Product_ID of the *parent* instance as the batch for simplicity? Or a sequence?
    -- Let's use the Parent_IID itself as a simple batch identifier for this run.
    v_batch_number := 452.0; -- All children created FOR this parent get same batch number

    INSERT INTO serialized (Instance_ID, Serial_Number, Batch_Number)
    VALUES (v_new_child_instance_id, v_serial_number, v_batch_number);

    -- Quantity for usesComponent link for serialized is typically 1
    v_quantity_to_create := 1;

  END IF;

  -- Step 3: Create the usesComponent link
  -- Quantity_Used is the Quantity_Needed from needsComponent (which matches child quantity for non-serialized)
  IF v_child_category IN ('Commodity', 'Packaged', 'Serialized') THEN -- Only insert if subtype was handled
      INSERT INTO usesComponent (Parent_IID, Child_IID, Quantity_Used)
      VALUES (452.0, v_new_child_instance_id, ROUND(1.3, 1)); -- Use rounded quantity needed
  END IF;

EXCEPTION
  WHEN OTHERS THEN
    DBMS_OUTPUT.PUT_LINE('Error processing Parent_IID=' || 452.0 || ', Child_PID=' || 601.0 || ': ' || SQLERRM);
    -- Decide if you want to rollback just this block or let the main exception handler catch it
END;
/
DECLARE
  v_new_child_instance_id productInstance.Instance_ID%TYPE;
  v_child_category        product.Category%TYPE := 'Commodity'; -- Pass category
  v_max_existing_batch_lot NUMBER;
  v_next_batch_lot_num   NUMBER;
  v_serial_number        serialized.Serial_Number%TYPE;
  v_batch_number         serialized.Batch_Number%TYPE; -- Shared batch for serialized children of *this* parent
  v_expiration_date      commodity.Expiration_Date%TYPE;
  v_quantity_to_create   commodity.Quantity%TYPE; -- Quantity for the new child instance

BEGIN
  -- Step 1: Create the new child productInstance
  INSERT INTO productInstance (Product_ID, Date_Manufactured, Is_Recalled)
  VALUES (601.0, TIMESTAMP '2025-02-27 11:53:28', 0)
  RETURNING Instance_ID INTO v_new_child_instance_id;

  -- Step 2: Create the corresponding subtype record
  IF v_child_category = 'Commodity' THEN
    -- Find max existing Batch_Number for this specific Child_PID
    SELECT NVL(MAX(c.Batch_Number), 0) INTO v_max_existing_batch_lot
    FROM commodity c JOIN productInstance pi ON c.Instance_ID = pi.Instance_ID
    WHERE pi.Product_ID = 601.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next batch

    v_expiration_date := TIMESTAMP '2025-02-27 11:53:28' + INTERVAL '281' DAY;
    v_quantity_to_create := ROUND(1.3, 1);

    INSERT INTO commodity (Instance_ID, Batch_Number, Expiration_Date, Quantity)
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Packaged' THEN
    -- Find max existing Lot_Number for this specific Child_PID
    SELECT NVL(MAX(p.Lot_Number), 0) INTO v_max_existing_batch_lot
    FROM packaged p JOIN productInstance pi ON p.Instance_ID = pi.Instance_ID -- Assuming 'packaged' table name
    WHERE pi.Product_ID = 601.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next lot

    v_expiration_date := TIMESTAMP '2025-02-27 11:53:28' + INTERVAL '617' DAY;
    v_quantity_to_create := ROUND(1.3, 1);

    INSERT INTO packaged (Instance_ID, Lot_Number, Expiration_Date, Quantity) -- Assuming 'packaged' table name
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Serialized' THEN
    -- Assign a unique serial number
    -- Using Instance ID guarantees uniqueness within this context
    v_serial_number := 'SN-' || TO_CHAR(601.0) || '-' || TO_CHAR(v_new_child_instance_id) || '-' || SUBSTR(SYS_GUID(),1,8);
    -- Assign a batch number - use Product_ID of the *parent* instance as the batch for simplicity? Or a sequence?
    -- Let's use the Parent_IID itself as a simple batch identifier for this run.
    v_batch_number := 453.0; -- All children created FOR this parent get same batch number

    INSERT INTO serialized (Instance_ID, Serial_Number, Batch_Number)
    VALUES (v_new_child_instance_id, v_serial_number, v_batch_number);

    -- Quantity for usesComponent link for serialized is typically 1
    v_quantity_to_create := 1;

  END IF;

  -- Step 3: Create the usesComponent link
  -- Quantity_Used is the Quantity_Needed from needsComponent (which matches child quantity for non-serialized)
  IF v_child_category IN ('Commodity', 'Packaged', 'Serialized') THEN -- Only insert if subtype was handled
      INSERT INTO usesComponent (Parent_IID, Child_IID, Quantity_Used)
      VALUES (453.0, v_new_child_instance_id, ROUND(1.3, 1)); -- Use rounded quantity needed
  END IF;

EXCEPTION
  WHEN OTHERS THEN
    DBMS_OUTPUT.PUT_LINE('Error processing Parent_IID=' || 453.0 || ', Child_PID=' || 601.0 || ': ' || SQLERRM);
    -- Decide if you want to rollback just this block or let the main exception handler catch it
END;
/
DECLARE
  v_new_child_instance_id productInstance.Instance_ID%TYPE;
  v_child_category        product.Category%TYPE := 'Commodity'; -- Pass category
  v_max_existing_batch_lot NUMBER;
  v_next_batch_lot_num   NUMBER;
  v_serial_number        serialized.Serial_Number%TYPE;
  v_batch_number         serialized.Batch_Number%TYPE; -- Shared batch for serialized children of *this* parent
  v_expiration_date      commodity.Expiration_Date%TYPE;
  v_quantity_to_create   commodity.Quantity%TYPE; -- Quantity for the new child instance

BEGIN
  -- Step 1: Create the new child productInstance
  INSERT INTO productInstance (Product_ID, Date_Manufactured, Is_Recalled)
  VALUES (601.0, TIMESTAMP '2025-02-13 00:14:04', 0)
  RETURNING Instance_ID INTO v_new_child_instance_id;

  -- Step 2: Create the corresponding subtype record
  IF v_child_category = 'Commodity' THEN
    -- Find max existing Batch_Number for this specific Child_PID
    SELECT NVL(MAX(c.Batch_Number), 0) INTO v_max_existing_batch_lot
    FROM commodity c JOIN productInstance pi ON c.Instance_ID = pi.Instance_ID
    WHERE pi.Product_ID = 601.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next batch

    v_expiration_date := TIMESTAMP '2025-02-13 00:14:04' + INTERVAL '376' DAY;
    v_quantity_to_create := ROUND(1.6, 1);

    INSERT INTO commodity (Instance_ID, Batch_Number, Expiration_Date, Quantity)
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Packaged' THEN
    -- Find max existing Lot_Number for this specific Child_PID
    SELECT NVL(MAX(p.Lot_Number), 0) INTO v_max_existing_batch_lot
    FROM packaged p JOIN productInstance pi ON p.Instance_ID = pi.Instance_ID -- Assuming 'packaged' table name
    WHERE pi.Product_ID = 601.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next lot

    v_expiration_date := TIMESTAMP '2025-02-13 00:14:04' + INTERVAL '400' DAY;
    v_quantity_to_create := ROUND(1.6, 1);

    INSERT INTO packaged (Instance_ID, Lot_Number, Expiration_Date, Quantity) -- Assuming 'packaged' table name
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Serialized' THEN
    -- Assign a unique serial number
    -- Using Instance ID guarantees uniqueness within this context
    v_serial_number := 'SN-' || TO_CHAR(601.0) || '-' || TO_CHAR(v_new_child_instance_id) || '-' || SUBSTR(SYS_GUID(),1,8);
    -- Assign a batch number - use Product_ID of the *parent* instance as the batch for simplicity? Or a sequence?
    -- Let's use the Parent_IID itself as a simple batch identifier for this run.
    v_batch_number := 494.0; -- All children created FOR this parent get same batch number

    INSERT INTO serialized (Instance_ID, Serial_Number, Batch_Number)
    VALUES (v_new_child_instance_id, v_serial_number, v_batch_number);

    -- Quantity for usesComponent link for serialized is typically 1
    v_quantity_to_create := 1;

  END IF;

  -- Step 3: Create the usesComponent link
  -- Quantity_Used is the Quantity_Needed from needsComponent (which matches child quantity for non-serialized)
  IF v_child_category IN ('Commodity', 'Packaged', 'Serialized') THEN -- Only insert if subtype was handled
      INSERT INTO usesComponent (Parent_IID, Child_IID, Quantity_Used)
      VALUES (494.0, v_new_child_instance_id, ROUND(1.6, 1)); -- Use rounded quantity needed
  END IF;

EXCEPTION
  WHEN OTHERS THEN
    DBMS_OUTPUT.PUT_LINE('Error processing Parent_IID=' || 494.0 || ', Child_PID=' || 601.0 || ': ' || SQLERRM);
    -- Decide if you want to rollback just this block or let the main exception handler catch it
END;
/
DECLARE
  v_new_child_instance_id productInstance.Instance_ID%TYPE;
  v_child_category        product.Category%TYPE := 'Commodity'; -- Pass category
  v_max_existing_batch_lot NUMBER;
  v_next_batch_lot_num   NUMBER;
  v_serial_number        serialized.Serial_Number%TYPE;
  v_batch_number         serialized.Batch_Number%TYPE; -- Shared batch for serialized children of *this* parent
  v_expiration_date      commodity.Expiration_Date%TYPE;
  v_quantity_to_create   commodity.Quantity%TYPE; -- Quantity for the new child instance

BEGIN
  -- Step 1: Create the new child productInstance
  INSERT INTO productInstance (Product_ID, Date_Manufactured, Is_Recalled)
  VALUES (601.0, TIMESTAMP '2025-03-04 12:42:18', 0)
  RETURNING Instance_ID INTO v_new_child_instance_id;

  -- Step 2: Create the corresponding subtype record
  IF v_child_category = 'Commodity' THEN
    -- Find max existing Batch_Number for this specific Child_PID
    SELECT NVL(MAX(c.Batch_Number), 0) INTO v_max_existing_batch_lot
    FROM commodity c JOIN productInstance pi ON c.Instance_ID = pi.Instance_ID
    WHERE pi.Product_ID = 601.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next batch

    v_expiration_date := TIMESTAMP '2025-03-04 12:42:18' + INTERVAL '688' DAY;
    v_quantity_to_create := ROUND(1.6, 1);

    INSERT INTO commodity (Instance_ID, Batch_Number, Expiration_Date, Quantity)
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Packaged' THEN
    -- Find max existing Lot_Number for this specific Child_PID
    SELECT NVL(MAX(p.Lot_Number), 0) INTO v_max_existing_batch_lot
    FROM packaged p JOIN productInstance pi ON p.Instance_ID = pi.Instance_ID -- Assuming 'packaged' table name
    WHERE pi.Product_ID = 601.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next lot

    v_expiration_date := TIMESTAMP '2025-03-04 12:42:18' + INTERVAL '409' DAY;
    v_quantity_to_create := ROUND(1.6, 1);

    INSERT INTO packaged (Instance_ID, Lot_Number, Expiration_Date, Quantity) -- Assuming 'packaged' table name
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Serialized' THEN
    -- Assign a unique serial number
    -- Using Instance ID guarantees uniqueness within this context
    v_serial_number := 'SN-' || TO_CHAR(601.0) || '-' || TO_CHAR(v_new_child_instance_id) || '-' || SUBSTR(SYS_GUID(),1,8);
    -- Assign a batch number - use Product_ID of the *parent* instance as the batch for simplicity? Or a sequence?
    -- Let's use the Parent_IID itself as a simple batch identifier for this run.
    v_batch_number := 495.0; -- All children created FOR this parent get same batch number

    INSERT INTO serialized (Instance_ID, Serial_Number, Batch_Number)
    VALUES (v_new_child_instance_id, v_serial_number, v_batch_number);

    -- Quantity for usesComponent link for serialized is typically 1
    v_quantity_to_create := 1;

  END IF;

  -- Step 3: Create the usesComponent link
  -- Quantity_Used is the Quantity_Needed from needsComponent (which matches child quantity for non-serialized)
  IF v_child_category IN ('Commodity', 'Packaged', 'Serialized') THEN -- Only insert if subtype was handled
      INSERT INTO usesComponent (Parent_IID, Child_IID, Quantity_Used)
      VALUES (495.0, v_new_child_instance_id, ROUND(1.6, 1)); -- Use rounded quantity needed
  END IF;

EXCEPTION
  WHEN OTHERS THEN
    DBMS_OUTPUT.PUT_LINE('Error processing Parent_IID=' || 495.0 || ', Child_PID=' || 601.0 || ': ' || SQLERRM);
    -- Decide if you want to rollback just this block or let the main exception handler catch it
END;
/
DECLARE
  v_new_child_instance_id productInstance.Instance_ID%TYPE;
  v_child_category        product.Category%TYPE := 'Commodity'; -- Pass category
  v_max_existing_batch_lot NUMBER;
  v_next_batch_lot_num   NUMBER;
  v_serial_number        serialized.Serial_Number%TYPE;
  v_batch_number         serialized.Batch_Number%TYPE; -- Shared batch for serialized children of *this* parent
  v_expiration_date      commodity.Expiration_Date%TYPE;
  v_quantity_to_create   commodity.Quantity%TYPE; -- Quantity for the new child instance

BEGIN
  -- Step 1: Create the new child productInstance
  INSERT INTO productInstance (Product_ID, Date_Manufactured, Is_Recalled)
  VALUES (601.0, TIMESTAMP '2024-10-02 09:13:42', 0)
  RETURNING Instance_ID INTO v_new_child_instance_id;

  -- Step 2: Create the corresponding subtype record
  IF v_child_category = 'Commodity' THEN
    -- Find max existing Batch_Number for this specific Child_PID
    SELECT NVL(MAX(c.Batch_Number), 0) INTO v_max_existing_batch_lot
    FROM commodity c JOIN productInstance pi ON c.Instance_ID = pi.Instance_ID
    WHERE pi.Product_ID = 601.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next batch

    v_expiration_date := TIMESTAMP '2024-10-02 09:13:42' + INTERVAL '344' DAY;
    v_quantity_to_create := ROUND(1.6, 1);

    INSERT INTO commodity (Instance_ID, Batch_Number, Expiration_Date, Quantity)
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Packaged' THEN
    -- Find max existing Lot_Number for this specific Child_PID
    SELECT NVL(MAX(p.Lot_Number), 0) INTO v_max_existing_batch_lot
    FROM packaged p JOIN productInstance pi ON p.Instance_ID = pi.Instance_ID -- Assuming 'packaged' table name
    WHERE pi.Product_ID = 601.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next lot

    v_expiration_date := TIMESTAMP '2024-10-02 09:13:42' + INTERVAL '505' DAY;
    v_quantity_to_create := ROUND(1.6, 1);

    INSERT INTO packaged (Instance_ID, Lot_Number, Expiration_Date, Quantity) -- Assuming 'packaged' table name
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Serialized' THEN
    -- Assign a unique serial number
    -- Using Instance ID guarantees uniqueness within this context
    v_serial_number := 'SN-' || TO_CHAR(601.0) || '-' || TO_CHAR(v_new_child_instance_id) || '-' || SUBSTR(SYS_GUID(),1,8);
    -- Assign a batch number - use Product_ID of the *parent* instance as the batch for simplicity? Or a sequence?
    -- Let's use the Parent_IID itself as a simple batch identifier for this run.
    v_batch_number := 496.0; -- All children created FOR this parent get same batch number

    INSERT INTO serialized (Instance_ID, Serial_Number, Batch_Number)
    VALUES (v_new_child_instance_id, v_serial_number, v_batch_number);

    -- Quantity for usesComponent link for serialized is typically 1
    v_quantity_to_create := 1;

  END IF;

  -- Step 3: Create the usesComponent link
  -- Quantity_Used is the Quantity_Needed from needsComponent (which matches child quantity for non-serialized)
  IF v_child_category IN ('Commodity', 'Packaged', 'Serialized') THEN -- Only insert if subtype was handled
      INSERT INTO usesComponent (Parent_IID, Child_IID, Quantity_Used)
      VALUES (496.0, v_new_child_instance_id, ROUND(1.6, 1)); -- Use rounded quantity needed
  END IF;

EXCEPTION
  WHEN OTHERS THEN
    DBMS_OUTPUT.PUT_LINE('Error processing Parent_IID=' || 496.0 || ', Child_PID=' || 601.0 || ': ' || SQLERRM);
    -- Decide if you want to rollback just this block or let the main exception handler catch it
END;
/
DECLARE
  v_new_child_instance_id productInstance.Instance_ID%TYPE;
  v_child_category        product.Category%TYPE := 'Commodity'; -- Pass category
  v_max_existing_batch_lot NUMBER;
  v_next_batch_lot_num   NUMBER;
  v_serial_number        serialized.Serial_Number%TYPE;
  v_batch_number         serialized.Batch_Number%TYPE; -- Shared batch for serialized children of *this* parent
  v_expiration_date      commodity.Expiration_Date%TYPE;
  v_quantity_to_create   commodity.Quantity%TYPE; -- Quantity for the new child instance

BEGIN
  -- Step 1: Create the new child productInstance
  INSERT INTO productInstance (Product_ID, Date_Manufactured, Is_Recalled)
  VALUES (601.0, TIMESTAMP '2024-12-17 09:09:41', 0)
  RETURNING Instance_ID INTO v_new_child_instance_id;

  -- Step 2: Create the corresponding subtype record
  IF v_child_category = 'Commodity' THEN
    -- Find max existing Batch_Number for this specific Child_PID
    SELECT NVL(MAX(c.Batch_Number), 0) INTO v_max_existing_batch_lot
    FROM commodity c JOIN productInstance pi ON c.Instance_ID = pi.Instance_ID
    WHERE pi.Product_ID = 601.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next batch

    v_expiration_date := TIMESTAMP '2024-12-17 09:09:41' + INTERVAL '378' DAY;
    v_quantity_to_create := ROUND(1.6, 1);

    INSERT INTO commodity (Instance_ID, Batch_Number, Expiration_Date, Quantity)
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Packaged' THEN
    -- Find max existing Lot_Number for this specific Child_PID
    SELECT NVL(MAX(p.Lot_Number), 0) INTO v_max_existing_batch_lot
    FROM packaged p JOIN productInstance pi ON p.Instance_ID = pi.Instance_ID -- Assuming 'packaged' table name
    WHERE pi.Product_ID = 601.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next lot

    v_expiration_date := TIMESTAMP '2024-12-17 09:09:41' + INTERVAL '574' DAY;
    v_quantity_to_create := ROUND(1.6, 1);

    INSERT INTO packaged (Instance_ID, Lot_Number, Expiration_Date, Quantity) -- Assuming 'packaged' table name
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Serialized' THEN
    -- Assign a unique serial number
    -- Using Instance ID guarantees uniqueness within this context
    v_serial_number := 'SN-' || TO_CHAR(601.0) || '-' || TO_CHAR(v_new_child_instance_id) || '-' || SUBSTR(SYS_GUID(),1,8);
    -- Assign a batch number - use Product_ID of the *parent* instance as the batch for simplicity? Or a sequence?
    -- Let's use the Parent_IID itself as a simple batch identifier for this run.
    v_batch_number := 497.0; -- All children created FOR this parent get same batch number

    INSERT INTO serialized (Instance_ID, Serial_Number, Batch_Number)
    VALUES (v_new_child_instance_id, v_serial_number, v_batch_number);

    -- Quantity for usesComponent link for serialized is typically 1
    v_quantity_to_create := 1;

  END IF;

  -- Step 3: Create the usesComponent link
  -- Quantity_Used is the Quantity_Needed from needsComponent (which matches child quantity for non-serialized)
  IF v_child_category IN ('Commodity', 'Packaged', 'Serialized') THEN -- Only insert if subtype was handled
      INSERT INTO usesComponent (Parent_IID, Child_IID, Quantity_Used)
      VALUES (497.0, v_new_child_instance_id, ROUND(1.6, 1)); -- Use rounded quantity needed
  END IF;

EXCEPTION
  WHEN OTHERS THEN
    DBMS_OUTPUT.PUT_LINE('Error processing Parent_IID=' || 497.0 || ', Child_PID=' || 601.0 || ': ' || SQLERRM);
    -- Decide if you want to rollback just this block or let the main exception handler catch it
END;
/
DECLARE
  v_new_child_instance_id productInstance.Instance_ID%TYPE;
  v_child_category        product.Category%TYPE := 'Commodity'; -- Pass category
  v_max_existing_batch_lot NUMBER;
  v_next_batch_lot_num   NUMBER;
  v_serial_number        serialized.Serial_Number%TYPE;
  v_batch_number         serialized.Batch_Number%TYPE; -- Shared batch for serialized children of *this* parent
  v_expiration_date      commodity.Expiration_Date%TYPE;
  v_quantity_to_create   commodity.Quantity%TYPE; -- Quantity for the new child instance

BEGIN
  -- Step 1: Create the new child productInstance
  INSERT INTO productInstance (Product_ID, Date_Manufactured, Is_Recalled)
  VALUES (175.0, TIMESTAMP '2024-11-12 03:35:46', 0)
  RETURNING Instance_ID INTO v_new_child_instance_id;

  -- Step 2: Create the corresponding subtype record
  IF v_child_category = 'Commodity' THEN
    -- Find max existing Batch_Number for this specific Child_PID
    SELECT NVL(MAX(c.Batch_Number), 0) INTO v_max_existing_batch_lot
    FROM commodity c JOIN productInstance pi ON c.Instance_ID = pi.Instance_ID
    WHERE pi.Product_ID = 175.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next batch

    v_expiration_date := TIMESTAMP '2024-11-12 03:35:46' + INTERVAL '201' DAY;
    v_quantity_to_create := ROUND(1.0, 1);

    INSERT INTO commodity (Instance_ID, Batch_Number, Expiration_Date, Quantity)
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Packaged' THEN
    -- Find max existing Lot_Number for this specific Child_PID
    SELECT NVL(MAX(p.Lot_Number), 0) INTO v_max_existing_batch_lot
    FROM packaged p JOIN productInstance pi ON p.Instance_ID = pi.Instance_ID -- Assuming 'packaged' table name
    WHERE pi.Product_ID = 175.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next lot

    v_expiration_date := TIMESTAMP '2024-11-12 03:35:46' + INTERVAL '59' DAY;
    v_quantity_to_create := ROUND(1.0, 1);

    INSERT INTO packaged (Instance_ID, Lot_Number, Expiration_Date, Quantity) -- Assuming 'packaged' table name
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Serialized' THEN
    -- Assign a unique serial number
    -- Using Instance ID guarantees uniqueness within this context
    v_serial_number := 'SN-' || TO_CHAR(175.0) || '-' || TO_CHAR(v_new_child_instance_id) || '-' || SUBSTR(SYS_GUID(),1,8);
    -- Assign a batch number - use Product_ID of the *parent* instance as the batch for simplicity? Or a sequence?
    -- Let's use the Parent_IID itself as a simple batch identifier for this run.
    v_batch_number := 511.0; -- All children created FOR this parent get same batch number

    INSERT INTO serialized (Instance_ID, Serial_Number, Batch_Number)
    VALUES (v_new_child_instance_id, v_serial_number, v_batch_number);

    -- Quantity for usesComponent link for serialized is typically 1
    v_quantity_to_create := 1;

  END IF;

  -- Step 3: Create the usesComponent link
  -- Quantity_Used is the Quantity_Needed from needsComponent (which matches child quantity for non-serialized)
  IF v_child_category IN ('Commodity', 'Packaged', 'Serialized') THEN -- Only insert if subtype was handled
      INSERT INTO usesComponent (Parent_IID, Child_IID, Quantity_Used)
      VALUES (511.0, v_new_child_instance_id, ROUND(1.0, 1)); -- Use rounded quantity needed
  END IF;

EXCEPTION
  WHEN OTHERS THEN
    DBMS_OUTPUT.PUT_LINE('Error processing Parent_IID=' || 511.0 || ', Child_PID=' || 175.0 || ': ' || SQLERRM);
    -- Decide if you want to rollback just this block or let the main exception handler catch it
END;
/
DECLARE
  v_new_child_instance_id productInstance.Instance_ID%TYPE;
  v_child_category        product.Category%TYPE := 'Commodity'; -- Pass category
  v_max_existing_batch_lot NUMBER;
  v_next_batch_lot_num   NUMBER;
  v_serial_number        serialized.Serial_Number%TYPE;
  v_batch_number         serialized.Batch_Number%TYPE; -- Shared batch for serialized children of *this* parent
  v_expiration_date      commodity.Expiration_Date%TYPE;
  v_quantity_to_create   commodity.Quantity%TYPE; -- Quantity for the new child instance

BEGIN
  -- Step 1: Create the new child productInstance
  INSERT INTO productInstance (Product_ID, Date_Manufactured, Is_Recalled)
  VALUES (209.0, TIMESTAMP '2024-06-25 15:43:47', 0)
  RETURNING Instance_ID INTO v_new_child_instance_id;

  -- Step 2: Create the corresponding subtype record
  IF v_child_category = 'Commodity' THEN
    -- Find max existing Batch_Number for this specific Child_PID
    SELECT NVL(MAX(c.Batch_Number), 0) INTO v_max_existing_batch_lot
    FROM commodity c JOIN productInstance pi ON c.Instance_ID = pi.Instance_ID
    WHERE pi.Product_ID = 209.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next batch

    v_expiration_date := TIMESTAMP '2024-06-25 15:43:47' + INTERVAL '286' DAY;
    v_quantity_to_create := ROUND(0.7, 1);

    INSERT INTO commodity (Instance_ID, Batch_Number, Expiration_Date, Quantity)
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Packaged' THEN
    -- Find max existing Lot_Number for this specific Child_PID
    SELECT NVL(MAX(p.Lot_Number), 0) INTO v_max_existing_batch_lot
    FROM packaged p JOIN productInstance pi ON p.Instance_ID = pi.Instance_ID -- Assuming 'packaged' table name
    WHERE pi.Product_ID = 209.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next lot

    v_expiration_date := TIMESTAMP '2024-06-25 15:43:47' + INTERVAL '256' DAY;
    v_quantity_to_create := ROUND(0.7, 1);

    INSERT INTO packaged (Instance_ID, Lot_Number, Expiration_Date, Quantity) -- Assuming 'packaged' table name
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Serialized' THEN
    -- Assign a unique serial number
    -- Using Instance ID guarantees uniqueness within this context
    v_serial_number := 'SN-' || TO_CHAR(209.0) || '-' || TO_CHAR(v_new_child_instance_id) || '-' || SUBSTR(SYS_GUID(),1,8);
    -- Assign a batch number - use Product_ID of the *parent* instance as the batch for simplicity? Or a sequence?
    -- Let's use the Parent_IID itself as a simple batch identifier for this run.
    v_batch_number := 511.0; -- All children created FOR this parent get same batch number

    INSERT INTO serialized (Instance_ID, Serial_Number, Batch_Number)
    VALUES (v_new_child_instance_id, v_serial_number, v_batch_number);

    -- Quantity for usesComponent link for serialized is typically 1
    v_quantity_to_create := 1;

  END IF;

  -- Step 3: Create the usesComponent link
  -- Quantity_Used is the Quantity_Needed from needsComponent (which matches child quantity for non-serialized)
  IF v_child_category IN ('Commodity', 'Packaged', 'Serialized') THEN -- Only insert if subtype was handled
      INSERT INTO usesComponent (Parent_IID, Child_IID, Quantity_Used)
      VALUES (511.0, v_new_child_instance_id, ROUND(0.7, 1)); -- Use rounded quantity needed
  END IF;

EXCEPTION
  WHEN OTHERS THEN
    DBMS_OUTPUT.PUT_LINE('Error processing Parent_IID=' || 511.0 || ', Child_PID=' || 209.0 || ': ' || SQLERRM);
    -- Decide if you want to rollback just this block or let the main exception handler catch it
END;
/
DECLARE
  v_new_child_instance_id productInstance.Instance_ID%TYPE;
  v_child_category        product.Category%TYPE := 'Commodity'; -- Pass category
  v_max_existing_batch_lot NUMBER;
  v_next_batch_lot_num   NUMBER;
  v_serial_number        serialized.Serial_Number%TYPE;
  v_batch_number         serialized.Batch_Number%TYPE; -- Shared batch for serialized children of *this* parent
  v_expiration_date      commodity.Expiration_Date%TYPE;
  v_quantity_to_create   commodity.Quantity%TYPE; -- Quantity for the new child instance

BEGIN
  -- Step 1: Create the new child productInstance
  INSERT INTO productInstance (Product_ID, Date_Manufactured, Is_Recalled)
  VALUES (195.0, TIMESTAMP '2024-12-03 14:24:33', 0)
  RETURNING Instance_ID INTO v_new_child_instance_id;

  -- Step 2: Create the corresponding subtype record
  IF v_child_category = 'Commodity' THEN
    -- Find max existing Batch_Number for this specific Child_PID
    SELECT NVL(MAX(c.Batch_Number), 0) INTO v_max_existing_batch_lot
    FROM commodity c JOIN productInstance pi ON c.Instance_ID = pi.Instance_ID
    WHERE pi.Product_ID = 195.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next batch

    v_expiration_date := TIMESTAMP '2024-12-03 14:24:33' + INTERVAL '166' DAY;
    v_quantity_to_create := ROUND(1.0, 1);

    INSERT INTO commodity (Instance_ID, Batch_Number, Expiration_Date, Quantity)
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Packaged' THEN
    -- Find max existing Lot_Number for this specific Child_PID
    SELECT NVL(MAX(p.Lot_Number), 0) INTO v_max_existing_batch_lot
    FROM packaged p JOIN productInstance pi ON p.Instance_ID = pi.Instance_ID -- Assuming 'packaged' table name
    WHERE pi.Product_ID = 195.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next lot

    v_expiration_date := TIMESTAMP '2024-12-03 14:24:33' + INTERVAL '145' DAY;
    v_quantity_to_create := ROUND(1.0, 1);

    INSERT INTO packaged (Instance_ID, Lot_Number, Expiration_Date, Quantity) -- Assuming 'packaged' table name
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Serialized' THEN
    -- Assign a unique serial number
    -- Using Instance ID guarantees uniqueness within this context
    v_serial_number := 'SN-' || TO_CHAR(195.0) || '-' || TO_CHAR(v_new_child_instance_id) || '-' || SUBSTR(SYS_GUID(),1,8);
    -- Assign a batch number - use Product_ID of the *parent* instance as the batch for simplicity? Or a sequence?
    -- Let's use the Parent_IID itself as a simple batch identifier for this run.
    v_batch_number := 511.0; -- All children created FOR this parent get same batch number

    INSERT INTO serialized (Instance_ID, Serial_Number, Batch_Number)
    VALUES (v_new_child_instance_id, v_serial_number, v_batch_number);

    -- Quantity for usesComponent link for serialized is typically 1
    v_quantity_to_create := 1;

  END IF;

  -- Step 3: Create the usesComponent link
  -- Quantity_Used is the Quantity_Needed from needsComponent (which matches child quantity for non-serialized)
  IF v_child_category IN ('Commodity', 'Packaged', 'Serialized') THEN -- Only insert if subtype was handled
      INSERT INTO usesComponent (Parent_IID, Child_IID, Quantity_Used)
      VALUES (511.0, v_new_child_instance_id, ROUND(1.0, 1)); -- Use rounded quantity needed
  END IF;

EXCEPTION
  WHEN OTHERS THEN
    DBMS_OUTPUT.PUT_LINE('Error processing Parent_IID=' || 511.0 || ', Child_PID=' || 195.0 || ': ' || SQLERRM);
    -- Decide if you want to rollback just this block or let the main exception handler catch it
END;
/
DECLARE
  v_new_child_instance_id productInstance.Instance_ID%TYPE;
  v_child_category        product.Category%TYPE := 'Commodity'; -- Pass category
  v_max_existing_batch_lot NUMBER;
  v_next_batch_lot_num   NUMBER;
  v_serial_number        serialized.Serial_Number%TYPE;
  v_batch_number         serialized.Batch_Number%TYPE; -- Shared batch for serialized children of *this* parent
  v_expiration_date      commodity.Expiration_Date%TYPE;
  v_quantity_to_create   commodity.Quantity%TYPE; -- Quantity for the new child instance

BEGIN
  -- Step 1: Create the new child productInstance
  INSERT INTO productInstance (Product_ID, Date_Manufactured, Is_Recalled)
  VALUES (175.0, TIMESTAMP '2024-07-09 17:33:39', 0)
  RETURNING Instance_ID INTO v_new_child_instance_id;

  -- Step 2: Create the corresponding subtype record
  IF v_child_category = 'Commodity' THEN
    -- Find max existing Batch_Number for this specific Child_PID
    SELECT NVL(MAX(c.Batch_Number), 0) INTO v_max_existing_batch_lot
    FROM commodity c JOIN productInstance pi ON c.Instance_ID = pi.Instance_ID
    WHERE pi.Product_ID = 175.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next batch

    v_expiration_date := TIMESTAMP '2024-07-09 17:33:39' + INTERVAL '450' DAY;
    v_quantity_to_create := ROUND(1.0, 1);

    INSERT INTO commodity (Instance_ID, Batch_Number, Expiration_Date, Quantity)
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Packaged' THEN
    -- Find max existing Lot_Number for this specific Child_PID
    SELECT NVL(MAX(p.Lot_Number), 0) INTO v_max_existing_batch_lot
    FROM packaged p JOIN productInstance pi ON p.Instance_ID = pi.Instance_ID -- Assuming 'packaged' table name
    WHERE pi.Product_ID = 175.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next lot

    v_expiration_date := TIMESTAMP '2024-07-09 17:33:39' + INTERVAL '664' DAY;
    v_quantity_to_create := ROUND(1.0, 1);

    INSERT INTO packaged (Instance_ID, Lot_Number, Expiration_Date, Quantity) -- Assuming 'packaged' table name
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Serialized' THEN
    -- Assign a unique serial number
    -- Using Instance ID guarantees uniqueness within this context
    v_serial_number := 'SN-' || TO_CHAR(175.0) || '-' || TO_CHAR(v_new_child_instance_id) || '-' || SUBSTR(SYS_GUID(),1,8);
    -- Assign a batch number - use Product_ID of the *parent* instance as the batch for simplicity? Or a sequence?
    -- Let's use the Parent_IID itself as a simple batch identifier for this run.
    v_batch_number := 512.0; -- All children created FOR this parent get same batch number

    INSERT INTO serialized (Instance_ID, Serial_Number, Batch_Number)
    VALUES (v_new_child_instance_id, v_serial_number, v_batch_number);

    -- Quantity for usesComponent link for serialized is typically 1
    v_quantity_to_create := 1;

  END IF;

  -- Step 3: Create the usesComponent link
  -- Quantity_Used is the Quantity_Needed from needsComponent (which matches child quantity for non-serialized)
  IF v_child_category IN ('Commodity', 'Packaged', 'Serialized') THEN -- Only insert if subtype was handled
      INSERT INTO usesComponent (Parent_IID, Child_IID, Quantity_Used)
      VALUES (512.0, v_new_child_instance_id, ROUND(1.0, 1)); -- Use rounded quantity needed
  END IF;

EXCEPTION
  WHEN OTHERS THEN
    DBMS_OUTPUT.PUT_LINE('Error processing Parent_IID=' || 512.0 || ', Child_PID=' || 175.0 || ': ' || SQLERRM);
    -- Decide if you want to rollback just this block or let the main exception handler catch it
END;
/
DECLARE
  v_new_child_instance_id productInstance.Instance_ID%TYPE;
  v_child_category        product.Category%TYPE := 'Commodity'; -- Pass category
  v_max_existing_batch_lot NUMBER;
  v_next_batch_lot_num   NUMBER;
  v_serial_number        serialized.Serial_Number%TYPE;
  v_batch_number         serialized.Batch_Number%TYPE; -- Shared batch for serialized children of *this* parent
  v_expiration_date      commodity.Expiration_Date%TYPE;
  v_quantity_to_create   commodity.Quantity%TYPE; -- Quantity for the new child instance

BEGIN
  -- Step 1: Create the new child productInstance
  INSERT INTO productInstance (Product_ID, Date_Manufactured, Is_Recalled)
  VALUES (209.0, TIMESTAMP '2024-05-18 11:58:25', 0)
  RETURNING Instance_ID INTO v_new_child_instance_id;

  -- Step 2: Create the corresponding subtype record
  IF v_child_category = 'Commodity' THEN
    -- Find max existing Batch_Number for this specific Child_PID
    SELECT NVL(MAX(c.Batch_Number), 0) INTO v_max_existing_batch_lot
    FROM commodity c JOIN productInstance pi ON c.Instance_ID = pi.Instance_ID
    WHERE pi.Product_ID = 209.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next batch

    v_expiration_date := TIMESTAMP '2024-05-18 11:58:25' + INTERVAL '131' DAY;
    v_quantity_to_create := ROUND(0.7, 1);

    INSERT INTO commodity (Instance_ID, Batch_Number, Expiration_Date, Quantity)
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Packaged' THEN
    -- Find max existing Lot_Number for this specific Child_PID
    SELECT NVL(MAX(p.Lot_Number), 0) INTO v_max_existing_batch_lot
    FROM packaged p JOIN productInstance pi ON p.Instance_ID = pi.Instance_ID -- Assuming 'packaged' table name
    WHERE pi.Product_ID = 209.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next lot

    v_expiration_date := TIMESTAMP '2024-05-18 11:58:25' + INTERVAL '588' DAY;
    v_quantity_to_create := ROUND(0.7, 1);

    INSERT INTO packaged (Instance_ID, Lot_Number, Expiration_Date, Quantity) -- Assuming 'packaged' table name
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Serialized' THEN
    -- Assign a unique serial number
    -- Using Instance ID guarantees uniqueness within this context
    v_serial_number := 'SN-' || TO_CHAR(209.0) || '-' || TO_CHAR(v_new_child_instance_id) || '-' || SUBSTR(SYS_GUID(),1,8);
    -- Assign a batch number - use Product_ID of the *parent* instance as the batch for simplicity? Or a sequence?
    -- Let's use the Parent_IID itself as a simple batch identifier for this run.
    v_batch_number := 512.0; -- All children created FOR this parent get same batch number

    INSERT INTO serialized (Instance_ID, Serial_Number, Batch_Number)
    VALUES (v_new_child_instance_id, v_serial_number, v_batch_number);

    -- Quantity for usesComponent link for serialized is typically 1
    v_quantity_to_create := 1;

  END IF;

  -- Step 3: Create the usesComponent link
  -- Quantity_Used is the Quantity_Needed from needsComponent (which matches child quantity for non-serialized)
  IF v_child_category IN ('Commodity', 'Packaged', 'Serialized') THEN -- Only insert if subtype was handled
      INSERT INTO usesComponent (Parent_IID, Child_IID, Quantity_Used)
      VALUES (512.0, v_new_child_instance_id, ROUND(0.7, 1)); -- Use rounded quantity needed
  END IF;

EXCEPTION
  WHEN OTHERS THEN
    DBMS_OUTPUT.PUT_LINE('Error processing Parent_IID=' || 512.0 || ', Child_PID=' || 209.0 || ': ' || SQLERRM);
    -- Decide if you want to rollback just this block or let the main exception handler catch it
END;
/
DECLARE
  v_new_child_instance_id productInstance.Instance_ID%TYPE;
  v_child_category        product.Category%TYPE := 'Commodity'; -- Pass category
  v_max_existing_batch_lot NUMBER;
  v_next_batch_lot_num   NUMBER;
  v_serial_number        serialized.Serial_Number%TYPE;
  v_batch_number         serialized.Batch_Number%TYPE; -- Shared batch for serialized children of *this* parent
  v_expiration_date      commodity.Expiration_Date%TYPE;
  v_quantity_to_create   commodity.Quantity%TYPE; -- Quantity for the new child instance

BEGIN
  -- Step 1: Create the new child productInstance
  INSERT INTO productInstance (Product_ID, Date_Manufactured, Is_Recalled)
  VALUES (195.0, TIMESTAMP '2025-01-18 15:17:41', 0)
  RETURNING Instance_ID INTO v_new_child_instance_id;

  -- Step 2: Create the corresponding subtype record
  IF v_child_category = 'Commodity' THEN
    -- Find max existing Batch_Number for this specific Child_PID
    SELECT NVL(MAX(c.Batch_Number), 0) INTO v_max_existing_batch_lot
    FROM commodity c JOIN productInstance pi ON c.Instance_ID = pi.Instance_ID
    WHERE pi.Product_ID = 195.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next batch

    v_expiration_date := TIMESTAMP '2025-01-18 15:17:41' + INTERVAL '302' DAY;
    v_quantity_to_create := ROUND(1.0, 1);

    INSERT INTO commodity (Instance_ID, Batch_Number, Expiration_Date, Quantity)
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Packaged' THEN
    -- Find max existing Lot_Number for this specific Child_PID
    SELECT NVL(MAX(p.Lot_Number), 0) INTO v_max_existing_batch_lot
    FROM packaged p JOIN productInstance pi ON p.Instance_ID = pi.Instance_ID -- Assuming 'packaged' table name
    WHERE pi.Product_ID = 195.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next lot

    v_expiration_date := TIMESTAMP '2025-01-18 15:17:41' + INTERVAL '139' DAY;
    v_quantity_to_create := ROUND(1.0, 1);

    INSERT INTO packaged (Instance_ID, Lot_Number, Expiration_Date, Quantity) -- Assuming 'packaged' table name
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Serialized' THEN
    -- Assign a unique serial number
    -- Using Instance ID guarantees uniqueness within this context
    v_serial_number := 'SN-' || TO_CHAR(195.0) || '-' || TO_CHAR(v_new_child_instance_id) || '-' || SUBSTR(SYS_GUID(),1,8);
    -- Assign a batch number - use Product_ID of the *parent* instance as the batch for simplicity? Or a sequence?
    -- Let's use the Parent_IID itself as a simple batch identifier for this run.
    v_batch_number := 512.0; -- All children created FOR this parent get same batch number

    INSERT INTO serialized (Instance_ID, Serial_Number, Batch_Number)
    VALUES (v_new_child_instance_id, v_serial_number, v_batch_number);

    -- Quantity for usesComponent link for serialized is typically 1
    v_quantity_to_create := 1;

  END IF;

  -- Step 3: Create the usesComponent link
  -- Quantity_Used is the Quantity_Needed from needsComponent (which matches child quantity for non-serialized)
  IF v_child_category IN ('Commodity', 'Packaged', 'Serialized') THEN -- Only insert if subtype was handled
      INSERT INTO usesComponent (Parent_IID, Child_IID, Quantity_Used)
      VALUES (512.0, v_new_child_instance_id, ROUND(1.0, 1)); -- Use rounded quantity needed
  END IF;

EXCEPTION
  WHEN OTHERS THEN
    DBMS_OUTPUT.PUT_LINE('Error processing Parent_IID=' || 512.0 || ', Child_PID=' || 195.0 || ': ' || SQLERRM);
    -- Decide if you want to rollback just this block or let the main exception handler catch it
END;
/
DECLARE
  v_new_child_instance_id productInstance.Instance_ID%TYPE;
  v_child_category        product.Category%TYPE := 'Commodity'; -- Pass category
  v_max_existing_batch_lot NUMBER;
  v_next_batch_lot_num   NUMBER;
  v_serial_number        serialized.Serial_Number%TYPE;
  v_batch_number         serialized.Batch_Number%TYPE; -- Shared batch for serialized children of *this* parent
  v_expiration_date      commodity.Expiration_Date%TYPE;
  v_quantity_to_create   commodity.Quantity%TYPE; -- Quantity for the new child instance

BEGIN
  -- Step 1: Create the new child productInstance
  INSERT INTO productInstance (Product_ID, Date_Manufactured, Is_Recalled)
  VALUES (175.0, TIMESTAMP '2024-07-17 09:35:31', 0)
  RETURNING Instance_ID INTO v_new_child_instance_id;

  -- Step 2: Create the corresponding subtype record
  IF v_child_category = 'Commodity' THEN
    -- Find max existing Batch_Number for this specific Child_PID
    SELECT NVL(MAX(c.Batch_Number), 0) INTO v_max_existing_batch_lot
    FROM commodity c JOIN productInstance pi ON c.Instance_ID = pi.Instance_ID
    WHERE pi.Product_ID = 175.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next batch

    v_expiration_date := TIMESTAMP '2024-07-17 09:35:31' + INTERVAL '297' DAY;
    v_quantity_to_create := ROUND(1.0, 1);

    INSERT INTO commodity (Instance_ID, Batch_Number, Expiration_Date, Quantity)
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Packaged' THEN
    -- Find max existing Lot_Number for this specific Child_PID
    SELECT NVL(MAX(p.Lot_Number), 0) INTO v_max_existing_batch_lot
    FROM packaged p JOIN productInstance pi ON p.Instance_ID = pi.Instance_ID -- Assuming 'packaged' table name
    WHERE pi.Product_ID = 175.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next lot

    v_expiration_date := TIMESTAMP '2024-07-17 09:35:31' + INTERVAL '98' DAY;
    v_quantity_to_create := ROUND(1.0, 1);

    INSERT INTO packaged (Instance_ID, Lot_Number, Expiration_Date, Quantity) -- Assuming 'packaged' table name
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Serialized' THEN
    -- Assign a unique serial number
    -- Using Instance ID guarantees uniqueness within this context
    v_serial_number := 'SN-' || TO_CHAR(175.0) || '-' || TO_CHAR(v_new_child_instance_id) || '-' || SUBSTR(SYS_GUID(),1,8);
    -- Assign a batch number - use Product_ID of the *parent* instance as the batch for simplicity? Or a sequence?
    -- Let's use the Parent_IID itself as a simple batch identifier for this run.
    v_batch_number := 513.0; -- All children created FOR this parent get same batch number

    INSERT INTO serialized (Instance_ID, Serial_Number, Batch_Number)
    VALUES (v_new_child_instance_id, v_serial_number, v_batch_number);

    -- Quantity for usesComponent link for serialized is typically 1
    v_quantity_to_create := 1;

  END IF;

  -- Step 3: Create the usesComponent link
  -- Quantity_Used is the Quantity_Needed from needsComponent (which matches child quantity for non-serialized)
  IF v_child_category IN ('Commodity', 'Packaged', 'Serialized') THEN -- Only insert if subtype was handled
      INSERT INTO usesComponent (Parent_IID, Child_IID, Quantity_Used)
      VALUES (513.0, v_new_child_instance_id, ROUND(1.0, 1)); -- Use rounded quantity needed
  END IF;

EXCEPTION
  WHEN OTHERS THEN
    DBMS_OUTPUT.PUT_LINE('Error processing Parent_IID=' || 513.0 || ', Child_PID=' || 175.0 || ': ' || SQLERRM);
    -- Decide if you want to rollback just this block or let the main exception handler catch it
END;
/
DECLARE
  v_new_child_instance_id productInstance.Instance_ID%TYPE;
  v_child_category        product.Category%TYPE := 'Commodity'; -- Pass category
  v_max_existing_batch_lot NUMBER;
  v_next_batch_lot_num   NUMBER;
  v_serial_number        serialized.Serial_Number%TYPE;
  v_batch_number         serialized.Batch_Number%TYPE; -- Shared batch for serialized children of *this* parent
  v_expiration_date      commodity.Expiration_Date%TYPE;
  v_quantity_to_create   commodity.Quantity%TYPE; -- Quantity for the new child instance

BEGIN
  -- Step 1: Create the new child productInstance
  INSERT INTO productInstance (Product_ID, Date_Manufactured, Is_Recalled)
  VALUES (209.0, TIMESTAMP '2024-12-30 12:56:35', 0)
  RETURNING Instance_ID INTO v_new_child_instance_id;

  -- Step 2: Create the corresponding subtype record
  IF v_child_category = 'Commodity' THEN
    -- Find max existing Batch_Number for this specific Child_PID
    SELECT NVL(MAX(c.Batch_Number), 0) INTO v_max_existing_batch_lot
    FROM commodity c JOIN productInstance pi ON c.Instance_ID = pi.Instance_ID
    WHERE pi.Product_ID = 209.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next batch

    v_expiration_date := TIMESTAMP '2024-12-30 12:56:35' + INTERVAL '614' DAY;
    v_quantity_to_create := ROUND(0.7, 1);

    INSERT INTO commodity (Instance_ID, Batch_Number, Expiration_Date, Quantity)
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Packaged' THEN
    -- Find max existing Lot_Number for this specific Child_PID
    SELECT NVL(MAX(p.Lot_Number), 0) INTO v_max_existing_batch_lot
    FROM packaged p JOIN productInstance pi ON p.Instance_ID = pi.Instance_ID -- Assuming 'packaged' table name
    WHERE pi.Product_ID = 209.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next lot

    v_expiration_date := TIMESTAMP '2024-12-30 12:56:35' + INTERVAL '569' DAY;
    v_quantity_to_create := ROUND(0.7, 1);

    INSERT INTO packaged (Instance_ID, Lot_Number, Expiration_Date, Quantity) -- Assuming 'packaged' table name
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Serialized' THEN
    -- Assign a unique serial number
    -- Using Instance ID guarantees uniqueness within this context
    v_serial_number := 'SN-' || TO_CHAR(209.0) || '-' || TO_CHAR(v_new_child_instance_id) || '-' || SUBSTR(SYS_GUID(),1,8);
    -- Assign a batch number - use Product_ID of the *parent* instance as the batch for simplicity? Or a sequence?
    -- Let's use the Parent_IID itself as a simple batch identifier for this run.
    v_batch_number := 513.0; -- All children created FOR this parent get same batch number

    INSERT INTO serialized (Instance_ID, Serial_Number, Batch_Number)
    VALUES (v_new_child_instance_id, v_serial_number, v_batch_number);

    -- Quantity for usesComponent link for serialized is typically 1
    v_quantity_to_create := 1;

  END IF;

  -- Step 3: Create the usesComponent link
  -- Quantity_Used is the Quantity_Needed from needsComponent (which matches child quantity for non-serialized)
  IF v_child_category IN ('Commodity', 'Packaged', 'Serialized') THEN -- Only insert if subtype was handled
      INSERT INTO usesComponent (Parent_IID, Child_IID, Quantity_Used)
      VALUES (513.0, v_new_child_instance_id, ROUND(0.7, 1)); -- Use rounded quantity needed
  END IF;

EXCEPTION
  WHEN OTHERS THEN
    DBMS_OUTPUT.PUT_LINE('Error processing Parent_IID=' || 513.0 || ', Child_PID=' || 209.0 || ': ' || SQLERRM);
    -- Decide if you want to rollback just this block or let the main exception handler catch it
END;
/
DECLARE
  v_new_child_instance_id productInstance.Instance_ID%TYPE;
  v_child_category        product.Category%TYPE := 'Commodity'; -- Pass category
  v_max_existing_batch_lot NUMBER;
  v_next_batch_lot_num   NUMBER;
  v_serial_number        serialized.Serial_Number%TYPE;
  v_batch_number         serialized.Batch_Number%TYPE; -- Shared batch for serialized children of *this* parent
  v_expiration_date      commodity.Expiration_Date%TYPE;
  v_quantity_to_create   commodity.Quantity%TYPE; -- Quantity for the new child instance

BEGIN
  -- Step 1: Create the new child productInstance
  INSERT INTO productInstance (Product_ID, Date_Manufactured, Is_Recalled)
  VALUES (195.0, TIMESTAMP '2025-01-02 23:48:51', 0)
  RETURNING Instance_ID INTO v_new_child_instance_id;

  -- Step 2: Create the corresponding subtype record
  IF v_child_category = 'Commodity' THEN
    -- Find max existing Batch_Number for this specific Child_PID
    SELECT NVL(MAX(c.Batch_Number), 0) INTO v_max_existing_batch_lot
    FROM commodity c JOIN productInstance pi ON c.Instance_ID = pi.Instance_ID
    WHERE pi.Product_ID = 195.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next batch

    v_expiration_date := TIMESTAMP '2025-01-02 23:48:51' + INTERVAL '110' DAY;
    v_quantity_to_create := ROUND(1.0, 1);

    INSERT INTO commodity (Instance_ID, Batch_Number, Expiration_Date, Quantity)
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Packaged' THEN
    -- Find max existing Lot_Number for this specific Child_PID
    SELECT NVL(MAX(p.Lot_Number), 0) INTO v_max_existing_batch_lot
    FROM packaged p JOIN productInstance pi ON p.Instance_ID = pi.Instance_ID -- Assuming 'packaged' table name
    WHERE pi.Product_ID = 195.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next lot

    v_expiration_date := TIMESTAMP '2025-01-02 23:48:51' + INTERVAL '104' DAY;
    v_quantity_to_create := ROUND(1.0, 1);

    INSERT INTO packaged (Instance_ID, Lot_Number, Expiration_Date, Quantity) -- Assuming 'packaged' table name
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Serialized' THEN
    -- Assign a unique serial number
    -- Using Instance ID guarantees uniqueness within this context
    v_serial_number := 'SN-' || TO_CHAR(195.0) || '-' || TO_CHAR(v_new_child_instance_id) || '-' || SUBSTR(SYS_GUID(),1,8);
    -- Assign a batch number - use Product_ID of the *parent* instance as the batch for simplicity? Or a sequence?
    -- Let's use the Parent_IID itself as a simple batch identifier for this run.
    v_batch_number := 513.0; -- All children created FOR this parent get same batch number

    INSERT INTO serialized (Instance_ID, Serial_Number, Batch_Number)
    VALUES (v_new_child_instance_id, v_serial_number, v_batch_number);

    -- Quantity for usesComponent link for serialized is typically 1
    v_quantity_to_create := 1;

  END IF;

  -- Step 3: Create the usesComponent link
  -- Quantity_Used is the Quantity_Needed from needsComponent (which matches child quantity for non-serialized)
  IF v_child_category IN ('Commodity', 'Packaged', 'Serialized') THEN -- Only insert if subtype was handled
      INSERT INTO usesComponent (Parent_IID, Child_IID, Quantity_Used)
      VALUES (513.0, v_new_child_instance_id, ROUND(1.0, 1)); -- Use rounded quantity needed
  END IF;

EXCEPTION
  WHEN OTHERS THEN
    DBMS_OUTPUT.PUT_LINE('Error processing Parent_IID=' || 513.0 || ', Child_PID=' || 195.0 || ': ' || SQLERRM);
    -- Decide if you want to rollback just this block or let the main exception handler catch it
END;
/
DECLARE
  v_new_child_instance_id productInstance.Instance_ID%TYPE;
  v_child_category        product.Category%TYPE := 'Commodity'; -- Pass category
  v_max_existing_batch_lot NUMBER;
  v_next_batch_lot_num   NUMBER;
  v_serial_number        serialized.Serial_Number%TYPE;
  v_batch_number         serialized.Batch_Number%TYPE; -- Shared batch for serialized children of *this* parent
  v_expiration_date      commodity.Expiration_Date%TYPE;
  v_quantity_to_create   commodity.Quantity%TYPE; -- Quantity for the new child instance

BEGIN
  -- Step 1: Create the new child productInstance
  INSERT INTO productInstance (Product_ID, Date_Manufactured, Is_Recalled)
  VALUES (227.0, TIMESTAMP '2025-03-03 11:33:20', 0)
  RETURNING Instance_ID INTO v_new_child_instance_id;

  -- Step 2: Create the corresponding subtype record
  IF v_child_category = 'Commodity' THEN
    -- Find max existing Batch_Number for this specific Child_PID
    SELECT NVL(MAX(c.Batch_Number), 0) INTO v_max_existing_batch_lot
    FROM commodity c JOIN productInstance pi ON c.Instance_ID = pi.Instance_ID
    WHERE pi.Product_ID = 227.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next batch

    v_expiration_date := TIMESTAMP '2025-03-03 11:33:20' + INTERVAL '252' DAY;
    v_quantity_to_create := ROUND(1.2, 1);

    INSERT INTO commodity (Instance_ID, Batch_Number, Expiration_Date, Quantity)
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Packaged' THEN
    -- Find max existing Lot_Number for this specific Child_PID
    SELECT NVL(MAX(p.Lot_Number), 0) INTO v_max_existing_batch_lot
    FROM packaged p JOIN productInstance pi ON p.Instance_ID = pi.Instance_ID -- Assuming 'packaged' table name
    WHERE pi.Product_ID = 227.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next lot

    v_expiration_date := TIMESTAMP '2025-03-03 11:33:20' + INTERVAL '688' DAY;
    v_quantity_to_create := ROUND(1.2, 1);

    INSERT INTO packaged (Instance_ID, Lot_Number, Expiration_Date, Quantity) -- Assuming 'packaged' table name
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Serialized' THEN
    -- Assign a unique serial number
    -- Using Instance ID guarantees uniqueness within this context
    v_serial_number := 'SN-' || TO_CHAR(227.0) || '-' || TO_CHAR(v_new_child_instance_id) || '-' || SUBSTR(SYS_GUID(),1,8);
    -- Assign a batch number - use Product_ID of the *parent* instance as the batch for simplicity? Or a sequence?
    -- Let's use the Parent_IID itself as a simple batch identifier for this run.
    v_batch_number := 523.0; -- All children created FOR this parent get same batch number

    INSERT INTO serialized (Instance_ID, Serial_Number, Batch_Number)
    VALUES (v_new_child_instance_id, v_serial_number, v_batch_number);

    -- Quantity for usesComponent link for serialized is typically 1
    v_quantity_to_create := 1;

  END IF;

  -- Step 3: Create the usesComponent link
  -- Quantity_Used is the Quantity_Needed from needsComponent (which matches child quantity for non-serialized)
  IF v_child_category IN ('Commodity', 'Packaged', 'Serialized') THEN -- Only insert if subtype was handled
      INSERT INTO usesComponent (Parent_IID, Child_IID, Quantity_Used)
      VALUES (523.0, v_new_child_instance_id, ROUND(1.2, 1)); -- Use rounded quantity needed
  END IF;

EXCEPTION
  WHEN OTHERS THEN
    DBMS_OUTPUT.PUT_LINE('Error processing Parent_IID=' || 523.0 || ', Child_PID=' || 227.0 || ': ' || SQLERRM);
    -- Decide if you want to rollback just this block or let the main exception handler catch it
END;
/
DECLARE
  v_new_child_instance_id productInstance.Instance_ID%TYPE;
  v_child_category        product.Category%TYPE := 'Commodity'; -- Pass category
  v_max_existing_batch_lot NUMBER;
  v_next_batch_lot_num   NUMBER;
  v_serial_number        serialized.Serial_Number%TYPE;
  v_batch_number         serialized.Batch_Number%TYPE; -- Shared batch for serialized children of *this* parent
  v_expiration_date      commodity.Expiration_Date%TYPE;
  v_quantity_to_create   commodity.Quantity%TYPE; -- Quantity for the new child instance

BEGIN
  -- Step 1: Create the new child productInstance
  INSERT INTO productInstance (Product_ID, Date_Manufactured, Is_Recalled)
  VALUES (227.0, TIMESTAMP '2025-03-20 14:08:39', 0)
  RETURNING Instance_ID INTO v_new_child_instance_id;

  -- Step 2: Create the corresponding subtype record
  IF v_child_category = 'Commodity' THEN
    -- Find max existing Batch_Number for this specific Child_PID
    SELECT NVL(MAX(c.Batch_Number), 0) INTO v_max_existing_batch_lot
    FROM commodity c JOIN productInstance pi ON c.Instance_ID = pi.Instance_ID
    WHERE pi.Product_ID = 227.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next batch

    v_expiration_date := TIMESTAMP '2025-03-20 14:08:39' + INTERVAL '207' DAY;
    v_quantity_to_create := ROUND(1.2, 1);

    INSERT INTO commodity (Instance_ID, Batch_Number, Expiration_Date, Quantity)
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Packaged' THEN
    -- Find max existing Lot_Number for this specific Child_PID
    SELECT NVL(MAX(p.Lot_Number), 0) INTO v_max_existing_batch_lot
    FROM packaged p JOIN productInstance pi ON p.Instance_ID = pi.Instance_ID -- Assuming 'packaged' table name
    WHERE pi.Product_ID = 227.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next lot

    v_expiration_date := TIMESTAMP '2025-03-20 14:08:39' + INTERVAL '553' DAY;
    v_quantity_to_create := ROUND(1.2, 1);

    INSERT INTO packaged (Instance_ID, Lot_Number, Expiration_Date, Quantity) -- Assuming 'packaged' table name
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Serialized' THEN
    -- Assign a unique serial number
    -- Using Instance ID guarantees uniqueness within this context
    v_serial_number := 'SN-' || TO_CHAR(227.0) || '-' || TO_CHAR(v_new_child_instance_id) || '-' || SUBSTR(SYS_GUID(),1,8);
    -- Assign a batch number - use Product_ID of the *parent* instance as the batch for simplicity? Or a sequence?
    -- Let's use the Parent_IID itself as a simple batch identifier for this run.
    v_batch_number := 524.0; -- All children created FOR this parent get same batch number

    INSERT INTO serialized (Instance_ID, Serial_Number, Batch_Number)
    VALUES (v_new_child_instance_id, v_serial_number, v_batch_number);

    -- Quantity for usesComponent link for serialized is typically 1
    v_quantity_to_create := 1;

  END IF;

  -- Step 3: Create the usesComponent link
  -- Quantity_Used is the Quantity_Needed from needsComponent (which matches child quantity for non-serialized)
  IF v_child_category IN ('Commodity', 'Packaged', 'Serialized') THEN -- Only insert if subtype was handled
      INSERT INTO usesComponent (Parent_IID, Child_IID, Quantity_Used)
      VALUES (524.0, v_new_child_instance_id, ROUND(1.2, 1)); -- Use rounded quantity needed
  END IF;

EXCEPTION
  WHEN OTHERS THEN
    DBMS_OUTPUT.PUT_LINE('Error processing Parent_IID=' || 524.0 || ', Child_PID=' || 227.0 || ': ' || SQLERRM);
    -- Decide if you want to rollback just this block or let the main exception handler catch it
END;
/
DECLARE
  v_new_child_instance_id productInstance.Instance_ID%TYPE;
  v_child_category        product.Category%TYPE := 'Commodity'; -- Pass category
  v_max_existing_batch_lot NUMBER;
  v_next_batch_lot_num   NUMBER;
  v_serial_number        serialized.Serial_Number%TYPE;
  v_batch_number         serialized.Batch_Number%TYPE; -- Shared batch for serialized children of *this* parent
  v_expiration_date      commodity.Expiration_Date%TYPE;
  v_quantity_to_create   commodity.Quantity%TYPE; -- Quantity for the new child instance

BEGIN
  -- Step 1: Create the new child productInstance
  INSERT INTO productInstance (Product_ID, Date_Manufactured, Is_Recalled)
  VALUES (184.0, TIMESTAMP '2025-03-29 17:50:12', 0)
  RETURNING Instance_ID INTO v_new_child_instance_id;

  -- Step 2: Create the corresponding subtype record
  IF v_child_category = 'Commodity' THEN
    -- Find max existing Batch_Number for this specific Child_PID
    SELECT NVL(MAX(c.Batch_Number), 0) INTO v_max_existing_batch_lot
    FROM commodity c JOIN productInstance pi ON c.Instance_ID = pi.Instance_ID
    WHERE pi.Product_ID = 184.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next batch

    v_expiration_date := TIMESTAMP '2025-03-29 17:50:12' + INTERVAL '472' DAY;
    v_quantity_to_create := ROUND(1.1, 1);

    INSERT INTO commodity (Instance_ID, Batch_Number, Expiration_Date, Quantity)
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Packaged' THEN
    -- Find max existing Lot_Number for this specific Child_PID
    SELECT NVL(MAX(p.Lot_Number), 0) INTO v_max_existing_batch_lot
    FROM packaged p JOIN productInstance pi ON p.Instance_ID = pi.Instance_ID -- Assuming 'packaged' table name
    WHERE pi.Product_ID = 184.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next lot

    v_expiration_date := TIMESTAMP '2025-03-29 17:50:12' + INTERVAL '52' DAY;
    v_quantity_to_create := ROUND(1.1, 1);

    INSERT INTO packaged (Instance_ID, Lot_Number, Expiration_Date, Quantity) -- Assuming 'packaged' table name
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Serialized' THEN
    -- Assign a unique serial number
    -- Using Instance ID guarantees uniqueness within this context
    v_serial_number := 'SN-' || TO_CHAR(184.0) || '-' || TO_CHAR(v_new_child_instance_id) || '-' || SUBSTR(SYS_GUID(),1,8);
    -- Assign a batch number - use Product_ID of the *parent* instance as the batch for simplicity? Or a sequence?
    -- Let's use the Parent_IID itself as a simple batch identifier for this run.
    v_batch_number := 528.0; -- All children created FOR this parent get same batch number

    INSERT INTO serialized (Instance_ID, Serial_Number, Batch_Number)
    VALUES (v_new_child_instance_id, v_serial_number, v_batch_number);

    -- Quantity for usesComponent link for serialized is typically 1
    v_quantity_to_create := 1;

  END IF;

  -- Step 3: Create the usesComponent link
  -- Quantity_Used is the Quantity_Needed from needsComponent (which matches child quantity for non-serialized)
  IF v_child_category IN ('Commodity', 'Packaged', 'Serialized') THEN -- Only insert if subtype was handled
      INSERT INTO usesComponent (Parent_IID, Child_IID, Quantity_Used)
      VALUES (528.0, v_new_child_instance_id, ROUND(1.1, 1)); -- Use rounded quantity needed
  END IF;

EXCEPTION
  WHEN OTHERS THEN
    DBMS_OUTPUT.PUT_LINE('Error processing Parent_IID=' || 528.0 || ', Child_PID=' || 184.0 || ': ' || SQLERRM);
    -- Decide if you want to rollback just this block or let the main exception handler catch it
END;
/
DECLARE
  v_new_child_instance_id productInstance.Instance_ID%TYPE;
  v_child_category        product.Category%TYPE := 'Commodity'; -- Pass category
  v_max_existing_batch_lot NUMBER;
  v_next_batch_lot_num   NUMBER;
  v_serial_number        serialized.Serial_Number%TYPE;
  v_batch_number         serialized.Batch_Number%TYPE; -- Shared batch for serialized children of *this* parent
  v_expiration_date      commodity.Expiration_Date%TYPE;
  v_quantity_to_create   commodity.Quantity%TYPE; -- Quantity for the new child instance

BEGIN
  -- Step 1: Create the new child productInstance
  INSERT INTO productInstance (Product_ID, Date_Manufactured, Is_Recalled)
  VALUES (145.0, TIMESTAMP '2024-12-14 07:30:25', 0)
  RETURNING Instance_ID INTO v_new_child_instance_id;

  -- Step 2: Create the corresponding subtype record
  IF v_child_category = 'Commodity' THEN
    -- Find max existing Batch_Number for this specific Child_PID
    SELECT NVL(MAX(c.Batch_Number), 0) INTO v_max_existing_batch_lot
    FROM commodity c JOIN productInstance pi ON c.Instance_ID = pi.Instance_ID
    WHERE pi.Product_ID = 145.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next batch

    v_expiration_date := TIMESTAMP '2024-12-14 07:30:25' + INTERVAL '406' DAY;
    v_quantity_to_create := ROUND(0.8, 1);

    INSERT INTO commodity (Instance_ID, Batch_Number, Expiration_Date, Quantity)
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Packaged' THEN
    -- Find max existing Lot_Number for this specific Child_PID
    SELECT NVL(MAX(p.Lot_Number), 0) INTO v_max_existing_batch_lot
    FROM packaged p JOIN productInstance pi ON p.Instance_ID = pi.Instance_ID -- Assuming 'packaged' table name
    WHERE pi.Product_ID = 145.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next lot

    v_expiration_date := TIMESTAMP '2024-12-14 07:30:25' + INTERVAL '528' DAY;
    v_quantity_to_create := ROUND(0.8, 1);

    INSERT INTO packaged (Instance_ID, Lot_Number, Expiration_Date, Quantity) -- Assuming 'packaged' table name
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Serialized' THEN
    -- Assign a unique serial number
    -- Using Instance ID guarantees uniqueness within this context
    v_serial_number := 'SN-' || TO_CHAR(145.0) || '-' || TO_CHAR(v_new_child_instance_id) || '-' || SUBSTR(SYS_GUID(),1,8);
    -- Assign a batch number - use Product_ID of the *parent* instance as the batch for simplicity? Or a sequence?
    -- Let's use the Parent_IID itself as a simple batch identifier for this run.
    v_batch_number := 528.0; -- All children created FOR this parent get same batch number

    INSERT INTO serialized (Instance_ID, Serial_Number, Batch_Number)
    VALUES (v_new_child_instance_id, v_serial_number, v_batch_number);

    -- Quantity for usesComponent link for serialized is typically 1
    v_quantity_to_create := 1;

  END IF;

  -- Step 3: Create the usesComponent link
  -- Quantity_Used is the Quantity_Needed from needsComponent (which matches child quantity for non-serialized)
  IF v_child_category IN ('Commodity', 'Packaged', 'Serialized') THEN -- Only insert if subtype was handled
      INSERT INTO usesComponent (Parent_IID, Child_IID, Quantity_Used)
      VALUES (528.0, v_new_child_instance_id, ROUND(0.8, 1)); -- Use rounded quantity needed
  END IF;

EXCEPTION
  WHEN OTHERS THEN
    DBMS_OUTPUT.PUT_LINE('Error processing Parent_IID=' || 528.0 || ', Child_PID=' || 145.0 || ': ' || SQLERRM);
    -- Decide if you want to rollback just this block or let the main exception handler catch it
END;
/
DECLARE
  v_new_child_instance_id productInstance.Instance_ID%TYPE;
  v_child_category        product.Category%TYPE := 'Commodity'; -- Pass category
  v_max_existing_batch_lot NUMBER;
  v_next_batch_lot_num   NUMBER;
  v_serial_number        serialized.Serial_Number%TYPE;
  v_batch_number         serialized.Batch_Number%TYPE; -- Shared batch for serialized children of *this* parent
  v_expiration_date      commodity.Expiration_Date%TYPE;
  v_quantity_to_create   commodity.Quantity%TYPE; -- Quantity for the new child instance

BEGIN
  -- Step 1: Create the new child productInstance
  INSERT INTO productInstance (Product_ID, Date_Manufactured, Is_Recalled)
  VALUES (184.0, TIMESTAMP '2025-01-29 21:14:08', 0)
  RETURNING Instance_ID INTO v_new_child_instance_id;

  -- Step 2: Create the corresponding subtype record
  IF v_child_category = 'Commodity' THEN
    -- Find max existing Batch_Number for this specific Child_PID
    SELECT NVL(MAX(c.Batch_Number), 0) INTO v_max_existing_batch_lot
    FROM commodity c JOIN productInstance pi ON c.Instance_ID = pi.Instance_ID
    WHERE pi.Product_ID = 184.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next batch

    v_expiration_date := TIMESTAMP '2025-01-29 21:14:08' + INTERVAL '320' DAY;
    v_quantity_to_create := ROUND(1.1, 1);

    INSERT INTO commodity (Instance_ID, Batch_Number, Expiration_Date, Quantity)
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Packaged' THEN
    -- Find max existing Lot_Number for this specific Child_PID
    SELECT NVL(MAX(p.Lot_Number), 0) INTO v_max_existing_batch_lot
    FROM packaged p JOIN productInstance pi ON p.Instance_ID = pi.Instance_ID -- Assuming 'packaged' table name
    WHERE pi.Product_ID = 184.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next lot

    v_expiration_date := TIMESTAMP '2025-01-29 21:14:08' + INTERVAL '255' DAY;
    v_quantity_to_create := ROUND(1.1, 1);

    INSERT INTO packaged (Instance_ID, Lot_Number, Expiration_Date, Quantity) -- Assuming 'packaged' table name
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Serialized' THEN
    -- Assign a unique serial number
    -- Using Instance ID guarantees uniqueness within this context
    v_serial_number := 'SN-' || TO_CHAR(184.0) || '-' || TO_CHAR(v_new_child_instance_id) || '-' || SUBSTR(SYS_GUID(),1,8);
    -- Assign a batch number - use Product_ID of the *parent* instance as the batch for simplicity? Or a sequence?
    -- Let's use the Parent_IID itself as a simple batch identifier for this run.
    v_batch_number := 529.0; -- All children created FOR this parent get same batch number

    INSERT INTO serialized (Instance_ID, Serial_Number, Batch_Number)
    VALUES (v_new_child_instance_id, v_serial_number, v_batch_number);

    -- Quantity for usesComponent link for serialized is typically 1
    v_quantity_to_create := 1;

  END IF;

  -- Step 3: Create the usesComponent link
  -- Quantity_Used is the Quantity_Needed from needsComponent (which matches child quantity for non-serialized)
  IF v_child_category IN ('Commodity', 'Packaged', 'Serialized') THEN -- Only insert if subtype was handled
      INSERT INTO usesComponent (Parent_IID, Child_IID, Quantity_Used)
      VALUES (529.0, v_new_child_instance_id, ROUND(1.1, 1)); -- Use rounded quantity needed
  END IF;

EXCEPTION
  WHEN OTHERS THEN
    DBMS_OUTPUT.PUT_LINE('Error processing Parent_IID=' || 529.0 || ', Child_PID=' || 184.0 || ': ' || SQLERRM);
    -- Decide if you want to rollback just this block or let the main exception handler catch it
END;
/
DECLARE
  v_new_child_instance_id productInstance.Instance_ID%TYPE;
  v_child_category        product.Category%TYPE := 'Commodity'; -- Pass category
  v_max_existing_batch_lot NUMBER;
  v_next_batch_lot_num   NUMBER;
  v_serial_number        serialized.Serial_Number%TYPE;
  v_batch_number         serialized.Batch_Number%TYPE; -- Shared batch for serialized children of *this* parent
  v_expiration_date      commodity.Expiration_Date%TYPE;
  v_quantity_to_create   commodity.Quantity%TYPE; -- Quantity for the new child instance

BEGIN
  -- Step 1: Create the new child productInstance
  INSERT INTO productInstance (Product_ID, Date_Manufactured, Is_Recalled)
  VALUES (145.0, TIMESTAMP '2025-04-10 04:18:24', 0)
  RETURNING Instance_ID INTO v_new_child_instance_id;

  -- Step 2: Create the corresponding subtype record
  IF v_child_category = 'Commodity' THEN
    -- Find max existing Batch_Number for this specific Child_PID
    SELECT NVL(MAX(c.Batch_Number), 0) INTO v_max_existing_batch_lot
    FROM commodity c JOIN productInstance pi ON c.Instance_ID = pi.Instance_ID
    WHERE pi.Product_ID = 145.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next batch

    v_expiration_date := TIMESTAMP '2025-04-10 04:18:24' + INTERVAL '235' DAY;
    v_quantity_to_create := ROUND(0.8, 1);

    INSERT INTO commodity (Instance_ID, Batch_Number, Expiration_Date, Quantity)
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Packaged' THEN
    -- Find max existing Lot_Number for this specific Child_PID
    SELECT NVL(MAX(p.Lot_Number), 0) INTO v_max_existing_batch_lot
    FROM packaged p JOIN productInstance pi ON p.Instance_ID = pi.Instance_ID -- Assuming 'packaged' table name
    WHERE pi.Product_ID = 145.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next lot

    v_expiration_date := TIMESTAMP '2025-04-10 04:18:24' + INTERVAL '642' DAY;
    v_quantity_to_create := ROUND(0.8, 1);

    INSERT INTO packaged (Instance_ID, Lot_Number, Expiration_Date, Quantity) -- Assuming 'packaged' table name
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Serialized' THEN
    -- Assign a unique serial number
    -- Using Instance ID guarantees uniqueness within this context
    v_serial_number := 'SN-' || TO_CHAR(145.0) || '-' || TO_CHAR(v_new_child_instance_id) || '-' || SUBSTR(SYS_GUID(),1,8);
    -- Assign a batch number - use Product_ID of the *parent* instance as the batch for simplicity? Or a sequence?
    -- Let's use the Parent_IID itself as a simple batch identifier for this run.
    v_batch_number := 529.0; -- All children created FOR this parent get same batch number

    INSERT INTO serialized (Instance_ID, Serial_Number, Batch_Number)
    VALUES (v_new_child_instance_id, v_serial_number, v_batch_number);

    -- Quantity for usesComponent link for serialized is typically 1
    v_quantity_to_create := 1;

  END IF;

  -- Step 3: Create the usesComponent link
  -- Quantity_Used is the Quantity_Needed from needsComponent (which matches child quantity for non-serialized)
  IF v_child_category IN ('Commodity', 'Packaged', 'Serialized') THEN -- Only insert if subtype was handled
      INSERT INTO usesComponent (Parent_IID, Child_IID, Quantity_Used)
      VALUES (529.0, v_new_child_instance_id, ROUND(0.8, 1)); -- Use rounded quantity needed
  END IF;

EXCEPTION
  WHEN OTHERS THEN
    DBMS_OUTPUT.PUT_LINE('Error processing Parent_IID=' || 529.0 || ', Child_PID=' || 145.0 || ': ' || SQLERRM);
    -- Decide if you want to rollback just this block or let the main exception handler catch it
END;
/
DECLARE
  v_new_child_instance_id productInstance.Instance_ID%TYPE;
  v_child_category        product.Category%TYPE := 'Commodity'; -- Pass category
  v_max_existing_batch_lot NUMBER;
  v_next_batch_lot_num   NUMBER;
  v_serial_number        serialized.Serial_Number%TYPE;
  v_batch_number         serialized.Batch_Number%TYPE; -- Shared batch for serialized children of *this* parent
  v_expiration_date      commodity.Expiration_Date%TYPE;
  v_quantity_to_create   commodity.Quantity%TYPE; -- Quantity for the new child instance

BEGIN
  -- Step 1: Create the new child productInstance
  INSERT INTO productInstance (Product_ID, Date_Manufactured, Is_Recalled)
  VALUES (184.0, TIMESTAMP '2024-11-06 17:47:22', 0)
  RETURNING Instance_ID INTO v_new_child_instance_id;

  -- Step 2: Create the corresponding subtype record
  IF v_child_category = 'Commodity' THEN
    -- Find max existing Batch_Number for this specific Child_PID
    SELECT NVL(MAX(c.Batch_Number), 0) INTO v_max_existing_batch_lot
    FROM commodity c JOIN productInstance pi ON c.Instance_ID = pi.Instance_ID
    WHERE pi.Product_ID = 184.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next batch

    v_expiration_date := TIMESTAMP '2024-11-06 17:47:22' + INTERVAL '270' DAY;
    v_quantity_to_create := ROUND(1.1, 1);

    INSERT INTO commodity (Instance_ID, Batch_Number, Expiration_Date, Quantity)
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Packaged' THEN
    -- Find max existing Lot_Number for this specific Child_PID
    SELECT NVL(MAX(p.Lot_Number), 0) INTO v_max_existing_batch_lot
    FROM packaged p JOIN productInstance pi ON p.Instance_ID = pi.Instance_ID -- Assuming 'packaged' table name
    WHERE pi.Product_ID = 184.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next lot

    v_expiration_date := TIMESTAMP '2024-11-06 17:47:22' + INTERVAL '465' DAY;
    v_quantity_to_create := ROUND(1.1, 1);

    INSERT INTO packaged (Instance_ID, Lot_Number, Expiration_Date, Quantity) -- Assuming 'packaged' table name
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Serialized' THEN
    -- Assign a unique serial number
    -- Using Instance ID guarantees uniqueness within this context
    v_serial_number := 'SN-' || TO_CHAR(184.0) || '-' || TO_CHAR(v_new_child_instance_id) || '-' || SUBSTR(SYS_GUID(),1,8);
    -- Assign a batch number - use Product_ID of the *parent* instance as the batch for simplicity? Or a sequence?
    -- Let's use the Parent_IID itself as a simple batch identifier for this run.
    v_batch_number := 530.0; -- All children created FOR this parent get same batch number

    INSERT INTO serialized (Instance_ID, Serial_Number, Batch_Number)
    VALUES (v_new_child_instance_id, v_serial_number, v_batch_number);

    -- Quantity for usesComponent link for serialized is typically 1
    v_quantity_to_create := 1;

  END IF;

  -- Step 3: Create the usesComponent link
  -- Quantity_Used is the Quantity_Needed from needsComponent (which matches child quantity for non-serialized)
  IF v_child_category IN ('Commodity', 'Packaged', 'Serialized') THEN -- Only insert if subtype was handled
      INSERT INTO usesComponent (Parent_IID, Child_IID, Quantity_Used)
      VALUES (530.0, v_new_child_instance_id, ROUND(1.1, 1)); -- Use rounded quantity needed
  END IF;

EXCEPTION
  WHEN OTHERS THEN
    DBMS_OUTPUT.PUT_LINE('Error processing Parent_IID=' || 530.0 || ', Child_PID=' || 184.0 || ': ' || SQLERRM);
    -- Decide if you want to rollback just this block or let the main exception handler catch it
END;
/
DECLARE
  v_new_child_instance_id productInstance.Instance_ID%TYPE;
  v_child_category        product.Category%TYPE := 'Commodity'; -- Pass category
  v_max_existing_batch_lot NUMBER;
  v_next_batch_lot_num   NUMBER;
  v_serial_number        serialized.Serial_Number%TYPE;
  v_batch_number         serialized.Batch_Number%TYPE; -- Shared batch for serialized children of *this* parent
  v_expiration_date      commodity.Expiration_Date%TYPE;
  v_quantity_to_create   commodity.Quantity%TYPE; -- Quantity for the new child instance

BEGIN
  -- Step 1: Create the new child productInstance
  INSERT INTO productInstance (Product_ID, Date_Manufactured, Is_Recalled)
  VALUES (145.0, TIMESTAMP '2024-10-21 15:42:41', 0)
  RETURNING Instance_ID INTO v_new_child_instance_id;

  -- Step 2: Create the corresponding subtype record
  IF v_child_category = 'Commodity' THEN
    -- Find max existing Batch_Number for this specific Child_PID
    SELECT NVL(MAX(c.Batch_Number), 0) INTO v_max_existing_batch_lot
    FROM commodity c JOIN productInstance pi ON c.Instance_ID = pi.Instance_ID
    WHERE pi.Product_ID = 145.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next batch

    v_expiration_date := TIMESTAMP '2024-10-21 15:42:41' + INTERVAL '721' DAY;
    v_quantity_to_create := ROUND(0.8, 1);

    INSERT INTO commodity (Instance_ID, Batch_Number, Expiration_Date, Quantity)
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Packaged' THEN
    -- Find max existing Lot_Number for this specific Child_PID
    SELECT NVL(MAX(p.Lot_Number), 0) INTO v_max_existing_batch_lot
    FROM packaged p JOIN productInstance pi ON p.Instance_ID = pi.Instance_ID -- Assuming 'packaged' table name
    WHERE pi.Product_ID = 145.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next lot

    v_expiration_date := TIMESTAMP '2024-10-21 15:42:41' + INTERVAL '405' DAY;
    v_quantity_to_create := ROUND(0.8, 1);

    INSERT INTO packaged (Instance_ID, Lot_Number, Expiration_Date, Quantity) -- Assuming 'packaged' table name
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Serialized' THEN
    -- Assign a unique serial number
    -- Using Instance ID guarantees uniqueness within this context
    v_serial_number := 'SN-' || TO_CHAR(145.0) || '-' || TO_CHAR(v_new_child_instance_id) || '-' || SUBSTR(SYS_GUID(),1,8);
    -- Assign a batch number - use Product_ID of the *parent* instance as the batch for simplicity? Or a sequence?
    -- Let's use the Parent_IID itself as a simple batch identifier for this run.
    v_batch_number := 530.0; -- All children created FOR this parent get same batch number

    INSERT INTO serialized (Instance_ID, Serial_Number, Batch_Number)
    VALUES (v_new_child_instance_id, v_serial_number, v_batch_number);

    -- Quantity for usesComponent link for serialized is typically 1
    v_quantity_to_create := 1;

  END IF;

  -- Step 3: Create the usesComponent link
  -- Quantity_Used is the Quantity_Needed from needsComponent (which matches child quantity for non-serialized)
  IF v_child_category IN ('Commodity', 'Packaged', 'Serialized') THEN -- Only insert if subtype was handled
      INSERT INTO usesComponent (Parent_IID, Child_IID, Quantity_Used)
      VALUES (530.0, v_new_child_instance_id, ROUND(0.8, 1)); -- Use rounded quantity needed
  END IF;

EXCEPTION
  WHEN OTHERS THEN
    DBMS_OUTPUT.PUT_LINE('Error processing Parent_IID=' || 530.0 || ', Child_PID=' || 145.0 || ': ' || SQLERRM);
    -- Decide if you want to rollback just this block or let the main exception handler catch it
END;
/
DECLARE
  v_new_child_instance_id productInstance.Instance_ID%TYPE;
  v_child_category        product.Category%TYPE := 'Commodity'; -- Pass category
  v_max_existing_batch_lot NUMBER;
  v_next_batch_lot_num   NUMBER;
  v_serial_number        serialized.Serial_Number%TYPE;
  v_batch_number         serialized.Batch_Number%TYPE; -- Shared batch for serialized children of *this* parent
  v_expiration_date      commodity.Expiration_Date%TYPE;
  v_quantity_to_create   commodity.Quantity%TYPE; -- Quantity for the new child instance

BEGIN
  -- Step 1: Create the new child productInstance
  INSERT INTO productInstance (Product_ID, Date_Manufactured, Is_Recalled)
  VALUES (601.0, TIMESTAMP '2024-11-26 11:50:53', 0)
  RETURNING Instance_ID INTO v_new_child_instance_id;

  -- Step 2: Create the corresponding subtype record
  IF v_child_category = 'Commodity' THEN
    -- Find max existing Batch_Number for this specific Child_PID
    SELECT NVL(MAX(c.Batch_Number), 0) INTO v_max_existing_batch_lot
    FROM commodity c JOIN productInstance pi ON c.Instance_ID = pi.Instance_ID
    WHERE pi.Product_ID = 601.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next batch

    v_expiration_date := TIMESTAMP '2024-11-26 11:50:53' + INTERVAL '223' DAY;
    v_quantity_to_create := ROUND(1.6, 1);

    INSERT INTO commodity (Instance_ID, Batch_Number, Expiration_Date, Quantity)
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Packaged' THEN
    -- Find max existing Lot_Number for this specific Child_PID
    SELECT NVL(MAX(p.Lot_Number), 0) INTO v_max_existing_batch_lot
    FROM packaged p JOIN productInstance pi ON p.Instance_ID = pi.Instance_ID -- Assuming 'packaged' table name
    WHERE pi.Product_ID = 601.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next lot

    v_expiration_date := TIMESTAMP '2024-11-26 11:50:53' + INTERVAL '523' DAY;
    v_quantity_to_create := ROUND(1.6, 1);

    INSERT INTO packaged (Instance_ID, Lot_Number, Expiration_Date, Quantity) -- Assuming 'packaged' table name
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Serialized' THEN
    -- Assign a unique serial number
    -- Using Instance ID guarantees uniqueness within this context
    v_serial_number := 'SN-' || TO_CHAR(601.0) || '-' || TO_CHAR(v_new_child_instance_id) || '-' || SUBSTR(SYS_GUID(),1,8);
    -- Assign a batch number - use Product_ID of the *parent* instance as the batch for simplicity? Or a sequence?
    -- Let's use the Parent_IID itself as a simple batch identifier for this run.
    v_batch_number := 539.0; -- All children created FOR this parent get same batch number

    INSERT INTO serialized (Instance_ID, Serial_Number, Batch_Number)
    VALUES (v_new_child_instance_id, v_serial_number, v_batch_number);

    -- Quantity for usesComponent link for serialized is typically 1
    v_quantity_to_create := 1;

  END IF;

  -- Step 3: Create the usesComponent link
  -- Quantity_Used is the Quantity_Needed from needsComponent (which matches child quantity for non-serialized)
  IF v_child_category IN ('Commodity', 'Packaged', 'Serialized') THEN -- Only insert if subtype was handled
      INSERT INTO usesComponent (Parent_IID, Child_IID, Quantity_Used)
      VALUES (539.0, v_new_child_instance_id, ROUND(1.6, 1)); -- Use rounded quantity needed
  END IF;

EXCEPTION
  WHEN OTHERS THEN
    DBMS_OUTPUT.PUT_LINE('Error processing Parent_IID=' || 539.0 || ', Child_PID=' || 601.0 || ': ' || SQLERRM);
    -- Decide if you want to rollback just this block or let the main exception handler catch it
END;
/
DECLARE
  v_new_child_instance_id productInstance.Instance_ID%TYPE;
  v_child_category        product.Category%TYPE := 'Commodity'; -- Pass category
  v_max_existing_batch_lot NUMBER;
  v_next_batch_lot_num   NUMBER;
  v_serial_number        serialized.Serial_Number%TYPE;
  v_batch_number         serialized.Batch_Number%TYPE; -- Shared batch for serialized children of *this* parent
  v_expiration_date      commodity.Expiration_Date%TYPE;
  v_quantity_to_create   commodity.Quantity%TYPE; -- Quantity for the new child instance

BEGIN
  -- Step 1: Create the new child productInstance
  INSERT INTO productInstance (Product_ID, Date_Manufactured, Is_Recalled)
  VALUES (601.0, TIMESTAMP '2025-02-04 22:04:47', 0)
  RETURNING Instance_ID INTO v_new_child_instance_id;

  -- Step 2: Create the corresponding subtype record
  IF v_child_category = 'Commodity' THEN
    -- Find max existing Batch_Number for this specific Child_PID
    SELECT NVL(MAX(c.Batch_Number), 0) INTO v_max_existing_batch_lot
    FROM commodity c JOIN productInstance pi ON c.Instance_ID = pi.Instance_ID
    WHERE pi.Product_ID = 601.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next batch

    v_expiration_date := TIMESTAMP '2025-02-04 22:04:47' + INTERVAL '104' DAY;
    v_quantity_to_create := ROUND(1.6, 1);

    INSERT INTO commodity (Instance_ID, Batch_Number, Expiration_Date, Quantity)
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Packaged' THEN
    -- Find max existing Lot_Number for this specific Child_PID
    SELECT NVL(MAX(p.Lot_Number), 0) INTO v_max_existing_batch_lot
    FROM packaged p JOIN productInstance pi ON p.Instance_ID = pi.Instance_ID -- Assuming 'packaged' table name
    WHERE pi.Product_ID = 601.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next lot

    v_expiration_date := TIMESTAMP '2025-02-04 22:04:47' + INTERVAL '292' DAY;
    v_quantity_to_create := ROUND(1.6, 1);

    INSERT INTO packaged (Instance_ID, Lot_Number, Expiration_Date, Quantity) -- Assuming 'packaged' table name
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Serialized' THEN
    -- Assign a unique serial number
    -- Using Instance ID guarantees uniqueness within this context
    v_serial_number := 'SN-' || TO_CHAR(601.0) || '-' || TO_CHAR(v_new_child_instance_id) || '-' || SUBSTR(SYS_GUID(),1,8);
    -- Assign a batch number - use Product_ID of the *parent* instance as the batch for simplicity? Or a sequence?
    -- Let's use the Parent_IID itself as a simple batch identifier for this run.
    v_batch_number := 540.0; -- All children created FOR this parent get same batch number

    INSERT INTO serialized (Instance_ID, Serial_Number, Batch_Number)
    VALUES (v_new_child_instance_id, v_serial_number, v_batch_number);

    -- Quantity for usesComponent link for serialized is typically 1
    v_quantity_to_create := 1;

  END IF;

  -- Step 3: Create the usesComponent link
  -- Quantity_Used is the Quantity_Needed from needsComponent (which matches child quantity for non-serialized)
  IF v_child_category IN ('Commodity', 'Packaged', 'Serialized') THEN -- Only insert if subtype was handled
      INSERT INTO usesComponent (Parent_IID, Child_IID, Quantity_Used)
      VALUES (540.0, v_new_child_instance_id, ROUND(1.6, 1)); -- Use rounded quantity needed
  END IF;

EXCEPTION
  WHEN OTHERS THEN
    DBMS_OUTPUT.PUT_LINE('Error processing Parent_IID=' || 540.0 || ', Child_PID=' || 601.0 || ': ' || SQLERRM);
    -- Decide if you want to rollback just this block or let the main exception handler catch it
END;
/
DECLARE
  v_new_child_instance_id productInstance.Instance_ID%TYPE;
  v_child_category        product.Category%TYPE := 'Commodity'; -- Pass category
  v_max_existing_batch_lot NUMBER;
  v_next_batch_lot_num   NUMBER;
  v_serial_number        serialized.Serial_Number%TYPE;
  v_batch_number         serialized.Batch_Number%TYPE; -- Shared batch for serialized children of *this* parent
  v_expiration_date      commodity.Expiration_Date%TYPE;
  v_quantity_to_create   commodity.Quantity%TYPE; -- Quantity for the new child instance

BEGIN
  -- Step 1: Create the new child productInstance
  INSERT INTO productInstance (Product_ID, Date_Manufactured, Is_Recalled)
  VALUES (601.0, TIMESTAMP '2024-10-04 05:22:08', 0)
  RETURNING Instance_ID INTO v_new_child_instance_id;

  -- Step 2: Create the corresponding subtype record
  IF v_child_category = 'Commodity' THEN
    -- Find max existing Batch_Number for this specific Child_PID
    SELECT NVL(MAX(c.Batch_Number), 0) INTO v_max_existing_batch_lot
    FROM commodity c JOIN productInstance pi ON c.Instance_ID = pi.Instance_ID
    WHERE pi.Product_ID = 601.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next batch

    v_expiration_date := TIMESTAMP '2024-10-04 05:22:08' + INTERVAL '236' DAY;
    v_quantity_to_create := ROUND(1.6, 1);

    INSERT INTO commodity (Instance_ID, Batch_Number, Expiration_Date, Quantity)
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Packaged' THEN
    -- Find max existing Lot_Number for this specific Child_PID
    SELECT NVL(MAX(p.Lot_Number), 0) INTO v_max_existing_batch_lot
    FROM packaged p JOIN productInstance pi ON p.Instance_ID = pi.Instance_ID -- Assuming 'packaged' table name
    WHERE pi.Product_ID = 601.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next lot

    v_expiration_date := TIMESTAMP '2024-10-04 05:22:08' + INTERVAL '38' DAY;
    v_quantity_to_create := ROUND(1.6, 1);

    INSERT INTO packaged (Instance_ID, Lot_Number, Expiration_Date, Quantity) -- Assuming 'packaged' table name
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Serialized' THEN
    -- Assign a unique serial number
    -- Using Instance ID guarantees uniqueness within this context
    v_serial_number := 'SN-' || TO_CHAR(601.0) || '-' || TO_CHAR(v_new_child_instance_id) || '-' || SUBSTR(SYS_GUID(),1,8);
    -- Assign a batch number - use Product_ID of the *parent* instance as the batch for simplicity? Or a sequence?
    -- Let's use the Parent_IID itself as a simple batch identifier for this run.
    v_batch_number := 541.0; -- All children created FOR this parent get same batch number

    INSERT INTO serialized (Instance_ID, Serial_Number, Batch_Number)
    VALUES (v_new_child_instance_id, v_serial_number, v_batch_number);

    -- Quantity for usesComponent link for serialized is typically 1
    v_quantity_to_create := 1;

  END IF;

  -- Step 3: Create the usesComponent link
  -- Quantity_Used is the Quantity_Needed from needsComponent (which matches child quantity for non-serialized)
  IF v_child_category IN ('Commodity', 'Packaged', 'Serialized') THEN -- Only insert if subtype was handled
      INSERT INTO usesComponent (Parent_IID, Child_IID, Quantity_Used)
      VALUES (541.0, v_new_child_instance_id, ROUND(1.6, 1)); -- Use rounded quantity needed
  END IF;

EXCEPTION
  WHEN OTHERS THEN
    DBMS_OUTPUT.PUT_LINE('Error processing Parent_IID=' || 541.0 || ', Child_PID=' || 601.0 || ': ' || SQLERRM);
    -- Decide if you want to rollback just this block or let the main exception handler catch it
END;
/
DECLARE
  v_new_child_instance_id productInstance.Instance_ID%TYPE;
  v_child_category        product.Category%TYPE := 'Commodity'; -- Pass category
  v_max_existing_batch_lot NUMBER;
  v_next_batch_lot_num   NUMBER;
  v_serial_number        serialized.Serial_Number%TYPE;
  v_batch_number         serialized.Batch_Number%TYPE; -- Shared batch for serialized children of *this* parent
  v_expiration_date      commodity.Expiration_Date%TYPE;
  v_quantity_to_create   commodity.Quantity%TYPE; -- Quantity for the new child instance

BEGIN
  -- Step 1: Create the new child productInstance
  INSERT INTO productInstance (Product_ID, Date_Manufactured, Is_Recalled)
  VALUES (601.0, TIMESTAMP '2025-02-13 01:28:53', 0)
  RETURNING Instance_ID INTO v_new_child_instance_id;

  -- Step 2: Create the corresponding subtype record
  IF v_child_category = 'Commodity' THEN
    -- Find max existing Batch_Number for this specific Child_PID
    SELECT NVL(MAX(c.Batch_Number), 0) INTO v_max_existing_batch_lot
    FROM commodity c JOIN productInstance pi ON c.Instance_ID = pi.Instance_ID
    WHERE pi.Product_ID = 601.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next batch

    v_expiration_date := TIMESTAMP '2025-02-13 01:28:53' + INTERVAL '574' DAY;
    v_quantity_to_create := ROUND(1.6, 1);

    INSERT INTO commodity (Instance_ID, Batch_Number, Expiration_Date, Quantity)
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Packaged' THEN
    -- Find max existing Lot_Number for this specific Child_PID
    SELECT NVL(MAX(p.Lot_Number), 0) INTO v_max_existing_batch_lot
    FROM packaged p JOIN productInstance pi ON p.Instance_ID = pi.Instance_ID -- Assuming 'packaged' table name
    WHERE pi.Product_ID = 601.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next lot

    v_expiration_date := TIMESTAMP '2025-02-13 01:28:53' + INTERVAL '419' DAY;
    v_quantity_to_create := ROUND(1.6, 1);

    INSERT INTO packaged (Instance_ID, Lot_Number, Expiration_Date, Quantity) -- Assuming 'packaged' table name
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Serialized' THEN
    -- Assign a unique serial number
    -- Using Instance ID guarantees uniqueness within this context
    v_serial_number := 'SN-' || TO_CHAR(601.0) || '-' || TO_CHAR(v_new_child_instance_id) || '-' || SUBSTR(SYS_GUID(),1,8);
    -- Assign a batch number - use Product_ID of the *parent* instance as the batch for simplicity? Or a sequence?
    -- Let's use the Parent_IID itself as a simple batch identifier for this run.
    v_batch_number := 542.0; -- All children created FOR this parent get same batch number

    INSERT INTO serialized (Instance_ID, Serial_Number, Batch_Number)
    VALUES (v_new_child_instance_id, v_serial_number, v_batch_number);

    -- Quantity for usesComponent link for serialized is typically 1
    v_quantity_to_create := 1;

  END IF;

  -- Step 3: Create the usesComponent link
  -- Quantity_Used is the Quantity_Needed from needsComponent (which matches child quantity for non-serialized)
  IF v_child_category IN ('Commodity', 'Packaged', 'Serialized') THEN -- Only insert if subtype was handled
      INSERT INTO usesComponent (Parent_IID, Child_IID, Quantity_Used)
      VALUES (542.0, v_new_child_instance_id, ROUND(1.6, 1)); -- Use rounded quantity needed
  END IF;

EXCEPTION
  WHEN OTHERS THEN
    DBMS_OUTPUT.PUT_LINE('Error processing Parent_IID=' || 542.0 || ', Child_PID=' || 601.0 || ': ' || SQLERRM);
    -- Decide if you want to rollback just this block or let the main exception handler catch it
END;
/
DECLARE
  v_new_child_instance_id productInstance.Instance_ID%TYPE;
  v_child_category        product.Category%TYPE := 'Commodity'; -- Pass category
  v_max_existing_batch_lot NUMBER;
  v_next_batch_lot_num   NUMBER;
  v_serial_number        serialized.Serial_Number%TYPE;
  v_batch_number         serialized.Batch_Number%TYPE; -- Shared batch for serialized children of *this* parent
  v_expiration_date      commodity.Expiration_Date%TYPE;
  v_quantity_to_create   commodity.Quantity%TYPE; -- Quantity for the new child instance

BEGIN
  -- Step 1: Create the new child productInstance
  INSERT INTO productInstance (Product_ID, Date_Manufactured, Is_Recalled)
  VALUES (226.0, TIMESTAMP '2024-11-14 18:26:00', 0)
  RETURNING Instance_ID INTO v_new_child_instance_id;

  -- Step 2: Create the corresponding subtype record
  IF v_child_category = 'Commodity' THEN
    -- Find max existing Batch_Number for this specific Child_PID
    SELECT NVL(MAX(c.Batch_Number), 0) INTO v_max_existing_batch_lot
    FROM commodity c JOIN productInstance pi ON c.Instance_ID = pi.Instance_ID
    WHERE pi.Product_ID = 226.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next batch

    v_expiration_date := TIMESTAMP '2024-11-14 18:26:00' + INTERVAL '528' DAY;
    v_quantity_to_create := ROUND(0.3, 1);

    INSERT INTO commodity (Instance_ID, Batch_Number, Expiration_Date, Quantity)
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Packaged' THEN
    -- Find max existing Lot_Number for this specific Child_PID
    SELECT NVL(MAX(p.Lot_Number), 0) INTO v_max_existing_batch_lot
    FROM packaged p JOIN productInstance pi ON p.Instance_ID = pi.Instance_ID -- Assuming 'packaged' table name
    WHERE pi.Product_ID = 226.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next lot

    v_expiration_date := TIMESTAMP '2024-11-14 18:26:00' + INTERVAL '108' DAY;
    v_quantity_to_create := ROUND(0.3, 1);

    INSERT INTO packaged (Instance_ID, Lot_Number, Expiration_Date, Quantity) -- Assuming 'packaged' table name
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Serialized' THEN
    -- Assign a unique serial number
    -- Using Instance ID guarantees uniqueness within this context
    v_serial_number := 'SN-' || TO_CHAR(226.0) || '-' || TO_CHAR(v_new_child_instance_id) || '-' || SUBSTR(SYS_GUID(),1,8);
    -- Assign a batch number - use Product_ID of the *parent* instance as the batch for simplicity? Or a sequence?
    -- Let's use the Parent_IID itself as a simple batch identifier for this run.
    v_batch_number := 545.0; -- All children created FOR this parent get same batch number

    INSERT INTO serialized (Instance_ID, Serial_Number, Batch_Number)
    VALUES (v_new_child_instance_id, v_serial_number, v_batch_number);

    -- Quantity for usesComponent link for serialized is typically 1
    v_quantity_to_create := 1;

  END IF;

  -- Step 3: Create the usesComponent link
  -- Quantity_Used is the Quantity_Needed from needsComponent (which matches child quantity for non-serialized)
  IF v_child_category IN ('Commodity', 'Packaged', 'Serialized') THEN -- Only insert if subtype was handled
      INSERT INTO usesComponent (Parent_IID, Child_IID, Quantity_Used)
      VALUES (545.0, v_new_child_instance_id, ROUND(0.3, 1)); -- Use rounded quantity needed
  END IF;

EXCEPTION
  WHEN OTHERS THEN
    DBMS_OUTPUT.PUT_LINE('Error processing Parent_IID=' || 545.0 || ', Child_PID=' || 226.0 || ': ' || SQLERRM);
    -- Decide if you want to rollback just this block or let the main exception handler catch it
END;
/
DECLARE
  v_new_child_instance_id productInstance.Instance_ID%TYPE;
  v_child_category        product.Category%TYPE := 'Commodity'; -- Pass category
  v_max_existing_batch_lot NUMBER;
  v_next_batch_lot_num   NUMBER;
  v_serial_number        serialized.Serial_Number%TYPE;
  v_batch_number         serialized.Batch_Number%TYPE; -- Shared batch for serialized children of *this* parent
  v_expiration_date      commodity.Expiration_Date%TYPE;
  v_quantity_to_create   commodity.Quantity%TYPE; -- Quantity for the new child instance

BEGIN
  -- Step 1: Create the new child productInstance
  INSERT INTO productInstance (Product_ID, Date_Manufactured, Is_Recalled)
  VALUES (107.0, TIMESTAMP '2024-10-02 20:07:09', 0)
  RETURNING Instance_ID INTO v_new_child_instance_id;

  -- Step 2: Create the corresponding subtype record
  IF v_child_category = 'Commodity' THEN
    -- Find max existing Batch_Number for this specific Child_PID
    SELECT NVL(MAX(c.Batch_Number), 0) INTO v_max_existing_batch_lot
    FROM commodity c JOIN productInstance pi ON c.Instance_ID = pi.Instance_ID
    WHERE pi.Product_ID = 107.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next batch

    v_expiration_date := TIMESTAMP '2024-10-02 20:07:09' + INTERVAL '660' DAY;
    v_quantity_to_create := ROUND(0.7, 1);

    INSERT INTO commodity (Instance_ID, Batch_Number, Expiration_Date, Quantity)
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Packaged' THEN
    -- Find max existing Lot_Number for this specific Child_PID
    SELECT NVL(MAX(p.Lot_Number), 0) INTO v_max_existing_batch_lot
    FROM packaged p JOIN productInstance pi ON p.Instance_ID = pi.Instance_ID -- Assuming 'packaged' table name
    WHERE pi.Product_ID = 107.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next lot

    v_expiration_date := TIMESTAMP '2024-10-02 20:07:09' + INTERVAL '552' DAY;
    v_quantity_to_create := ROUND(0.7, 1);

    INSERT INTO packaged (Instance_ID, Lot_Number, Expiration_Date, Quantity) -- Assuming 'packaged' table name
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Serialized' THEN
    -- Assign a unique serial number
    -- Using Instance ID guarantees uniqueness within this context
    v_serial_number := 'SN-' || TO_CHAR(107.0) || '-' || TO_CHAR(v_new_child_instance_id) || '-' || SUBSTR(SYS_GUID(),1,8);
    -- Assign a batch number - use Product_ID of the *parent* instance as the batch for simplicity? Or a sequence?
    -- Let's use the Parent_IID itself as a simple batch identifier for this run.
    v_batch_number := 545.0; -- All children created FOR this parent get same batch number

    INSERT INTO serialized (Instance_ID, Serial_Number, Batch_Number)
    VALUES (v_new_child_instance_id, v_serial_number, v_batch_number);

    -- Quantity for usesComponent link for serialized is typically 1
    v_quantity_to_create := 1;

  END IF;

  -- Step 3: Create the usesComponent link
  -- Quantity_Used is the Quantity_Needed from needsComponent (which matches child quantity for non-serialized)
  IF v_child_category IN ('Commodity', 'Packaged', 'Serialized') THEN -- Only insert if subtype was handled
      INSERT INTO usesComponent (Parent_IID, Child_IID, Quantity_Used)
      VALUES (545.0, v_new_child_instance_id, ROUND(0.7, 1)); -- Use rounded quantity needed
  END IF;

EXCEPTION
  WHEN OTHERS THEN
    DBMS_OUTPUT.PUT_LINE('Error processing Parent_IID=' || 545.0 || ', Child_PID=' || 107.0 || ': ' || SQLERRM);
    -- Decide if you want to rollback just this block or let the main exception handler catch it
END;
/
DECLARE
  v_new_child_instance_id productInstance.Instance_ID%TYPE;
  v_child_category        product.Category%TYPE := 'Commodity'; -- Pass category
  v_max_existing_batch_lot NUMBER;
  v_next_batch_lot_num   NUMBER;
  v_serial_number        serialized.Serial_Number%TYPE;
  v_batch_number         serialized.Batch_Number%TYPE; -- Shared batch for serialized children of *this* parent
  v_expiration_date      commodity.Expiration_Date%TYPE;
  v_quantity_to_create   commodity.Quantity%TYPE; -- Quantity for the new child instance

BEGIN
  -- Step 1: Create the new child productInstance
  INSERT INTO productInstance (Product_ID, Date_Manufactured, Is_Recalled)
  VALUES (174.0, TIMESTAMP '2025-03-04 06:22:48', 0)
  RETURNING Instance_ID INTO v_new_child_instance_id;

  -- Step 2: Create the corresponding subtype record
  IF v_child_category = 'Commodity' THEN
    -- Find max existing Batch_Number for this specific Child_PID
    SELECT NVL(MAX(c.Batch_Number), 0) INTO v_max_existing_batch_lot
    FROM commodity c JOIN productInstance pi ON c.Instance_ID = pi.Instance_ID
    WHERE pi.Product_ID = 174.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next batch

    v_expiration_date := TIMESTAMP '2025-03-04 06:22:48' + INTERVAL '622' DAY;
    v_quantity_to_create := ROUND(1.5, 1);

    INSERT INTO commodity (Instance_ID, Batch_Number, Expiration_Date, Quantity)
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Packaged' THEN
    -- Find max existing Lot_Number for this specific Child_PID
    SELECT NVL(MAX(p.Lot_Number), 0) INTO v_max_existing_batch_lot
    FROM packaged p JOIN productInstance pi ON p.Instance_ID = pi.Instance_ID -- Assuming 'packaged' table name
    WHERE pi.Product_ID = 174.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next lot

    v_expiration_date := TIMESTAMP '2025-03-04 06:22:48' + INTERVAL '628' DAY;
    v_quantity_to_create := ROUND(1.5, 1);

    INSERT INTO packaged (Instance_ID, Lot_Number, Expiration_Date, Quantity) -- Assuming 'packaged' table name
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Serialized' THEN
    -- Assign a unique serial number
    -- Using Instance ID guarantees uniqueness within this context
    v_serial_number := 'SN-' || TO_CHAR(174.0) || '-' || TO_CHAR(v_new_child_instance_id) || '-' || SUBSTR(SYS_GUID(),1,8);
    -- Assign a batch number - use Product_ID of the *parent* instance as the batch for simplicity? Or a sequence?
    -- Let's use the Parent_IID itself as a simple batch identifier for this run.
    v_batch_number := 545.0; -- All children created FOR this parent get same batch number

    INSERT INTO serialized (Instance_ID, Serial_Number, Batch_Number)
    VALUES (v_new_child_instance_id, v_serial_number, v_batch_number);

    -- Quantity for usesComponent link for serialized is typically 1
    v_quantity_to_create := 1;

  END IF;

  -- Step 3: Create the usesComponent link
  -- Quantity_Used is the Quantity_Needed from needsComponent (which matches child quantity for non-serialized)
  IF v_child_category IN ('Commodity', 'Packaged', 'Serialized') THEN -- Only insert if subtype was handled
      INSERT INTO usesComponent (Parent_IID, Child_IID, Quantity_Used)
      VALUES (545.0, v_new_child_instance_id, ROUND(1.5, 1)); -- Use rounded quantity needed
  END IF;

EXCEPTION
  WHEN OTHERS THEN
    DBMS_OUTPUT.PUT_LINE('Error processing Parent_IID=' || 545.0 || ', Child_PID=' || 174.0 || ': ' || SQLERRM);
    -- Decide if you want to rollback just this block or let the main exception handler catch it
END;
/
DECLARE
  v_new_child_instance_id productInstance.Instance_ID%TYPE;
  v_child_category        product.Category%TYPE := 'Commodity'; -- Pass category
  v_max_existing_batch_lot NUMBER;
  v_next_batch_lot_num   NUMBER;
  v_serial_number        serialized.Serial_Number%TYPE;
  v_batch_number         serialized.Batch_Number%TYPE; -- Shared batch for serialized children of *this* parent
  v_expiration_date      commodity.Expiration_Date%TYPE;
  v_quantity_to_create   commodity.Quantity%TYPE; -- Quantity for the new child instance

BEGIN
  -- Step 1: Create the new child productInstance
  INSERT INTO productInstance (Product_ID, Date_Manufactured, Is_Recalled)
  VALUES (226.0, TIMESTAMP '2024-10-11 07:48:49', 0)
  RETURNING Instance_ID INTO v_new_child_instance_id;

  -- Step 2: Create the corresponding subtype record
  IF v_child_category = 'Commodity' THEN
    -- Find max existing Batch_Number for this specific Child_PID
    SELECT NVL(MAX(c.Batch_Number), 0) INTO v_max_existing_batch_lot
    FROM commodity c JOIN productInstance pi ON c.Instance_ID = pi.Instance_ID
    WHERE pi.Product_ID = 226.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next batch

    v_expiration_date := TIMESTAMP '2024-10-11 07:48:49' + INTERVAL '71' DAY;
    v_quantity_to_create := ROUND(0.3, 1);

    INSERT INTO commodity (Instance_ID, Batch_Number, Expiration_Date, Quantity)
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Packaged' THEN
    -- Find max existing Lot_Number for this specific Child_PID
    SELECT NVL(MAX(p.Lot_Number), 0) INTO v_max_existing_batch_lot
    FROM packaged p JOIN productInstance pi ON p.Instance_ID = pi.Instance_ID -- Assuming 'packaged' table name
    WHERE pi.Product_ID = 226.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next lot

    v_expiration_date := TIMESTAMP '2024-10-11 07:48:49' + INTERVAL '390' DAY;
    v_quantity_to_create := ROUND(0.3, 1);

    INSERT INTO packaged (Instance_ID, Lot_Number, Expiration_Date, Quantity) -- Assuming 'packaged' table name
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Serialized' THEN
    -- Assign a unique serial number
    -- Using Instance ID guarantees uniqueness within this context
    v_serial_number := 'SN-' || TO_CHAR(226.0) || '-' || TO_CHAR(v_new_child_instance_id) || '-' || SUBSTR(SYS_GUID(),1,8);
    -- Assign a batch number - use Product_ID of the *parent* instance as the batch for simplicity? Or a sequence?
    -- Let's use the Parent_IID itself as a simple batch identifier for this run.
    v_batch_number := 546.0; -- All children created FOR this parent get same batch number

    INSERT INTO serialized (Instance_ID, Serial_Number, Batch_Number)
    VALUES (v_new_child_instance_id, v_serial_number, v_batch_number);

    -- Quantity for usesComponent link for serialized is typically 1
    v_quantity_to_create := 1;

  END IF;

  -- Step 3: Create the usesComponent link
  -- Quantity_Used is the Quantity_Needed from needsComponent (which matches child quantity for non-serialized)
  IF v_child_category IN ('Commodity', 'Packaged', 'Serialized') THEN -- Only insert if subtype was handled
      INSERT INTO usesComponent (Parent_IID, Child_IID, Quantity_Used)
      VALUES (546.0, v_new_child_instance_id, ROUND(0.3, 1)); -- Use rounded quantity needed
  END IF;

EXCEPTION
  WHEN OTHERS THEN
    DBMS_OUTPUT.PUT_LINE('Error processing Parent_IID=' || 546.0 || ', Child_PID=' || 226.0 || ': ' || SQLERRM);
    -- Decide if you want to rollback just this block or let the main exception handler catch it
END;
/
DECLARE
  v_new_child_instance_id productInstance.Instance_ID%TYPE;
  v_child_category        product.Category%TYPE := 'Commodity'; -- Pass category
  v_max_existing_batch_lot NUMBER;
  v_next_batch_lot_num   NUMBER;
  v_serial_number        serialized.Serial_Number%TYPE;
  v_batch_number         serialized.Batch_Number%TYPE; -- Shared batch for serialized children of *this* parent
  v_expiration_date      commodity.Expiration_Date%TYPE;
  v_quantity_to_create   commodity.Quantity%TYPE; -- Quantity for the new child instance

BEGIN
  -- Step 1: Create the new child productInstance
  INSERT INTO productInstance (Product_ID, Date_Manufactured, Is_Recalled)
  VALUES (107.0, TIMESTAMP '2025-03-25 14:10:32', 0)
  RETURNING Instance_ID INTO v_new_child_instance_id;

  -- Step 2: Create the corresponding subtype record
  IF v_child_category = 'Commodity' THEN
    -- Find max existing Batch_Number for this specific Child_PID
    SELECT NVL(MAX(c.Batch_Number), 0) INTO v_max_existing_batch_lot
    FROM commodity c JOIN productInstance pi ON c.Instance_ID = pi.Instance_ID
    WHERE pi.Product_ID = 107.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next batch

    v_expiration_date := TIMESTAMP '2025-03-25 14:10:32' + INTERVAL '499' DAY;
    v_quantity_to_create := ROUND(0.7, 1);

    INSERT INTO commodity (Instance_ID, Batch_Number, Expiration_Date, Quantity)
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Packaged' THEN
    -- Find max existing Lot_Number for this specific Child_PID
    SELECT NVL(MAX(p.Lot_Number), 0) INTO v_max_existing_batch_lot
    FROM packaged p JOIN productInstance pi ON p.Instance_ID = pi.Instance_ID -- Assuming 'packaged' table name
    WHERE pi.Product_ID = 107.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next lot

    v_expiration_date := TIMESTAMP '2025-03-25 14:10:32' + INTERVAL '36' DAY;
    v_quantity_to_create := ROUND(0.7, 1);

    INSERT INTO packaged (Instance_ID, Lot_Number, Expiration_Date, Quantity) -- Assuming 'packaged' table name
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Serialized' THEN
    -- Assign a unique serial number
    -- Using Instance ID guarantees uniqueness within this context
    v_serial_number := 'SN-' || TO_CHAR(107.0) || '-' || TO_CHAR(v_new_child_instance_id) || '-' || SUBSTR(SYS_GUID(),1,8);
    -- Assign a batch number - use Product_ID of the *parent* instance as the batch for simplicity? Or a sequence?
    -- Let's use the Parent_IID itself as a simple batch identifier for this run.
    v_batch_number := 546.0; -- All children created FOR this parent get same batch number

    INSERT INTO serialized (Instance_ID, Serial_Number, Batch_Number)
    VALUES (v_new_child_instance_id, v_serial_number, v_batch_number);

    -- Quantity for usesComponent link for serialized is typically 1
    v_quantity_to_create := 1;

  END IF;

  -- Step 3: Create the usesComponent link
  -- Quantity_Used is the Quantity_Needed from needsComponent (which matches child quantity for non-serialized)
  IF v_child_category IN ('Commodity', 'Packaged', 'Serialized') THEN -- Only insert if subtype was handled
      INSERT INTO usesComponent (Parent_IID, Child_IID, Quantity_Used)
      VALUES (546.0, v_new_child_instance_id, ROUND(0.7, 1)); -- Use rounded quantity needed
  END IF;

EXCEPTION
  WHEN OTHERS THEN
    DBMS_OUTPUT.PUT_LINE('Error processing Parent_IID=' || 546.0 || ', Child_PID=' || 107.0 || ': ' || SQLERRM);
    -- Decide if you want to rollback just this block or let the main exception handler catch it
END;
/
DECLARE
  v_new_child_instance_id productInstance.Instance_ID%TYPE;
  v_child_category        product.Category%TYPE := 'Commodity'; -- Pass category
  v_max_existing_batch_lot NUMBER;
  v_next_batch_lot_num   NUMBER;
  v_serial_number        serialized.Serial_Number%TYPE;
  v_batch_number         serialized.Batch_Number%TYPE; -- Shared batch for serialized children of *this* parent
  v_expiration_date      commodity.Expiration_Date%TYPE;
  v_quantity_to_create   commodity.Quantity%TYPE; -- Quantity for the new child instance

BEGIN
  -- Step 1: Create the new child productInstance
  INSERT INTO productInstance (Product_ID, Date_Manufactured, Is_Recalled)
  VALUES (174.0, TIMESTAMP '2024-07-11 17:39:26', 0)
  RETURNING Instance_ID INTO v_new_child_instance_id;

  -- Step 2: Create the corresponding subtype record
  IF v_child_category = 'Commodity' THEN
    -- Find max existing Batch_Number for this specific Child_PID
    SELECT NVL(MAX(c.Batch_Number), 0) INTO v_max_existing_batch_lot
    FROM commodity c JOIN productInstance pi ON c.Instance_ID = pi.Instance_ID
    WHERE pi.Product_ID = 174.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next batch

    v_expiration_date := TIMESTAMP '2024-07-11 17:39:26' + INTERVAL '336' DAY;
    v_quantity_to_create := ROUND(1.5, 1);

    INSERT INTO commodity (Instance_ID, Batch_Number, Expiration_Date, Quantity)
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Packaged' THEN
    -- Find max existing Lot_Number for this specific Child_PID
    SELECT NVL(MAX(p.Lot_Number), 0) INTO v_max_existing_batch_lot
    FROM packaged p JOIN productInstance pi ON p.Instance_ID = pi.Instance_ID -- Assuming 'packaged' table name
    WHERE pi.Product_ID = 174.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next lot

    v_expiration_date := TIMESTAMP '2024-07-11 17:39:26' + INTERVAL '687' DAY;
    v_quantity_to_create := ROUND(1.5, 1);

    INSERT INTO packaged (Instance_ID, Lot_Number, Expiration_Date, Quantity) -- Assuming 'packaged' table name
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Serialized' THEN
    -- Assign a unique serial number
    -- Using Instance ID guarantees uniqueness within this context
    v_serial_number := 'SN-' || TO_CHAR(174.0) || '-' || TO_CHAR(v_new_child_instance_id) || '-' || SUBSTR(SYS_GUID(),1,8);
    -- Assign a batch number - use Product_ID of the *parent* instance as the batch for simplicity? Or a sequence?
    -- Let's use the Parent_IID itself as a simple batch identifier for this run.
    v_batch_number := 546.0; -- All children created FOR this parent get same batch number

    INSERT INTO serialized (Instance_ID, Serial_Number, Batch_Number)
    VALUES (v_new_child_instance_id, v_serial_number, v_batch_number);

    -- Quantity for usesComponent link for serialized is typically 1
    v_quantity_to_create := 1;

  END IF;

  -- Step 3: Create the usesComponent link
  -- Quantity_Used is the Quantity_Needed from needsComponent (which matches child quantity for non-serialized)
  IF v_child_category IN ('Commodity', 'Packaged', 'Serialized') THEN -- Only insert if subtype was handled
      INSERT INTO usesComponent (Parent_IID, Child_IID, Quantity_Used)
      VALUES (546.0, v_new_child_instance_id, ROUND(1.5, 1)); -- Use rounded quantity needed
  END IF;

EXCEPTION
  WHEN OTHERS THEN
    DBMS_OUTPUT.PUT_LINE('Error processing Parent_IID=' || 546.0 || ', Child_PID=' || 174.0 || ': ' || SQLERRM);
    -- Decide if you want to rollback just this block or let the main exception handler catch it
END;
/
DECLARE
  v_new_child_instance_id productInstance.Instance_ID%TYPE;
  v_child_category        product.Category%TYPE := 'Commodity'; -- Pass category
  v_max_existing_batch_lot NUMBER;
  v_next_batch_lot_num   NUMBER;
  v_serial_number        serialized.Serial_Number%TYPE;
  v_batch_number         serialized.Batch_Number%TYPE; -- Shared batch for serialized children of *this* parent
  v_expiration_date      commodity.Expiration_Date%TYPE;
  v_quantity_to_create   commodity.Quantity%TYPE; -- Quantity for the new child instance

BEGIN
  -- Step 1: Create the new child productInstance
  INSERT INTO productInstance (Product_ID, Date_Manufactured, Is_Recalled)
  VALUES (226.0, TIMESTAMP '2024-05-01 04:17:26', 0)
  RETURNING Instance_ID INTO v_new_child_instance_id;

  -- Step 2: Create the corresponding subtype record
  IF v_child_category = 'Commodity' THEN
    -- Find max existing Batch_Number for this specific Child_PID
    SELECT NVL(MAX(c.Batch_Number), 0) INTO v_max_existing_batch_lot
    FROM commodity c JOIN productInstance pi ON c.Instance_ID = pi.Instance_ID
    WHERE pi.Product_ID = 226.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next batch

    v_expiration_date := TIMESTAMP '2024-05-01 04:17:26' + INTERVAL '583' DAY;
    v_quantity_to_create := ROUND(0.3, 1);

    INSERT INTO commodity (Instance_ID, Batch_Number, Expiration_Date, Quantity)
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Packaged' THEN
    -- Find max existing Lot_Number for this specific Child_PID
    SELECT NVL(MAX(p.Lot_Number), 0) INTO v_max_existing_batch_lot
    FROM packaged p JOIN productInstance pi ON p.Instance_ID = pi.Instance_ID -- Assuming 'packaged' table name
    WHERE pi.Product_ID = 226.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next lot

    v_expiration_date := TIMESTAMP '2024-05-01 04:17:26' + INTERVAL '152' DAY;
    v_quantity_to_create := ROUND(0.3, 1);

    INSERT INTO packaged (Instance_ID, Lot_Number, Expiration_Date, Quantity) -- Assuming 'packaged' table name
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Serialized' THEN
    -- Assign a unique serial number
    -- Using Instance ID guarantees uniqueness within this context
    v_serial_number := 'SN-' || TO_CHAR(226.0) || '-' || TO_CHAR(v_new_child_instance_id) || '-' || SUBSTR(SYS_GUID(),1,8);
    -- Assign a batch number - use Product_ID of the *parent* instance as the batch for simplicity? Or a sequence?
    -- Let's use the Parent_IID itself as a simple batch identifier for this run.
    v_batch_number := 547.0; -- All children created FOR this parent get same batch number

    INSERT INTO serialized (Instance_ID, Serial_Number, Batch_Number)
    VALUES (v_new_child_instance_id, v_serial_number, v_batch_number);

    -- Quantity for usesComponent link for serialized is typically 1
    v_quantity_to_create := 1;

  END IF;

  -- Step 3: Create the usesComponent link
  -- Quantity_Used is the Quantity_Needed from needsComponent (which matches child quantity for non-serialized)
  IF v_child_category IN ('Commodity', 'Packaged', 'Serialized') THEN -- Only insert if subtype was handled
      INSERT INTO usesComponent (Parent_IID, Child_IID, Quantity_Used)
      VALUES (547.0, v_new_child_instance_id, ROUND(0.3, 1)); -- Use rounded quantity needed
  END IF;

EXCEPTION
  WHEN OTHERS THEN
    DBMS_OUTPUT.PUT_LINE('Error processing Parent_IID=' || 547.0 || ', Child_PID=' || 226.0 || ': ' || SQLERRM);
    -- Decide if you want to rollback just this block or let the main exception handler catch it
END;
/
DECLARE
  v_new_child_instance_id productInstance.Instance_ID%TYPE;
  v_child_category        product.Category%TYPE := 'Commodity'; -- Pass category
  v_max_existing_batch_lot NUMBER;
  v_next_batch_lot_num   NUMBER;
  v_serial_number        serialized.Serial_Number%TYPE;
  v_batch_number         serialized.Batch_Number%TYPE; -- Shared batch for serialized children of *this* parent
  v_expiration_date      commodity.Expiration_Date%TYPE;
  v_quantity_to_create   commodity.Quantity%TYPE; -- Quantity for the new child instance

BEGIN
  -- Step 1: Create the new child productInstance
  INSERT INTO productInstance (Product_ID, Date_Manufactured, Is_Recalled)
  VALUES (107.0, TIMESTAMP '2025-03-14 05:17:49', 0)
  RETURNING Instance_ID INTO v_new_child_instance_id;

  -- Step 2: Create the corresponding subtype record
  IF v_child_category = 'Commodity' THEN
    -- Find max existing Batch_Number for this specific Child_PID
    SELECT NVL(MAX(c.Batch_Number), 0) INTO v_max_existing_batch_lot
    FROM commodity c JOIN productInstance pi ON c.Instance_ID = pi.Instance_ID
    WHERE pi.Product_ID = 107.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next batch

    v_expiration_date := TIMESTAMP '2025-03-14 05:17:49' + INTERVAL '339' DAY;
    v_quantity_to_create := ROUND(0.7, 1);

    INSERT INTO commodity (Instance_ID, Batch_Number, Expiration_Date, Quantity)
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Packaged' THEN
    -- Find max existing Lot_Number for this specific Child_PID
    SELECT NVL(MAX(p.Lot_Number), 0) INTO v_max_existing_batch_lot
    FROM packaged p JOIN productInstance pi ON p.Instance_ID = pi.Instance_ID -- Assuming 'packaged' table name
    WHERE pi.Product_ID = 107.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next lot

    v_expiration_date := TIMESTAMP '2025-03-14 05:17:49' + INTERVAL '554' DAY;
    v_quantity_to_create := ROUND(0.7, 1);

    INSERT INTO packaged (Instance_ID, Lot_Number, Expiration_Date, Quantity) -- Assuming 'packaged' table name
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Serialized' THEN
    -- Assign a unique serial number
    -- Using Instance ID guarantees uniqueness within this context
    v_serial_number := 'SN-' || TO_CHAR(107.0) || '-' || TO_CHAR(v_new_child_instance_id) || '-' || SUBSTR(SYS_GUID(),1,8);
    -- Assign a batch number - use Product_ID of the *parent* instance as the batch for simplicity? Or a sequence?
    -- Let's use the Parent_IID itself as a simple batch identifier for this run.
    v_batch_number := 547.0; -- All children created FOR this parent get same batch number

    INSERT INTO serialized (Instance_ID, Serial_Number, Batch_Number)
    VALUES (v_new_child_instance_id, v_serial_number, v_batch_number);

    -- Quantity for usesComponent link for serialized is typically 1
    v_quantity_to_create := 1;

  END IF;

  -- Step 3: Create the usesComponent link
  -- Quantity_Used is the Quantity_Needed from needsComponent (which matches child quantity for non-serialized)
  IF v_child_category IN ('Commodity', 'Packaged', 'Serialized') THEN -- Only insert if subtype was handled
      INSERT INTO usesComponent (Parent_IID, Child_IID, Quantity_Used)
      VALUES (547.0, v_new_child_instance_id, ROUND(0.7, 1)); -- Use rounded quantity needed
  END IF;

EXCEPTION
  WHEN OTHERS THEN
    DBMS_OUTPUT.PUT_LINE('Error processing Parent_IID=' || 547.0 || ', Child_PID=' || 107.0 || ': ' || SQLERRM);
    -- Decide if you want to rollback just this block or let the main exception handler catch it
END;
/
DECLARE
  v_new_child_instance_id productInstance.Instance_ID%TYPE;
  v_child_category        product.Category%TYPE := 'Commodity'; -- Pass category
  v_max_existing_batch_lot NUMBER;
  v_next_batch_lot_num   NUMBER;
  v_serial_number        serialized.Serial_Number%TYPE;
  v_batch_number         serialized.Batch_Number%TYPE; -- Shared batch for serialized children of *this* parent
  v_expiration_date      commodity.Expiration_Date%TYPE;
  v_quantity_to_create   commodity.Quantity%TYPE; -- Quantity for the new child instance

BEGIN
  -- Step 1: Create the new child productInstance
  INSERT INTO productInstance (Product_ID, Date_Manufactured, Is_Recalled)
  VALUES (174.0, TIMESTAMP '2025-04-08 14:11:01', 0)
  RETURNING Instance_ID INTO v_new_child_instance_id;

  -- Step 2: Create the corresponding subtype record
  IF v_child_category = 'Commodity' THEN
    -- Find max existing Batch_Number for this specific Child_PID
    SELECT NVL(MAX(c.Batch_Number), 0) INTO v_max_existing_batch_lot
    FROM commodity c JOIN productInstance pi ON c.Instance_ID = pi.Instance_ID
    WHERE pi.Product_ID = 174.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next batch

    v_expiration_date := TIMESTAMP '2025-04-08 14:11:01' + INTERVAL '353' DAY;
    v_quantity_to_create := ROUND(1.5, 1);

    INSERT INTO commodity (Instance_ID, Batch_Number, Expiration_Date, Quantity)
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Packaged' THEN
    -- Find max existing Lot_Number for this specific Child_PID
    SELECT NVL(MAX(p.Lot_Number), 0) INTO v_max_existing_batch_lot
    FROM packaged p JOIN productInstance pi ON p.Instance_ID = pi.Instance_ID -- Assuming 'packaged' table name
    WHERE pi.Product_ID = 174.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next lot

    v_expiration_date := TIMESTAMP '2025-04-08 14:11:01' + INTERVAL '586' DAY;
    v_quantity_to_create := ROUND(1.5, 1);

    INSERT INTO packaged (Instance_ID, Lot_Number, Expiration_Date, Quantity) -- Assuming 'packaged' table name
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Serialized' THEN
    -- Assign a unique serial number
    -- Using Instance ID guarantees uniqueness within this context
    v_serial_number := 'SN-' || TO_CHAR(174.0) || '-' || TO_CHAR(v_new_child_instance_id) || '-' || SUBSTR(SYS_GUID(),1,8);
    -- Assign a batch number - use Product_ID of the *parent* instance as the batch for simplicity? Or a sequence?
    -- Let's use the Parent_IID itself as a simple batch identifier for this run.
    v_batch_number := 547.0; -- All children created FOR this parent get same batch number

    INSERT INTO serialized (Instance_ID, Serial_Number, Batch_Number)
    VALUES (v_new_child_instance_id, v_serial_number, v_batch_number);

    -- Quantity for usesComponent link for serialized is typically 1
    v_quantity_to_create := 1;

  END IF;

  -- Step 3: Create the usesComponent link
  -- Quantity_Used is the Quantity_Needed from needsComponent (which matches child quantity for non-serialized)
  IF v_child_category IN ('Commodity', 'Packaged', 'Serialized') THEN -- Only insert if subtype was handled
      INSERT INTO usesComponent (Parent_IID, Child_IID, Quantity_Used)
      VALUES (547.0, v_new_child_instance_id, ROUND(1.5, 1)); -- Use rounded quantity needed
  END IF;

EXCEPTION
  WHEN OTHERS THEN
    DBMS_OUTPUT.PUT_LINE('Error processing Parent_IID=' || 547.0 || ', Child_PID=' || 174.0 || ': ' || SQLERRM);
    -- Decide if you want to rollback just this block or let the main exception handler catch it
END;
/
DECLARE
  v_new_child_instance_id productInstance.Instance_ID%TYPE;
  v_child_category        product.Category%TYPE := 'Commodity'; -- Pass category
  v_max_existing_batch_lot NUMBER;
  v_next_batch_lot_num   NUMBER;
  v_serial_number        serialized.Serial_Number%TYPE;
  v_batch_number         serialized.Batch_Number%TYPE; -- Shared batch for serialized children of *this* parent
  v_expiration_date      commodity.Expiration_Date%TYPE;
  v_quantity_to_create   commodity.Quantity%TYPE; -- Quantity for the new child instance

BEGIN
  -- Step 1: Create the new child productInstance
  INSERT INTO productInstance (Product_ID, Date_Manufactured, Is_Recalled)
  VALUES (226.0, TIMESTAMP '2025-01-04 13:14:33', 0)
  RETURNING Instance_ID INTO v_new_child_instance_id;

  -- Step 2: Create the corresponding subtype record
  IF v_child_category = 'Commodity' THEN
    -- Find max existing Batch_Number for this specific Child_PID
    SELECT NVL(MAX(c.Batch_Number), 0) INTO v_max_existing_batch_lot
    FROM commodity c JOIN productInstance pi ON c.Instance_ID = pi.Instance_ID
    WHERE pi.Product_ID = 226.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next batch

    v_expiration_date := TIMESTAMP '2025-01-04 13:14:33' + INTERVAL '615' DAY;
    v_quantity_to_create := ROUND(0.3, 1);

    INSERT INTO commodity (Instance_ID, Batch_Number, Expiration_Date, Quantity)
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Packaged' THEN
    -- Find max existing Lot_Number for this specific Child_PID
    SELECT NVL(MAX(p.Lot_Number), 0) INTO v_max_existing_batch_lot
    FROM packaged p JOIN productInstance pi ON p.Instance_ID = pi.Instance_ID -- Assuming 'packaged' table name
    WHERE pi.Product_ID = 226.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next lot

    v_expiration_date := TIMESTAMP '2025-01-04 13:14:33' + INTERVAL '594' DAY;
    v_quantity_to_create := ROUND(0.3, 1);

    INSERT INTO packaged (Instance_ID, Lot_Number, Expiration_Date, Quantity) -- Assuming 'packaged' table name
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Serialized' THEN
    -- Assign a unique serial number
    -- Using Instance ID guarantees uniqueness within this context
    v_serial_number := 'SN-' || TO_CHAR(226.0) || '-' || TO_CHAR(v_new_child_instance_id) || '-' || SUBSTR(SYS_GUID(),1,8);
    -- Assign a batch number - use Product_ID of the *parent* instance as the batch for simplicity? Or a sequence?
    -- Let's use the Parent_IID itself as a simple batch identifier for this run.
    v_batch_number := 548.0; -- All children created FOR this parent get same batch number

    INSERT INTO serialized (Instance_ID, Serial_Number, Batch_Number)
    VALUES (v_new_child_instance_id, v_serial_number, v_batch_number);

    -- Quantity for usesComponent link for serialized is typically 1
    v_quantity_to_create := 1;

  END IF;

  -- Step 3: Create the usesComponent link
  -- Quantity_Used is the Quantity_Needed from needsComponent (which matches child quantity for non-serialized)
  IF v_child_category IN ('Commodity', 'Packaged', 'Serialized') THEN -- Only insert if subtype was handled
      INSERT INTO usesComponent (Parent_IID, Child_IID, Quantity_Used)
      VALUES (548.0, v_new_child_instance_id, ROUND(0.3, 1)); -- Use rounded quantity needed
  END IF;

EXCEPTION
  WHEN OTHERS THEN
    DBMS_OUTPUT.PUT_LINE('Error processing Parent_IID=' || 548.0 || ', Child_PID=' || 226.0 || ': ' || SQLERRM);
    -- Decide if you want to rollback just this block or let the main exception handler catch it
END;
/
DECLARE
  v_new_child_instance_id productInstance.Instance_ID%TYPE;
  v_child_category        product.Category%TYPE := 'Commodity'; -- Pass category
  v_max_existing_batch_lot NUMBER;
  v_next_batch_lot_num   NUMBER;
  v_serial_number        serialized.Serial_Number%TYPE;
  v_batch_number         serialized.Batch_Number%TYPE; -- Shared batch for serialized children of *this* parent
  v_expiration_date      commodity.Expiration_Date%TYPE;
  v_quantity_to_create   commodity.Quantity%TYPE; -- Quantity for the new child instance

BEGIN
  -- Step 1: Create the new child productInstance
  INSERT INTO productInstance (Product_ID, Date_Manufactured, Is_Recalled)
  VALUES (107.0, TIMESTAMP '2024-08-16 18:06:57', 0)
  RETURNING Instance_ID INTO v_new_child_instance_id;

  -- Step 2: Create the corresponding subtype record
  IF v_child_category = 'Commodity' THEN
    -- Find max existing Batch_Number for this specific Child_PID
    SELECT NVL(MAX(c.Batch_Number), 0) INTO v_max_existing_batch_lot
    FROM commodity c JOIN productInstance pi ON c.Instance_ID = pi.Instance_ID
    WHERE pi.Product_ID = 107.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next batch

    v_expiration_date := TIMESTAMP '2024-08-16 18:06:57' + INTERVAL '568' DAY;
    v_quantity_to_create := ROUND(0.7, 1);

    INSERT INTO commodity (Instance_ID, Batch_Number, Expiration_Date, Quantity)
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Packaged' THEN
    -- Find max existing Lot_Number for this specific Child_PID
    SELECT NVL(MAX(p.Lot_Number), 0) INTO v_max_existing_batch_lot
    FROM packaged p JOIN productInstance pi ON p.Instance_ID = pi.Instance_ID -- Assuming 'packaged' table name
    WHERE pi.Product_ID = 107.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next lot

    v_expiration_date := TIMESTAMP '2024-08-16 18:06:57' + INTERVAL '451' DAY;
    v_quantity_to_create := ROUND(0.7, 1);

    INSERT INTO packaged (Instance_ID, Lot_Number, Expiration_Date, Quantity) -- Assuming 'packaged' table name
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Serialized' THEN
    -- Assign a unique serial number
    -- Using Instance ID guarantees uniqueness within this context
    v_serial_number := 'SN-' || TO_CHAR(107.0) || '-' || TO_CHAR(v_new_child_instance_id) || '-' || SUBSTR(SYS_GUID(),1,8);
    -- Assign a batch number - use Product_ID of the *parent* instance as the batch for simplicity? Or a sequence?
    -- Let's use the Parent_IID itself as a simple batch identifier for this run.
    v_batch_number := 548.0; -- All children created FOR this parent get same batch number

    INSERT INTO serialized (Instance_ID, Serial_Number, Batch_Number)
    VALUES (v_new_child_instance_id, v_serial_number, v_batch_number);

    -- Quantity for usesComponent link for serialized is typically 1
    v_quantity_to_create := 1;

  END IF;

  -- Step 3: Create the usesComponent link
  -- Quantity_Used is the Quantity_Needed from needsComponent (which matches child quantity for non-serialized)
  IF v_child_category IN ('Commodity', 'Packaged', 'Serialized') THEN -- Only insert if subtype was handled
      INSERT INTO usesComponent (Parent_IID, Child_IID, Quantity_Used)
      VALUES (548.0, v_new_child_instance_id, ROUND(0.7, 1)); -- Use rounded quantity needed
  END IF;

EXCEPTION
  WHEN OTHERS THEN
    DBMS_OUTPUT.PUT_LINE('Error processing Parent_IID=' || 548.0 || ', Child_PID=' || 107.0 || ': ' || SQLERRM);
    -- Decide if you want to rollback just this block or let the main exception handler catch it
END;
/
DECLARE
  v_new_child_instance_id productInstance.Instance_ID%TYPE;
  v_child_category        product.Category%TYPE := 'Commodity'; -- Pass category
  v_max_existing_batch_lot NUMBER;
  v_next_batch_lot_num   NUMBER;
  v_serial_number        serialized.Serial_Number%TYPE;
  v_batch_number         serialized.Batch_Number%TYPE; -- Shared batch for serialized children of *this* parent
  v_expiration_date      commodity.Expiration_Date%TYPE;
  v_quantity_to_create   commodity.Quantity%TYPE; -- Quantity for the new child instance

BEGIN
  -- Step 1: Create the new child productInstance
  INSERT INTO productInstance (Product_ID, Date_Manufactured, Is_Recalled)
  VALUES (174.0, TIMESTAMP '2024-11-25 13:08:43', 0)
  RETURNING Instance_ID INTO v_new_child_instance_id;

  -- Step 2: Create the corresponding subtype record
  IF v_child_category = 'Commodity' THEN
    -- Find max existing Batch_Number for this specific Child_PID
    SELECT NVL(MAX(c.Batch_Number), 0) INTO v_max_existing_batch_lot
    FROM commodity c JOIN productInstance pi ON c.Instance_ID = pi.Instance_ID
    WHERE pi.Product_ID = 174.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next batch

    v_expiration_date := TIMESTAMP '2024-11-25 13:08:43' + INTERVAL '560' DAY;
    v_quantity_to_create := ROUND(1.5, 1);

    INSERT INTO commodity (Instance_ID, Batch_Number, Expiration_Date, Quantity)
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Packaged' THEN
    -- Find max existing Lot_Number for this specific Child_PID
    SELECT NVL(MAX(p.Lot_Number), 0) INTO v_max_existing_batch_lot
    FROM packaged p JOIN productInstance pi ON p.Instance_ID = pi.Instance_ID -- Assuming 'packaged' table name
    WHERE pi.Product_ID = 174.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next lot

    v_expiration_date := TIMESTAMP '2024-11-25 13:08:43' + INTERVAL '448' DAY;
    v_quantity_to_create := ROUND(1.5, 1);

    INSERT INTO packaged (Instance_ID, Lot_Number, Expiration_Date, Quantity) -- Assuming 'packaged' table name
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Serialized' THEN
    -- Assign a unique serial number
    -- Using Instance ID guarantees uniqueness within this context
    v_serial_number := 'SN-' || TO_CHAR(174.0) || '-' || TO_CHAR(v_new_child_instance_id) || '-' || SUBSTR(SYS_GUID(),1,8);
    -- Assign a batch number - use Product_ID of the *parent* instance as the batch for simplicity? Or a sequence?
    -- Let's use the Parent_IID itself as a simple batch identifier for this run.
    v_batch_number := 548.0; -- All children created FOR this parent get same batch number

    INSERT INTO serialized (Instance_ID, Serial_Number, Batch_Number)
    VALUES (v_new_child_instance_id, v_serial_number, v_batch_number);

    -- Quantity for usesComponent link for serialized is typically 1
    v_quantity_to_create := 1;

  END IF;

  -- Step 3: Create the usesComponent link
  -- Quantity_Used is the Quantity_Needed from needsComponent (which matches child quantity for non-serialized)
  IF v_child_category IN ('Commodity', 'Packaged', 'Serialized') THEN -- Only insert if subtype was handled
      INSERT INTO usesComponent (Parent_IID, Child_IID, Quantity_Used)
      VALUES (548.0, v_new_child_instance_id, ROUND(1.5, 1)); -- Use rounded quantity needed
  END IF;

EXCEPTION
  WHEN OTHERS THEN
    DBMS_OUTPUT.PUT_LINE('Error processing Parent_IID=' || 548.0 || ', Child_PID=' || 174.0 || ': ' || SQLERRM);
    -- Decide if you want to rollback just this block or let the main exception handler catch it
END;
/
DECLARE
  v_new_child_instance_id productInstance.Instance_ID%TYPE;
  v_child_category        product.Category%TYPE := 'Commodity'; -- Pass category
  v_max_existing_batch_lot NUMBER;
  v_next_batch_lot_num   NUMBER;
  v_serial_number        serialized.Serial_Number%TYPE;
  v_batch_number         serialized.Batch_Number%TYPE; -- Shared batch for serialized children of *this* parent
  v_expiration_date      commodity.Expiration_Date%TYPE;
  v_quantity_to_create   commodity.Quantity%TYPE; -- Quantity for the new child instance

BEGIN
  -- Step 1: Create the new child productInstance
  INSERT INTO productInstance (Product_ID, Date_Manufactured, Is_Recalled)
  VALUES (230.0, TIMESTAMP '2024-12-19 03:10:43', 0)
  RETURNING Instance_ID INTO v_new_child_instance_id;

  -- Step 2: Create the corresponding subtype record
  IF v_child_category = 'Commodity' THEN
    -- Find max existing Batch_Number for this specific Child_PID
    SELECT NVL(MAX(c.Batch_Number), 0) INTO v_max_existing_batch_lot
    FROM commodity c JOIN productInstance pi ON c.Instance_ID = pi.Instance_ID
    WHERE pi.Product_ID = 230.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next batch

    v_expiration_date := TIMESTAMP '2024-12-19 03:10:43' + INTERVAL '675' DAY;
    v_quantity_to_create := ROUND(1.5, 1);

    INSERT INTO commodity (Instance_ID, Batch_Number, Expiration_Date, Quantity)
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Packaged' THEN
    -- Find max existing Lot_Number for this specific Child_PID
    SELECT NVL(MAX(p.Lot_Number), 0) INTO v_max_existing_batch_lot
    FROM packaged p JOIN productInstance pi ON p.Instance_ID = pi.Instance_ID -- Assuming 'packaged' table name
    WHERE pi.Product_ID = 230.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next lot

    v_expiration_date := TIMESTAMP '2024-12-19 03:10:43' + INTERVAL '625' DAY;
    v_quantity_to_create := ROUND(1.5, 1);

    INSERT INTO packaged (Instance_ID, Lot_Number, Expiration_Date, Quantity) -- Assuming 'packaged' table name
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Serialized' THEN
    -- Assign a unique serial number
    -- Using Instance ID guarantees uniqueness within this context
    v_serial_number := 'SN-' || TO_CHAR(230.0) || '-' || TO_CHAR(v_new_child_instance_id) || '-' || SUBSTR(SYS_GUID(),1,8);
    -- Assign a batch number - use Product_ID of the *parent* instance as the batch for simplicity? Or a sequence?
    -- Let's use the Parent_IID itself as a simple batch identifier for this run.
    v_batch_number := 556.0; -- All children created FOR this parent get same batch number

    INSERT INTO serialized (Instance_ID, Serial_Number, Batch_Number)
    VALUES (v_new_child_instance_id, v_serial_number, v_batch_number);

    -- Quantity for usesComponent link for serialized is typically 1
    v_quantity_to_create := 1;

  END IF;

  -- Step 3: Create the usesComponent link
  -- Quantity_Used is the Quantity_Needed from needsComponent (which matches child quantity for non-serialized)
  IF v_child_category IN ('Commodity', 'Packaged', 'Serialized') THEN -- Only insert if subtype was handled
      INSERT INTO usesComponent (Parent_IID, Child_IID, Quantity_Used)
      VALUES (556.0, v_new_child_instance_id, ROUND(1.5, 1)); -- Use rounded quantity needed
  END IF;

EXCEPTION
  WHEN OTHERS THEN
    DBMS_OUTPUT.PUT_LINE('Error processing Parent_IID=' || 556.0 || ', Child_PID=' || 230.0 || ': ' || SQLERRM);
    -- Decide if you want to rollback just this block or let the main exception handler catch it
END;
/
DECLARE
  v_new_child_instance_id productInstance.Instance_ID%TYPE;
  v_child_category        product.Category%TYPE := 'Commodity'; -- Pass category
  v_max_existing_batch_lot NUMBER;
  v_next_batch_lot_num   NUMBER;
  v_serial_number        serialized.Serial_Number%TYPE;
  v_batch_number         serialized.Batch_Number%TYPE; -- Shared batch for serialized children of *this* parent
  v_expiration_date      commodity.Expiration_Date%TYPE;
  v_quantity_to_create   commodity.Quantity%TYPE; -- Quantity for the new child instance

BEGIN
  -- Step 1: Create the new child productInstance
  INSERT INTO productInstance (Product_ID, Date_Manufactured, Is_Recalled)
  VALUES (242.0, TIMESTAMP '2024-08-26 13:29:12', 0)
  RETURNING Instance_ID INTO v_new_child_instance_id;

  -- Step 2: Create the corresponding subtype record
  IF v_child_category = 'Commodity' THEN
    -- Find max existing Batch_Number for this specific Child_PID
    SELECT NVL(MAX(c.Batch_Number), 0) INTO v_max_existing_batch_lot
    FROM commodity c JOIN productInstance pi ON c.Instance_ID = pi.Instance_ID
    WHERE pi.Product_ID = 242.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next batch

    v_expiration_date := TIMESTAMP '2024-08-26 13:29:12' + INTERVAL '493' DAY;
    v_quantity_to_create := ROUND(1.0, 1);

    INSERT INTO commodity (Instance_ID, Batch_Number, Expiration_Date, Quantity)
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Packaged' THEN
    -- Find max existing Lot_Number for this specific Child_PID
    SELECT NVL(MAX(p.Lot_Number), 0) INTO v_max_existing_batch_lot
    FROM packaged p JOIN productInstance pi ON p.Instance_ID = pi.Instance_ID -- Assuming 'packaged' table name
    WHERE pi.Product_ID = 242.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next lot

    v_expiration_date := TIMESTAMP '2024-08-26 13:29:12' + INTERVAL '339' DAY;
    v_quantity_to_create := ROUND(1.0, 1);

    INSERT INTO packaged (Instance_ID, Lot_Number, Expiration_Date, Quantity) -- Assuming 'packaged' table name
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Serialized' THEN
    -- Assign a unique serial number
    -- Using Instance ID guarantees uniqueness within this context
    v_serial_number := 'SN-' || TO_CHAR(242.0) || '-' || TO_CHAR(v_new_child_instance_id) || '-' || SUBSTR(SYS_GUID(),1,8);
    -- Assign a batch number - use Product_ID of the *parent* instance as the batch for simplicity? Or a sequence?
    -- Let's use the Parent_IID itself as a simple batch identifier for this run.
    v_batch_number := 556.0; -- All children created FOR this parent get same batch number

    INSERT INTO serialized (Instance_ID, Serial_Number, Batch_Number)
    VALUES (v_new_child_instance_id, v_serial_number, v_batch_number);

    -- Quantity for usesComponent link for serialized is typically 1
    v_quantity_to_create := 1;

  END IF;

  -- Step 3: Create the usesComponent link
  -- Quantity_Used is the Quantity_Needed from needsComponent (which matches child quantity for non-serialized)
  IF v_child_category IN ('Commodity', 'Packaged', 'Serialized') THEN -- Only insert if subtype was handled
      INSERT INTO usesComponent (Parent_IID, Child_IID, Quantity_Used)
      VALUES (556.0, v_new_child_instance_id, ROUND(1.0, 1)); -- Use rounded quantity needed
  END IF;

EXCEPTION
  WHEN OTHERS THEN
    DBMS_OUTPUT.PUT_LINE('Error processing Parent_IID=' || 556.0 || ', Child_PID=' || 242.0 || ': ' || SQLERRM);
    -- Decide if you want to rollback just this block or let the main exception handler catch it
END;
/
DECLARE
  v_new_child_instance_id productInstance.Instance_ID%TYPE;
  v_child_category        product.Category%TYPE := 'Commodity'; -- Pass category
  v_max_existing_batch_lot NUMBER;
  v_next_batch_lot_num   NUMBER;
  v_serial_number        serialized.Serial_Number%TYPE;
  v_batch_number         serialized.Batch_Number%TYPE; -- Shared batch for serialized children of *this* parent
  v_expiration_date      commodity.Expiration_Date%TYPE;
  v_quantity_to_create   commodity.Quantity%TYPE; -- Quantity for the new child instance

BEGIN
  -- Step 1: Create the new child productInstance
  INSERT INTO productInstance (Product_ID, Date_Manufactured, Is_Recalled)
  VALUES (117.0, TIMESTAMP '2024-06-18 21:26:40', 0)
  RETURNING Instance_ID INTO v_new_child_instance_id;

  -- Step 2: Create the corresponding subtype record
  IF v_child_category = 'Commodity' THEN
    -- Find max existing Batch_Number for this specific Child_PID
    SELECT NVL(MAX(c.Batch_Number), 0) INTO v_max_existing_batch_lot
    FROM commodity c JOIN productInstance pi ON c.Instance_ID = pi.Instance_ID
    WHERE pi.Product_ID = 117.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next batch

    v_expiration_date := TIMESTAMP '2024-06-18 21:26:40' + INTERVAL '548' DAY;
    v_quantity_to_create := ROUND(0.7, 1);

    INSERT INTO commodity (Instance_ID, Batch_Number, Expiration_Date, Quantity)
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Packaged' THEN
    -- Find max existing Lot_Number for this specific Child_PID
    SELECT NVL(MAX(p.Lot_Number), 0) INTO v_max_existing_batch_lot
    FROM packaged p JOIN productInstance pi ON p.Instance_ID = pi.Instance_ID -- Assuming 'packaged' table name
    WHERE pi.Product_ID = 117.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next lot

    v_expiration_date := TIMESTAMP '2024-06-18 21:26:40' + INTERVAL '484' DAY;
    v_quantity_to_create := ROUND(0.7, 1);

    INSERT INTO packaged (Instance_ID, Lot_Number, Expiration_Date, Quantity) -- Assuming 'packaged' table name
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Serialized' THEN
    -- Assign a unique serial number
    -- Using Instance ID guarantees uniqueness within this context
    v_serial_number := 'SN-' || TO_CHAR(117.0) || '-' || TO_CHAR(v_new_child_instance_id) || '-' || SUBSTR(SYS_GUID(),1,8);
    -- Assign a batch number - use Product_ID of the *parent* instance as the batch for simplicity? Or a sequence?
    -- Let's use the Parent_IID itself as a simple batch identifier for this run.
    v_batch_number := 556.0; -- All children created FOR this parent get same batch number

    INSERT INTO serialized (Instance_ID, Serial_Number, Batch_Number)
    VALUES (v_new_child_instance_id, v_serial_number, v_batch_number);

    -- Quantity for usesComponent link for serialized is typically 1
    v_quantity_to_create := 1;

  END IF;

  -- Step 3: Create the usesComponent link
  -- Quantity_Used is the Quantity_Needed from needsComponent (which matches child quantity for non-serialized)
  IF v_child_category IN ('Commodity', 'Packaged', 'Serialized') THEN -- Only insert if subtype was handled
      INSERT INTO usesComponent (Parent_IID, Child_IID, Quantity_Used)
      VALUES (556.0, v_new_child_instance_id, ROUND(0.7, 1)); -- Use rounded quantity needed
  END IF;

EXCEPTION
  WHEN OTHERS THEN
    DBMS_OUTPUT.PUT_LINE('Error processing Parent_IID=' || 556.0 || ', Child_PID=' || 117.0 || ': ' || SQLERRM);
    -- Decide if you want to rollback just this block or let the main exception handler catch it
END;
/
DECLARE
  v_new_child_instance_id productInstance.Instance_ID%TYPE;
  v_child_category        product.Category%TYPE := 'Commodity'; -- Pass category
  v_max_existing_batch_lot NUMBER;
  v_next_batch_lot_num   NUMBER;
  v_serial_number        serialized.Serial_Number%TYPE;
  v_batch_number         serialized.Batch_Number%TYPE; -- Shared batch for serialized children of *this* parent
  v_expiration_date      commodity.Expiration_Date%TYPE;
  v_quantity_to_create   commodity.Quantity%TYPE; -- Quantity for the new child instance

BEGIN
  -- Step 1: Create the new child productInstance
  INSERT INTO productInstance (Product_ID, Date_Manufactured, Is_Recalled)
  VALUES (168.0, TIMESTAMP '2024-12-12 17:22:18', 0)
  RETURNING Instance_ID INTO v_new_child_instance_id;

  -- Step 2: Create the corresponding subtype record
  IF v_child_category = 'Commodity' THEN
    -- Find max existing Batch_Number for this specific Child_PID
    SELECT NVL(MAX(c.Batch_Number), 0) INTO v_max_existing_batch_lot
    FROM commodity c JOIN productInstance pi ON c.Instance_ID = pi.Instance_ID
    WHERE pi.Product_ID = 168.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next batch

    v_expiration_date := TIMESTAMP '2024-12-12 17:22:18' + INTERVAL '173' DAY;
    v_quantity_to_create := ROUND(1.7, 1);

    INSERT INTO commodity (Instance_ID, Batch_Number, Expiration_Date, Quantity)
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Packaged' THEN
    -- Find max existing Lot_Number for this specific Child_PID
    SELECT NVL(MAX(p.Lot_Number), 0) INTO v_max_existing_batch_lot
    FROM packaged p JOIN productInstance pi ON p.Instance_ID = pi.Instance_ID -- Assuming 'packaged' table name
    WHERE pi.Product_ID = 168.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next lot

    v_expiration_date := TIMESTAMP '2024-12-12 17:22:18' + INTERVAL '593' DAY;
    v_quantity_to_create := ROUND(1.7, 1);

    INSERT INTO packaged (Instance_ID, Lot_Number, Expiration_Date, Quantity) -- Assuming 'packaged' table name
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Serialized' THEN
    -- Assign a unique serial number
    -- Using Instance ID guarantees uniqueness within this context
    v_serial_number := 'SN-' || TO_CHAR(168.0) || '-' || TO_CHAR(v_new_child_instance_id) || '-' || SUBSTR(SYS_GUID(),1,8);
    -- Assign a batch number - use Product_ID of the *parent* instance as the batch for simplicity? Or a sequence?
    -- Let's use the Parent_IID itself as a simple batch identifier for this run.
    v_batch_number := 556.0; -- All children created FOR this parent get same batch number

    INSERT INTO serialized (Instance_ID, Serial_Number, Batch_Number)
    VALUES (v_new_child_instance_id, v_serial_number, v_batch_number);

    -- Quantity for usesComponent link for serialized is typically 1
    v_quantity_to_create := 1;

  END IF;

  -- Step 3: Create the usesComponent link
  -- Quantity_Used is the Quantity_Needed from needsComponent (which matches child quantity for non-serialized)
  IF v_child_category IN ('Commodity', 'Packaged', 'Serialized') THEN -- Only insert if subtype was handled
      INSERT INTO usesComponent (Parent_IID, Child_IID, Quantity_Used)
      VALUES (556.0, v_new_child_instance_id, ROUND(1.7, 1)); -- Use rounded quantity needed
  END IF;

EXCEPTION
  WHEN OTHERS THEN
    DBMS_OUTPUT.PUT_LINE('Error processing Parent_IID=' || 556.0 || ', Child_PID=' || 168.0 || ': ' || SQLERRM);
    -- Decide if you want to rollback just this block or let the main exception handler catch it
END;
/
DECLARE
  v_new_child_instance_id productInstance.Instance_ID%TYPE;
  v_child_category        product.Category%TYPE := 'Commodity'; -- Pass category
  v_max_existing_batch_lot NUMBER;
  v_next_batch_lot_num   NUMBER;
  v_serial_number        serialized.Serial_Number%TYPE;
  v_batch_number         serialized.Batch_Number%TYPE; -- Shared batch for serialized children of *this* parent
  v_expiration_date      commodity.Expiration_Date%TYPE;
  v_quantity_to_create   commodity.Quantity%TYPE; -- Quantity for the new child instance

BEGIN
  -- Step 1: Create the new child productInstance
  INSERT INTO productInstance (Product_ID, Date_Manufactured, Is_Recalled)
  VALUES (230.0, TIMESTAMP '2025-02-23 01:16:05', 0)
  RETURNING Instance_ID INTO v_new_child_instance_id;

  -- Step 2: Create the corresponding subtype record
  IF v_child_category = 'Commodity' THEN
    -- Find max existing Batch_Number for this specific Child_PID
    SELECT NVL(MAX(c.Batch_Number), 0) INTO v_max_existing_batch_lot
    FROM commodity c JOIN productInstance pi ON c.Instance_ID = pi.Instance_ID
    WHERE pi.Product_ID = 230.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next batch

    v_expiration_date := TIMESTAMP '2025-02-23 01:16:05' + INTERVAL '196' DAY;
    v_quantity_to_create := ROUND(1.5, 1);

    INSERT INTO commodity (Instance_ID, Batch_Number, Expiration_Date, Quantity)
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Packaged' THEN
    -- Find max existing Lot_Number for this specific Child_PID
    SELECT NVL(MAX(p.Lot_Number), 0) INTO v_max_existing_batch_lot
    FROM packaged p JOIN productInstance pi ON p.Instance_ID = pi.Instance_ID -- Assuming 'packaged' table name
    WHERE pi.Product_ID = 230.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next lot

    v_expiration_date := TIMESTAMP '2025-02-23 01:16:05' + INTERVAL '288' DAY;
    v_quantity_to_create := ROUND(1.5, 1);

    INSERT INTO packaged (Instance_ID, Lot_Number, Expiration_Date, Quantity) -- Assuming 'packaged' table name
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Serialized' THEN
    -- Assign a unique serial number
    -- Using Instance ID guarantees uniqueness within this context
    v_serial_number := 'SN-' || TO_CHAR(230.0) || '-' || TO_CHAR(v_new_child_instance_id) || '-' || SUBSTR(SYS_GUID(),1,8);
    -- Assign a batch number - use Product_ID of the *parent* instance as the batch for simplicity? Or a sequence?
    -- Let's use the Parent_IID itself as a simple batch identifier for this run.
    v_batch_number := 557.0; -- All children created FOR this parent get same batch number

    INSERT INTO serialized (Instance_ID, Serial_Number, Batch_Number)
    VALUES (v_new_child_instance_id, v_serial_number, v_batch_number);

    -- Quantity for usesComponent link for serialized is typically 1
    v_quantity_to_create := 1;

  END IF;

  -- Step 3: Create the usesComponent link
  -- Quantity_Used is the Quantity_Needed from needsComponent (which matches child quantity for non-serialized)
  IF v_child_category IN ('Commodity', 'Packaged', 'Serialized') THEN -- Only insert if subtype was handled
      INSERT INTO usesComponent (Parent_IID, Child_IID, Quantity_Used)
      VALUES (557.0, v_new_child_instance_id, ROUND(1.5, 1)); -- Use rounded quantity needed
  END IF;

EXCEPTION
  WHEN OTHERS THEN
    DBMS_OUTPUT.PUT_LINE('Error processing Parent_IID=' || 557.0 || ', Child_PID=' || 230.0 || ': ' || SQLERRM);
    -- Decide if you want to rollback just this block or let the main exception handler catch it
END;
/
DECLARE
  v_new_child_instance_id productInstance.Instance_ID%TYPE;
  v_child_category        product.Category%TYPE := 'Commodity'; -- Pass category
  v_max_existing_batch_lot NUMBER;
  v_next_batch_lot_num   NUMBER;
  v_serial_number        serialized.Serial_Number%TYPE;
  v_batch_number         serialized.Batch_Number%TYPE; -- Shared batch for serialized children of *this* parent
  v_expiration_date      commodity.Expiration_Date%TYPE;
  v_quantity_to_create   commodity.Quantity%TYPE; -- Quantity for the new child instance

BEGIN
  -- Step 1: Create the new child productInstance
  INSERT INTO productInstance (Product_ID, Date_Manufactured, Is_Recalled)
  VALUES (242.0, TIMESTAMP '2025-01-01 07:06:12', 0)
  RETURNING Instance_ID INTO v_new_child_instance_id;

  -- Step 2: Create the corresponding subtype record
  IF v_child_category = 'Commodity' THEN
    -- Find max existing Batch_Number for this specific Child_PID
    SELECT NVL(MAX(c.Batch_Number), 0) INTO v_max_existing_batch_lot
    FROM commodity c JOIN productInstance pi ON c.Instance_ID = pi.Instance_ID
    WHERE pi.Product_ID = 242.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next batch

    v_expiration_date := TIMESTAMP '2025-01-01 07:06:12' + INTERVAL '39' DAY;
    v_quantity_to_create := ROUND(1.0, 1);

    INSERT INTO commodity (Instance_ID, Batch_Number, Expiration_Date, Quantity)
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Packaged' THEN
    -- Find max existing Lot_Number for this specific Child_PID
    SELECT NVL(MAX(p.Lot_Number), 0) INTO v_max_existing_batch_lot
    FROM packaged p JOIN productInstance pi ON p.Instance_ID = pi.Instance_ID -- Assuming 'packaged' table name
    WHERE pi.Product_ID = 242.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next lot

    v_expiration_date := TIMESTAMP '2025-01-01 07:06:12' + INTERVAL '464' DAY;
    v_quantity_to_create := ROUND(1.0, 1);

    INSERT INTO packaged (Instance_ID, Lot_Number, Expiration_Date, Quantity) -- Assuming 'packaged' table name
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Serialized' THEN
    -- Assign a unique serial number
    -- Using Instance ID guarantees uniqueness within this context
    v_serial_number := 'SN-' || TO_CHAR(242.0) || '-' || TO_CHAR(v_new_child_instance_id) || '-' || SUBSTR(SYS_GUID(),1,8);
    -- Assign a batch number - use Product_ID of the *parent* instance as the batch for simplicity? Or a sequence?
    -- Let's use the Parent_IID itself as a simple batch identifier for this run.
    v_batch_number := 557.0; -- All children created FOR this parent get same batch number

    INSERT INTO serialized (Instance_ID, Serial_Number, Batch_Number)
    VALUES (v_new_child_instance_id, v_serial_number, v_batch_number);

    -- Quantity for usesComponent link for serialized is typically 1
    v_quantity_to_create := 1;

  END IF;

  -- Step 3: Create the usesComponent link
  -- Quantity_Used is the Quantity_Needed from needsComponent (which matches child quantity for non-serialized)
  IF v_child_category IN ('Commodity', 'Packaged', 'Serialized') THEN -- Only insert if subtype was handled
      INSERT INTO usesComponent (Parent_IID, Child_IID, Quantity_Used)
      VALUES (557.0, v_new_child_instance_id, ROUND(1.0, 1)); -- Use rounded quantity needed
  END IF;

EXCEPTION
  WHEN OTHERS THEN
    DBMS_OUTPUT.PUT_LINE('Error processing Parent_IID=' || 557.0 || ', Child_PID=' || 242.0 || ': ' || SQLERRM);
    -- Decide if you want to rollback just this block or let the main exception handler catch it
END;
/
DECLARE
  v_new_child_instance_id productInstance.Instance_ID%TYPE;
  v_child_category        product.Category%TYPE := 'Commodity'; -- Pass category
  v_max_existing_batch_lot NUMBER;
  v_next_batch_lot_num   NUMBER;
  v_serial_number        serialized.Serial_Number%TYPE;
  v_batch_number         serialized.Batch_Number%TYPE; -- Shared batch for serialized children of *this* parent
  v_expiration_date      commodity.Expiration_Date%TYPE;
  v_quantity_to_create   commodity.Quantity%TYPE; -- Quantity for the new child instance

BEGIN
  -- Step 1: Create the new child productInstance
  INSERT INTO productInstance (Product_ID, Date_Manufactured, Is_Recalled)
  VALUES (117.0, TIMESTAMP '2025-02-08 22:14:21', 0)
  RETURNING Instance_ID INTO v_new_child_instance_id;

  -- Step 2: Create the corresponding subtype record
  IF v_child_category = 'Commodity' THEN
    -- Find max existing Batch_Number for this specific Child_PID
    SELECT NVL(MAX(c.Batch_Number), 0) INTO v_max_existing_batch_lot
    FROM commodity c JOIN productInstance pi ON c.Instance_ID = pi.Instance_ID
    WHERE pi.Product_ID = 117.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next batch

    v_expiration_date := TIMESTAMP '2025-02-08 22:14:21' + INTERVAL '707' DAY;
    v_quantity_to_create := ROUND(0.7, 1);

    INSERT INTO commodity (Instance_ID, Batch_Number, Expiration_Date, Quantity)
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Packaged' THEN
    -- Find max existing Lot_Number for this specific Child_PID
    SELECT NVL(MAX(p.Lot_Number), 0) INTO v_max_existing_batch_lot
    FROM packaged p JOIN productInstance pi ON p.Instance_ID = pi.Instance_ID -- Assuming 'packaged' table name
    WHERE pi.Product_ID = 117.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next lot

    v_expiration_date := TIMESTAMP '2025-02-08 22:14:21' + INTERVAL '609' DAY;
    v_quantity_to_create := ROUND(0.7, 1);

    INSERT INTO packaged (Instance_ID, Lot_Number, Expiration_Date, Quantity) -- Assuming 'packaged' table name
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Serialized' THEN
    -- Assign a unique serial number
    -- Using Instance ID guarantees uniqueness within this context
    v_serial_number := 'SN-' || TO_CHAR(117.0) || '-' || TO_CHAR(v_new_child_instance_id) || '-' || SUBSTR(SYS_GUID(),1,8);
    -- Assign a batch number - use Product_ID of the *parent* instance as the batch for simplicity? Or a sequence?
    -- Let's use the Parent_IID itself as a simple batch identifier for this run.
    v_batch_number := 557.0; -- All children created FOR this parent get same batch number

    INSERT INTO serialized (Instance_ID, Serial_Number, Batch_Number)
    VALUES (v_new_child_instance_id, v_serial_number, v_batch_number);

    -- Quantity for usesComponent link for serialized is typically 1
    v_quantity_to_create := 1;

  END IF;

  -- Step 3: Create the usesComponent link
  -- Quantity_Used is the Quantity_Needed from needsComponent (which matches child quantity for non-serialized)
  IF v_child_category IN ('Commodity', 'Packaged', 'Serialized') THEN -- Only insert if subtype was handled
      INSERT INTO usesComponent (Parent_IID, Child_IID, Quantity_Used)
      VALUES (557.0, v_new_child_instance_id, ROUND(0.7, 1)); -- Use rounded quantity needed
  END IF;

EXCEPTION
  WHEN OTHERS THEN
    DBMS_OUTPUT.PUT_LINE('Error processing Parent_IID=' || 557.0 || ', Child_PID=' || 117.0 || ': ' || SQLERRM);
    -- Decide if you want to rollback just this block or let the main exception handler catch it
END;
/
DECLARE
  v_new_child_instance_id productInstance.Instance_ID%TYPE;
  v_child_category        product.Category%TYPE := 'Commodity'; -- Pass category
  v_max_existing_batch_lot NUMBER;
  v_next_batch_lot_num   NUMBER;
  v_serial_number        serialized.Serial_Number%TYPE;
  v_batch_number         serialized.Batch_Number%TYPE; -- Shared batch for serialized children of *this* parent
  v_expiration_date      commodity.Expiration_Date%TYPE;
  v_quantity_to_create   commodity.Quantity%TYPE; -- Quantity for the new child instance

BEGIN
  -- Step 1: Create the new child productInstance
  INSERT INTO productInstance (Product_ID, Date_Manufactured, Is_Recalled)
  VALUES (168.0, TIMESTAMP '2024-05-13 02:50:01', 0)
  RETURNING Instance_ID INTO v_new_child_instance_id;

  -- Step 2: Create the corresponding subtype record
  IF v_child_category = 'Commodity' THEN
    -- Find max existing Batch_Number for this specific Child_PID
    SELECT NVL(MAX(c.Batch_Number), 0) INTO v_max_existing_batch_lot
    FROM commodity c JOIN productInstance pi ON c.Instance_ID = pi.Instance_ID
    WHERE pi.Product_ID = 168.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next batch

    v_expiration_date := TIMESTAMP '2024-05-13 02:50:01' + INTERVAL '407' DAY;
    v_quantity_to_create := ROUND(1.7, 1);

    INSERT INTO commodity (Instance_ID, Batch_Number, Expiration_Date, Quantity)
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Packaged' THEN
    -- Find max existing Lot_Number for this specific Child_PID
    SELECT NVL(MAX(p.Lot_Number), 0) INTO v_max_existing_batch_lot
    FROM packaged p JOIN productInstance pi ON p.Instance_ID = pi.Instance_ID -- Assuming 'packaged' table name
    WHERE pi.Product_ID = 168.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next lot

    v_expiration_date := TIMESTAMP '2024-05-13 02:50:01' + INTERVAL '460' DAY;
    v_quantity_to_create := ROUND(1.7, 1);

    INSERT INTO packaged (Instance_ID, Lot_Number, Expiration_Date, Quantity) -- Assuming 'packaged' table name
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Serialized' THEN
    -- Assign a unique serial number
    -- Using Instance ID guarantees uniqueness within this context
    v_serial_number := 'SN-' || TO_CHAR(168.0) || '-' || TO_CHAR(v_new_child_instance_id) || '-' || SUBSTR(SYS_GUID(),1,8);
    -- Assign a batch number - use Product_ID of the *parent* instance as the batch for simplicity? Or a sequence?
    -- Let's use the Parent_IID itself as a simple batch identifier for this run.
    v_batch_number := 557.0; -- All children created FOR this parent get same batch number

    INSERT INTO serialized (Instance_ID, Serial_Number, Batch_Number)
    VALUES (v_new_child_instance_id, v_serial_number, v_batch_number);

    -- Quantity for usesComponent link for serialized is typically 1
    v_quantity_to_create := 1;

  END IF;

  -- Step 3: Create the usesComponent link
  -- Quantity_Used is the Quantity_Needed from needsComponent (which matches child quantity for non-serialized)
  IF v_child_category IN ('Commodity', 'Packaged', 'Serialized') THEN -- Only insert if subtype was handled
      INSERT INTO usesComponent (Parent_IID, Child_IID, Quantity_Used)
      VALUES (557.0, v_new_child_instance_id, ROUND(1.7, 1)); -- Use rounded quantity needed
  END IF;

EXCEPTION
  WHEN OTHERS THEN
    DBMS_OUTPUT.PUT_LINE('Error processing Parent_IID=' || 557.0 || ', Child_PID=' || 168.0 || ': ' || SQLERRM);
    -- Decide if you want to rollback just this block or let the main exception handler catch it
END;
/
DECLARE
  v_new_child_instance_id productInstance.Instance_ID%TYPE;
  v_child_category        product.Category%TYPE := 'Commodity'; -- Pass category
  v_max_existing_batch_lot NUMBER;
  v_next_batch_lot_num   NUMBER;
  v_serial_number        serialized.Serial_Number%TYPE;
  v_batch_number         serialized.Batch_Number%TYPE; -- Shared batch for serialized children of *this* parent
  v_expiration_date      commodity.Expiration_Date%TYPE;
  v_quantity_to_create   commodity.Quantity%TYPE; -- Quantity for the new child instance

BEGIN
  -- Step 1: Create the new child productInstance
  INSERT INTO productInstance (Product_ID, Date_Manufactured, Is_Recalled)
  VALUES (230.0, TIMESTAMP '2024-10-02 05:10:01', 0)
  RETURNING Instance_ID INTO v_new_child_instance_id;

  -- Step 2: Create the corresponding subtype record
  IF v_child_category = 'Commodity' THEN
    -- Find max existing Batch_Number for this specific Child_PID
    SELECT NVL(MAX(c.Batch_Number), 0) INTO v_max_existing_batch_lot
    FROM commodity c JOIN productInstance pi ON c.Instance_ID = pi.Instance_ID
    WHERE pi.Product_ID = 230.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next batch

    v_expiration_date := TIMESTAMP '2024-10-02 05:10:01' + INTERVAL '318' DAY;
    v_quantity_to_create := ROUND(1.5, 1);

    INSERT INTO commodity (Instance_ID, Batch_Number, Expiration_Date, Quantity)
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Packaged' THEN
    -- Find max existing Lot_Number for this specific Child_PID
    SELECT NVL(MAX(p.Lot_Number), 0) INTO v_max_existing_batch_lot
    FROM packaged p JOIN productInstance pi ON p.Instance_ID = pi.Instance_ID -- Assuming 'packaged' table name
    WHERE pi.Product_ID = 230.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next lot

    v_expiration_date := TIMESTAMP '2024-10-02 05:10:01' + INTERVAL '704' DAY;
    v_quantity_to_create := ROUND(1.5, 1);

    INSERT INTO packaged (Instance_ID, Lot_Number, Expiration_Date, Quantity) -- Assuming 'packaged' table name
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Serialized' THEN
    -- Assign a unique serial number
    -- Using Instance ID guarantees uniqueness within this context
    v_serial_number := 'SN-' || TO_CHAR(230.0) || '-' || TO_CHAR(v_new_child_instance_id) || '-' || SUBSTR(SYS_GUID(),1,8);
    -- Assign a batch number - use Product_ID of the *parent* instance as the batch for simplicity? Or a sequence?
    -- Let's use the Parent_IID itself as a simple batch identifier for this run.
    v_batch_number := 558.0; -- All children created FOR this parent get same batch number

    INSERT INTO serialized (Instance_ID, Serial_Number, Batch_Number)
    VALUES (v_new_child_instance_id, v_serial_number, v_batch_number);

    -- Quantity for usesComponent link for serialized is typically 1
    v_quantity_to_create := 1;

  END IF;

  -- Step 3: Create the usesComponent link
  -- Quantity_Used is the Quantity_Needed from needsComponent (which matches child quantity for non-serialized)
  IF v_child_category IN ('Commodity', 'Packaged', 'Serialized') THEN -- Only insert if subtype was handled
      INSERT INTO usesComponent (Parent_IID, Child_IID, Quantity_Used)
      VALUES (558.0, v_new_child_instance_id, ROUND(1.5, 1)); -- Use rounded quantity needed
  END IF;

EXCEPTION
  WHEN OTHERS THEN
    DBMS_OUTPUT.PUT_LINE('Error processing Parent_IID=' || 558.0 || ', Child_PID=' || 230.0 || ': ' || SQLERRM);
    -- Decide if you want to rollback just this block or let the main exception handler catch it
END;
/
DECLARE
  v_new_child_instance_id productInstance.Instance_ID%TYPE;
  v_child_category        product.Category%TYPE := 'Commodity'; -- Pass category
  v_max_existing_batch_lot NUMBER;
  v_next_batch_lot_num   NUMBER;
  v_serial_number        serialized.Serial_Number%TYPE;
  v_batch_number         serialized.Batch_Number%TYPE; -- Shared batch for serialized children of *this* parent
  v_expiration_date      commodity.Expiration_Date%TYPE;
  v_quantity_to_create   commodity.Quantity%TYPE; -- Quantity for the new child instance

BEGIN
  -- Step 1: Create the new child productInstance
  INSERT INTO productInstance (Product_ID, Date_Manufactured, Is_Recalled)
  VALUES (242.0, TIMESTAMP '2025-04-11 18:02:44', 0)
  RETURNING Instance_ID INTO v_new_child_instance_id;

  -- Step 2: Create the corresponding subtype record
  IF v_child_category = 'Commodity' THEN
    -- Find max existing Batch_Number for this specific Child_PID
    SELECT NVL(MAX(c.Batch_Number), 0) INTO v_max_existing_batch_lot
    FROM commodity c JOIN productInstance pi ON c.Instance_ID = pi.Instance_ID
    WHERE pi.Product_ID = 242.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next batch

    v_expiration_date := TIMESTAMP '2025-04-11 18:02:44' + INTERVAL '715' DAY;
    v_quantity_to_create := ROUND(1.0, 1);

    INSERT INTO commodity (Instance_ID, Batch_Number, Expiration_Date, Quantity)
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Packaged' THEN
    -- Find max existing Lot_Number for this specific Child_PID
    SELECT NVL(MAX(p.Lot_Number), 0) INTO v_max_existing_batch_lot
    FROM packaged p JOIN productInstance pi ON p.Instance_ID = pi.Instance_ID -- Assuming 'packaged' table name
    WHERE pi.Product_ID = 242.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next lot

    v_expiration_date := TIMESTAMP '2025-04-11 18:02:44' + INTERVAL '48' DAY;
    v_quantity_to_create := ROUND(1.0, 1);

    INSERT INTO packaged (Instance_ID, Lot_Number, Expiration_Date, Quantity) -- Assuming 'packaged' table name
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Serialized' THEN
    -- Assign a unique serial number
    -- Using Instance ID guarantees uniqueness within this context
    v_serial_number := 'SN-' || TO_CHAR(242.0) || '-' || TO_CHAR(v_new_child_instance_id) || '-' || SUBSTR(SYS_GUID(),1,8);
    -- Assign a batch number - use Product_ID of the *parent* instance as the batch for simplicity? Or a sequence?
    -- Let's use the Parent_IID itself as a simple batch identifier for this run.
    v_batch_number := 558.0; -- All children created FOR this parent get same batch number

    INSERT INTO serialized (Instance_ID, Serial_Number, Batch_Number)
    VALUES (v_new_child_instance_id, v_serial_number, v_batch_number);

    -- Quantity for usesComponent link for serialized is typically 1
    v_quantity_to_create := 1;

  END IF;

  -- Step 3: Create the usesComponent link
  -- Quantity_Used is the Quantity_Needed from needsComponent (which matches child quantity for non-serialized)
  IF v_child_category IN ('Commodity', 'Packaged', 'Serialized') THEN -- Only insert if subtype was handled
      INSERT INTO usesComponent (Parent_IID, Child_IID, Quantity_Used)
      VALUES (558.0, v_new_child_instance_id, ROUND(1.0, 1)); -- Use rounded quantity needed
  END IF;

EXCEPTION
  WHEN OTHERS THEN
    DBMS_OUTPUT.PUT_LINE('Error processing Parent_IID=' || 558.0 || ', Child_PID=' || 242.0 || ': ' || SQLERRM);
    -- Decide if you want to rollback just this block or let the main exception handler catch it
END;
/
DECLARE
  v_new_child_instance_id productInstance.Instance_ID%TYPE;
  v_child_category        product.Category%TYPE := 'Commodity'; -- Pass category
  v_max_existing_batch_lot NUMBER;
  v_next_batch_lot_num   NUMBER;
  v_serial_number        serialized.Serial_Number%TYPE;
  v_batch_number         serialized.Batch_Number%TYPE; -- Shared batch for serialized children of *this* parent
  v_expiration_date      commodity.Expiration_Date%TYPE;
  v_quantity_to_create   commodity.Quantity%TYPE; -- Quantity for the new child instance

BEGIN
  -- Step 1: Create the new child productInstance
  INSERT INTO productInstance (Product_ID, Date_Manufactured, Is_Recalled)
  VALUES (117.0, TIMESTAMP '2025-04-13 01:53:55', 0)
  RETURNING Instance_ID INTO v_new_child_instance_id;

  -- Step 2: Create the corresponding subtype record
  IF v_child_category = 'Commodity' THEN
    -- Find max existing Batch_Number for this specific Child_PID
    SELECT NVL(MAX(c.Batch_Number), 0) INTO v_max_existing_batch_lot
    FROM commodity c JOIN productInstance pi ON c.Instance_ID = pi.Instance_ID
    WHERE pi.Product_ID = 117.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next batch

    v_expiration_date := TIMESTAMP '2025-04-13 01:53:55' + INTERVAL '122' DAY;
    v_quantity_to_create := ROUND(0.7, 1);

    INSERT INTO commodity (Instance_ID, Batch_Number, Expiration_Date, Quantity)
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Packaged' THEN
    -- Find max existing Lot_Number for this specific Child_PID
    SELECT NVL(MAX(p.Lot_Number), 0) INTO v_max_existing_batch_lot
    FROM packaged p JOIN productInstance pi ON p.Instance_ID = pi.Instance_ID -- Assuming 'packaged' table name
    WHERE pi.Product_ID = 117.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next lot

    v_expiration_date := TIMESTAMP '2025-04-13 01:53:55' + INTERVAL '122' DAY;
    v_quantity_to_create := ROUND(0.7, 1);

    INSERT INTO packaged (Instance_ID, Lot_Number, Expiration_Date, Quantity) -- Assuming 'packaged' table name
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Serialized' THEN
    -- Assign a unique serial number
    -- Using Instance ID guarantees uniqueness within this context
    v_serial_number := 'SN-' || TO_CHAR(117.0) || '-' || TO_CHAR(v_new_child_instance_id) || '-' || SUBSTR(SYS_GUID(),1,8);
    -- Assign a batch number - use Product_ID of the *parent* instance as the batch for simplicity? Or a sequence?
    -- Let's use the Parent_IID itself as a simple batch identifier for this run.
    v_batch_number := 558.0; -- All children created FOR this parent get same batch number

    INSERT INTO serialized (Instance_ID, Serial_Number, Batch_Number)
    VALUES (v_new_child_instance_id, v_serial_number, v_batch_number);

    -- Quantity for usesComponent link for serialized is typically 1
    v_quantity_to_create := 1;

  END IF;

  -- Step 3: Create the usesComponent link
  -- Quantity_Used is the Quantity_Needed from needsComponent (which matches child quantity for non-serialized)
  IF v_child_category IN ('Commodity', 'Packaged', 'Serialized') THEN -- Only insert if subtype was handled
      INSERT INTO usesComponent (Parent_IID, Child_IID, Quantity_Used)
      VALUES (558.0, v_new_child_instance_id, ROUND(0.7, 1)); -- Use rounded quantity needed
  END IF;

EXCEPTION
  WHEN OTHERS THEN
    DBMS_OUTPUT.PUT_LINE('Error processing Parent_IID=' || 558.0 || ', Child_PID=' || 117.0 || ': ' || SQLERRM);
    -- Decide if you want to rollback just this block or let the main exception handler catch it
END;
/
DECLARE
  v_new_child_instance_id productInstance.Instance_ID%TYPE;
  v_child_category        product.Category%TYPE := 'Commodity'; -- Pass category
  v_max_existing_batch_lot NUMBER;
  v_next_batch_lot_num   NUMBER;
  v_serial_number        serialized.Serial_Number%TYPE;
  v_batch_number         serialized.Batch_Number%TYPE; -- Shared batch for serialized children of *this* parent
  v_expiration_date      commodity.Expiration_Date%TYPE;
  v_quantity_to_create   commodity.Quantity%TYPE; -- Quantity for the new child instance

BEGIN
  -- Step 1: Create the new child productInstance
  INSERT INTO productInstance (Product_ID, Date_Manufactured, Is_Recalled)
  VALUES (168.0, TIMESTAMP '2025-03-23 17:27:17', 0)
  RETURNING Instance_ID INTO v_new_child_instance_id;

  -- Step 2: Create the corresponding subtype record
  IF v_child_category = 'Commodity' THEN
    -- Find max existing Batch_Number for this specific Child_PID
    SELECT NVL(MAX(c.Batch_Number), 0) INTO v_max_existing_batch_lot
    FROM commodity c JOIN productInstance pi ON c.Instance_ID = pi.Instance_ID
    WHERE pi.Product_ID = 168.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next batch

    v_expiration_date := TIMESTAMP '2025-03-23 17:27:17' + INTERVAL '34' DAY;
    v_quantity_to_create := ROUND(1.7, 1);

    INSERT INTO commodity (Instance_ID, Batch_Number, Expiration_Date, Quantity)
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Packaged' THEN
    -- Find max existing Lot_Number for this specific Child_PID
    SELECT NVL(MAX(p.Lot_Number), 0) INTO v_max_existing_batch_lot
    FROM packaged p JOIN productInstance pi ON p.Instance_ID = pi.Instance_ID -- Assuming 'packaged' table name
    WHERE pi.Product_ID = 168.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next lot

    v_expiration_date := TIMESTAMP '2025-03-23 17:27:17' + INTERVAL '422' DAY;
    v_quantity_to_create := ROUND(1.7, 1);

    INSERT INTO packaged (Instance_ID, Lot_Number, Expiration_Date, Quantity) -- Assuming 'packaged' table name
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Serialized' THEN
    -- Assign a unique serial number
    -- Using Instance ID guarantees uniqueness within this context
    v_serial_number := 'SN-' || TO_CHAR(168.0) || '-' || TO_CHAR(v_new_child_instance_id) || '-' || SUBSTR(SYS_GUID(),1,8);
    -- Assign a batch number - use Product_ID of the *parent* instance as the batch for simplicity? Or a sequence?
    -- Let's use the Parent_IID itself as a simple batch identifier for this run.
    v_batch_number := 558.0; -- All children created FOR this parent get same batch number

    INSERT INTO serialized (Instance_ID, Serial_Number, Batch_Number)
    VALUES (v_new_child_instance_id, v_serial_number, v_batch_number);

    -- Quantity for usesComponent link for serialized is typically 1
    v_quantity_to_create := 1;

  END IF;

  -- Step 3: Create the usesComponent link
  -- Quantity_Used is the Quantity_Needed from needsComponent (which matches child quantity for non-serialized)
  IF v_child_category IN ('Commodity', 'Packaged', 'Serialized') THEN -- Only insert if subtype was handled
      INSERT INTO usesComponent (Parent_IID, Child_IID, Quantity_Used)
      VALUES (558.0, v_new_child_instance_id, ROUND(1.7, 1)); -- Use rounded quantity needed
  END IF;

EXCEPTION
  WHEN OTHERS THEN
    DBMS_OUTPUT.PUT_LINE('Error processing Parent_IID=' || 558.0 || ', Child_PID=' || 168.0 || ': ' || SQLERRM);
    -- Decide if you want to rollback just this block or let the main exception handler catch it
END;
/
DECLARE
  v_new_child_instance_id productInstance.Instance_ID%TYPE;
  v_child_category        product.Category%TYPE := 'Commodity'; -- Pass category
  v_max_existing_batch_lot NUMBER;
  v_next_batch_lot_num   NUMBER;
  v_serial_number        serialized.Serial_Number%TYPE;
  v_batch_number         serialized.Batch_Number%TYPE; -- Shared batch for serialized children of *this* parent
  v_expiration_date      commodity.Expiration_Date%TYPE;
  v_quantity_to_create   commodity.Quantity%TYPE; -- Quantity for the new child instance

BEGIN
  -- Step 1: Create the new child productInstance
  INSERT INTO productInstance (Product_ID, Date_Manufactured, Is_Recalled)
  VALUES (230.0, TIMESTAMP '2024-08-11 11:03:34', 0)
  RETURNING Instance_ID INTO v_new_child_instance_id;

  -- Step 2: Create the corresponding subtype record
  IF v_child_category = 'Commodity' THEN
    -- Find max existing Batch_Number for this specific Child_PID
    SELECT NVL(MAX(c.Batch_Number), 0) INTO v_max_existing_batch_lot
    FROM commodity c JOIN productInstance pi ON c.Instance_ID = pi.Instance_ID
    WHERE pi.Product_ID = 230.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next batch

    v_expiration_date := TIMESTAMP '2024-08-11 11:03:34' + INTERVAL '505' DAY;
    v_quantity_to_create := ROUND(1.5, 1);

    INSERT INTO commodity (Instance_ID, Batch_Number, Expiration_Date, Quantity)
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Packaged' THEN
    -- Find max existing Lot_Number for this specific Child_PID
    SELECT NVL(MAX(p.Lot_Number), 0) INTO v_max_existing_batch_lot
    FROM packaged p JOIN productInstance pi ON p.Instance_ID = pi.Instance_ID -- Assuming 'packaged' table name
    WHERE pi.Product_ID = 230.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next lot

    v_expiration_date := TIMESTAMP '2024-08-11 11:03:34' + INTERVAL '308' DAY;
    v_quantity_to_create := ROUND(1.5, 1);

    INSERT INTO packaged (Instance_ID, Lot_Number, Expiration_Date, Quantity) -- Assuming 'packaged' table name
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Serialized' THEN
    -- Assign a unique serial number
    -- Using Instance ID guarantees uniqueness within this context
    v_serial_number := 'SN-' || TO_CHAR(230.0) || '-' || TO_CHAR(v_new_child_instance_id) || '-' || SUBSTR(SYS_GUID(),1,8);
    -- Assign a batch number - use Product_ID of the *parent* instance as the batch for simplicity? Or a sequence?
    -- Let's use the Parent_IID itself as a simple batch identifier for this run.
    v_batch_number := 559.0; -- All children created FOR this parent get same batch number

    INSERT INTO serialized (Instance_ID, Serial_Number, Batch_Number)
    VALUES (v_new_child_instance_id, v_serial_number, v_batch_number);

    -- Quantity for usesComponent link for serialized is typically 1
    v_quantity_to_create := 1;

  END IF;

  -- Step 3: Create the usesComponent link
  -- Quantity_Used is the Quantity_Needed from needsComponent (which matches child quantity for non-serialized)
  IF v_child_category IN ('Commodity', 'Packaged', 'Serialized') THEN -- Only insert if subtype was handled
      INSERT INTO usesComponent (Parent_IID, Child_IID, Quantity_Used)
      VALUES (559.0, v_new_child_instance_id, ROUND(1.5, 1)); -- Use rounded quantity needed
  END IF;

EXCEPTION
  WHEN OTHERS THEN
    DBMS_OUTPUT.PUT_LINE('Error processing Parent_IID=' || 559.0 || ', Child_PID=' || 230.0 || ': ' || SQLERRM);
    -- Decide if you want to rollback just this block or let the main exception handler catch it
END;
/
DECLARE
  v_new_child_instance_id productInstance.Instance_ID%TYPE;
  v_child_category        product.Category%TYPE := 'Commodity'; -- Pass category
  v_max_existing_batch_lot NUMBER;
  v_next_batch_lot_num   NUMBER;
  v_serial_number        serialized.Serial_Number%TYPE;
  v_batch_number         serialized.Batch_Number%TYPE; -- Shared batch for serialized children of *this* parent
  v_expiration_date      commodity.Expiration_Date%TYPE;
  v_quantity_to_create   commodity.Quantity%TYPE; -- Quantity for the new child instance

BEGIN
  -- Step 1: Create the new child productInstance
  INSERT INTO productInstance (Product_ID, Date_Manufactured, Is_Recalled)
  VALUES (242.0, TIMESTAMP '2025-03-04 03:21:24', 0)
  RETURNING Instance_ID INTO v_new_child_instance_id;

  -- Step 2: Create the corresponding subtype record
  IF v_child_category = 'Commodity' THEN
    -- Find max existing Batch_Number for this specific Child_PID
    SELECT NVL(MAX(c.Batch_Number), 0) INTO v_max_existing_batch_lot
    FROM commodity c JOIN productInstance pi ON c.Instance_ID = pi.Instance_ID
    WHERE pi.Product_ID = 242.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next batch

    v_expiration_date := TIMESTAMP '2025-03-04 03:21:24' + INTERVAL '411' DAY;
    v_quantity_to_create := ROUND(1.0, 1);

    INSERT INTO commodity (Instance_ID, Batch_Number, Expiration_Date, Quantity)
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Packaged' THEN
    -- Find max existing Lot_Number for this specific Child_PID
    SELECT NVL(MAX(p.Lot_Number), 0) INTO v_max_existing_batch_lot
    FROM packaged p JOIN productInstance pi ON p.Instance_ID = pi.Instance_ID -- Assuming 'packaged' table name
    WHERE pi.Product_ID = 242.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next lot

    v_expiration_date := TIMESTAMP '2025-03-04 03:21:24' + INTERVAL '681' DAY;
    v_quantity_to_create := ROUND(1.0, 1);

    INSERT INTO packaged (Instance_ID, Lot_Number, Expiration_Date, Quantity) -- Assuming 'packaged' table name
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Serialized' THEN
    -- Assign a unique serial number
    -- Using Instance ID guarantees uniqueness within this context
    v_serial_number := 'SN-' || TO_CHAR(242.0) || '-' || TO_CHAR(v_new_child_instance_id) || '-' || SUBSTR(SYS_GUID(),1,8);
    -- Assign a batch number - use Product_ID of the *parent* instance as the batch for simplicity? Or a sequence?
    -- Let's use the Parent_IID itself as a simple batch identifier for this run.
    v_batch_number := 559.0; -- All children created FOR this parent get same batch number

    INSERT INTO serialized (Instance_ID, Serial_Number, Batch_Number)
    VALUES (v_new_child_instance_id, v_serial_number, v_batch_number);

    -- Quantity for usesComponent link for serialized is typically 1
    v_quantity_to_create := 1;

  END IF;

  -- Step 3: Create the usesComponent link
  -- Quantity_Used is the Quantity_Needed from needsComponent (which matches child quantity for non-serialized)
  IF v_child_category IN ('Commodity', 'Packaged', 'Serialized') THEN -- Only insert if subtype was handled
      INSERT INTO usesComponent (Parent_IID, Child_IID, Quantity_Used)
      VALUES (559.0, v_new_child_instance_id, ROUND(1.0, 1)); -- Use rounded quantity needed
  END IF;

EXCEPTION
  WHEN OTHERS THEN
    DBMS_OUTPUT.PUT_LINE('Error processing Parent_IID=' || 559.0 || ', Child_PID=' || 242.0 || ': ' || SQLERRM);
    -- Decide if you want to rollback just this block or let the main exception handler catch it
END;
/
DECLARE
  v_new_child_instance_id productInstance.Instance_ID%TYPE;
  v_child_category        product.Category%TYPE := 'Commodity'; -- Pass category
  v_max_existing_batch_lot NUMBER;
  v_next_batch_lot_num   NUMBER;
  v_serial_number        serialized.Serial_Number%TYPE;
  v_batch_number         serialized.Batch_Number%TYPE; -- Shared batch for serialized children of *this* parent
  v_expiration_date      commodity.Expiration_Date%TYPE;
  v_quantity_to_create   commodity.Quantity%TYPE; -- Quantity for the new child instance

BEGIN
  -- Step 1: Create the new child productInstance
  INSERT INTO productInstance (Product_ID, Date_Manufactured, Is_Recalled)
  VALUES (117.0, TIMESTAMP '2025-02-14 01:32:16', 0)
  RETURNING Instance_ID INTO v_new_child_instance_id;

  -- Step 2: Create the corresponding subtype record
  IF v_child_category = 'Commodity' THEN
    -- Find max existing Batch_Number for this specific Child_PID
    SELECT NVL(MAX(c.Batch_Number), 0) INTO v_max_existing_batch_lot
    FROM commodity c JOIN productInstance pi ON c.Instance_ID = pi.Instance_ID
    WHERE pi.Product_ID = 117.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next batch

    v_expiration_date := TIMESTAMP '2025-02-14 01:32:16' + INTERVAL '522' DAY;
    v_quantity_to_create := ROUND(0.7, 1);

    INSERT INTO commodity (Instance_ID, Batch_Number, Expiration_Date, Quantity)
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Packaged' THEN
    -- Find max existing Lot_Number for this specific Child_PID
    SELECT NVL(MAX(p.Lot_Number), 0) INTO v_max_existing_batch_lot
    FROM packaged p JOIN productInstance pi ON p.Instance_ID = pi.Instance_ID -- Assuming 'packaged' table name
    WHERE pi.Product_ID = 117.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next lot

    v_expiration_date := TIMESTAMP '2025-02-14 01:32:16' + INTERVAL '374' DAY;
    v_quantity_to_create := ROUND(0.7, 1);

    INSERT INTO packaged (Instance_ID, Lot_Number, Expiration_Date, Quantity) -- Assuming 'packaged' table name
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Serialized' THEN
    -- Assign a unique serial number
    -- Using Instance ID guarantees uniqueness within this context
    v_serial_number := 'SN-' || TO_CHAR(117.0) || '-' || TO_CHAR(v_new_child_instance_id) || '-' || SUBSTR(SYS_GUID(),1,8);
    -- Assign a batch number - use Product_ID of the *parent* instance as the batch for simplicity? Or a sequence?
    -- Let's use the Parent_IID itself as a simple batch identifier for this run.
    v_batch_number := 559.0; -- All children created FOR this parent get same batch number

    INSERT INTO serialized (Instance_ID, Serial_Number, Batch_Number)
    VALUES (v_new_child_instance_id, v_serial_number, v_batch_number);

    -- Quantity for usesComponent link for serialized is typically 1
    v_quantity_to_create := 1;

  END IF;

  -- Step 3: Create the usesComponent link
  -- Quantity_Used is the Quantity_Needed from needsComponent (which matches child quantity for non-serialized)
  IF v_child_category IN ('Commodity', 'Packaged', 'Serialized') THEN -- Only insert if subtype was handled
      INSERT INTO usesComponent (Parent_IID, Child_IID, Quantity_Used)
      VALUES (559.0, v_new_child_instance_id, ROUND(0.7, 1)); -- Use rounded quantity needed
  END IF;

EXCEPTION
  WHEN OTHERS THEN
    DBMS_OUTPUT.PUT_LINE('Error processing Parent_IID=' || 559.0 || ', Child_PID=' || 117.0 || ': ' || SQLERRM);
    -- Decide if you want to rollback just this block or let the main exception handler catch it
END;
/
DECLARE
  v_new_child_instance_id productInstance.Instance_ID%TYPE;
  v_child_category        product.Category%TYPE := 'Commodity'; -- Pass category
  v_max_existing_batch_lot NUMBER;
  v_next_batch_lot_num   NUMBER;
  v_serial_number        serialized.Serial_Number%TYPE;
  v_batch_number         serialized.Batch_Number%TYPE; -- Shared batch for serialized children of *this* parent
  v_expiration_date      commodity.Expiration_Date%TYPE;
  v_quantity_to_create   commodity.Quantity%TYPE; -- Quantity for the new child instance

BEGIN
  -- Step 1: Create the new child productInstance
  INSERT INTO productInstance (Product_ID, Date_Manufactured, Is_Recalled)
  VALUES (168.0, TIMESTAMP '2024-09-26 21:39:35', 0)
  RETURNING Instance_ID INTO v_new_child_instance_id;

  -- Step 2: Create the corresponding subtype record
  IF v_child_category = 'Commodity' THEN
    -- Find max existing Batch_Number for this specific Child_PID
    SELECT NVL(MAX(c.Batch_Number), 0) INTO v_max_existing_batch_lot
    FROM commodity c JOIN productInstance pi ON c.Instance_ID = pi.Instance_ID
    WHERE pi.Product_ID = 168.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next batch

    v_expiration_date := TIMESTAMP '2024-09-26 21:39:35' + INTERVAL '497' DAY;
    v_quantity_to_create := ROUND(1.7, 1);

    INSERT INTO commodity (Instance_ID, Batch_Number, Expiration_Date, Quantity)
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Packaged' THEN
    -- Find max existing Lot_Number for this specific Child_PID
    SELECT NVL(MAX(p.Lot_Number), 0) INTO v_max_existing_batch_lot
    FROM packaged p JOIN productInstance pi ON p.Instance_ID = pi.Instance_ID -- Assuming 'packaged' table name
    WHERE pi.Product_ID = 168.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next lot

    v_expiration_date := TIMESTAMP '2024-09-26 21:39:35' + INTERVAL '149' DAY;
    v_quantity_to_create := ROUND(1.7, 1);

    INSERT INTO packaged (Instance_ID, Lot_Number, Expiration_Date, Quantity) -- Assuming 'packaged' table name
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Serialized' THEN
    -- Assign a unique serial number
    -- Using Instance ID guarantees uniqueness within this context
    v_serial_number := 'SN-' || TO_CHAR(168.0) || '-' || TO_CHAR(v_new_child_instance_id) || '-' || SUBSTR(SYS_GUID(),1,8);
    -- Assign a batch number - use Product_ID of the *parent* instance as the batch for simplicity? Or a sequence?
    -- Let's use the Parent_IID itself as a simple batch identifier for this run.
    v_batch_number := 559.0; -- All children created FOR this parent get same batch number

    INSERT INTO serialized (Instance_ID, Serial_Number, Batch_Number)
    VALUES (v_new_child_instance_id, v_serial_number, v_batch_number);

    -- Quantity for usesComponent link for serialized is typically 1
    v_quantity_to_create := 1;

  END IF;

  -- Step 3: Create the usesComponent link
  -- Quantity_Used is the Quantity_Needed from needsComponent (which matches child quantity for non-serialized)
  IF v_child_category IN ('Commodity', 'Packaged', 'Serialized') THEN -- Only insert if subtype was handled
      INSERT INTO usesComponent (Parent_IID, Child_IID, Quantity_Used)
      VALUES (559.0, v_new_child_instance_id, ROUND(1.7, 1)); -- Use rounded quantity needed
  END IF;

EXCEPTION
  WHEN OTHERS THEN
    DBMS_OUTPUT.PUT_LINE('Error processing Parent_IID=' || 559.0 || ', Child_PID=' || 168.0 || ': ' || SQLERRM);
    -- Decide if you want to rollback just this block or let the main exception handler catch it
END;
/
DECLARE
  v_new_child_instance_id productInstance.Instance_ID%TYPE;
  v_child_category        product.Category%TYPE := 'Commodity'; -- Pass category
  v_max_existing_batch_lot NUMBER;
  v_next_batch_lot_num   NUMBER;
  v_serial_number        serialized.Serial_Number%TYPE;
  v_batch_number         serialized.Batch_Number%TYPE; -- Shared batch for serialized children of *this* parent
  v_expiration_date      commodity.Expiration_Date%TYPE;
  v_quantity_to_create   commodity.Quantity%TYPE; -- Quantity for the new child instance

BEGIN
  -- Step 1: Create the new child productInstance
  INSERT INTO productInstance (Product_ID, Date_Manufactured, Is_Recalled)
  VALUES (158.0, TIMESTAMP '2024-11-02 21:35:48', 0)
  RETURNING Instance_ID INTO v_new_child_instance_id;

  -- Step 2: Create the corresponding subtype record
  IF v_child_category = 'Commodity' THEN
    -- Find max existing Batch_Number for this specific Child_PID
    SELECT NVL(MAX(c.Batch_Number), 0) INTO v_max_existing_batch_lot
    FROM commodity c JOIN productInstance pi ON c.Instance_ID = pi.Instance_ID
    WHERE pi.Product_ID = 158.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next batch

    v_expiration_date := TIMESTAMP '2024-11-02 21:35:48' + INTERVAL '393' DAY;
    v_quantity_to_create := ROUND(0.2, 1);

    INSERT INTO commodity (Instance_ID, Batch_Number, Expiration_Date, Quantity)
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Packaged' THEN
    -- Find max existing Lot_Number for this specific Child_PID
    SELECT NVL(MAX(p.Lot_Number), 0) INTO v_max_existing_batch_lot
    FROM packaged p JOIN productInstance pi ON p.Instance_ID = pi.Instance_ID -- Assuming 'packaged' table name
    WHERE pi.Product_ID = 158.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next lot

    v_expiration_date := TIMESTAMP '2024-11-02 21:35:48' + INTERVAL '178' DAY;
    v_quantity_to_create := ROUND(0.2, 1);

    INSERT INTO packaged (Instance_ID, Lot_Number, Expiration_Date, Quantity) -- Assuming 'packaged' table name
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Serialized' THEN
    -- Assign a unique serial number
    -- Using Instance ID guarantees uniqueness within this context
    v_serial_number := 'SN-' || TO_CHAR(158.0) || '-' || TO_CHAR(v_new_child_instance_id) || '-' || SUBSTR(SYS_GUID(),1,8);
    -- Assign a batch number - use Product_ID of the *parent* instance as the batch for simplicity? Or a sequence?
    -- Let's use the Parent_IID itself as a simple batch identifier for this run.
    v_batch_number := 571.0; -- All children created FOR this parent get same batch number

    INSERT INTO serialized (Instance_ID, Serial_Number, Batch_Number)
    VALUES (v_new_child_instance_id, v_serial_number, v_batch_number);

    -- Quantity for usesComponent link for serialized is typically 1
    v_quantity_to_create := 1;

  END IF;

  -- Step 3: Create the usesComponent link
  -- Quantity_Used is the Quantity_Needed from needsComponent (which matches child quantity for non-serialized)
  IF v_child_category IN ('Commodity', 'Packaged', 'Serialized') THEN -- Only insert if subtype was handled
      INSERT INTO usesComponent (Parent_IID, Child_IID, Quantity_Used)
      VALUES (571.0, v_new_child_instance_id, ROUND(0.2, 1)); -- Use rounded quantity needed
  END IF;

EXCEPTION
  WHEN OTHERS THEN
    DBMS_OUTPUT.PUT_LINE('Error processing Parent_IID=' || 571.0 || ', Child_PID=' || 158.0 || ': ' || SQLERRM);
    -- Decide if you want to rollback just this block or let the main exception handler catch it
END;
/
DECLARE
  v_new_child_instance_id productInstance.Instance_ID%TYPE;
  v_child_category        product.Category%TYPE := 'Commodity'; -- Pass category
  v_max_existing_batch_lot NUMBER;
  v_next_batch_lot_num   NUMBER;
  v_serial_number        serialized.Serial_Number%TYPE;
  v_batch_number         serialized.Batch_Number%TYPE; -- Shared batch for serialized children of *this* parent
  v_expiration_date      commodity.Expiration_Date%TYPE;
  v_quantity_to_create   commodity.Quantity%TYPE; -- Quantity for the new child instance

BEGIN
  -- Step 1: Create the new child productInstance
  INSERT INTO productInstance (Product_ID, Date_Manufactured, Is_Recalled)
  VALUES (113.0, TIMESTAMP '2024-10-07 06:51:13', 0)
  RETURNING Instance_ID INTO v_new_child_instance_id;

  -- Step 2: Create the corresponding subtype record
  IF v_child_category = 'Commodity' THEN
    -- Find max existing Batch_Number for this specific Child_PID
    SELECT NVL(MAX(c.Batch_Number), 0) INTO v_max_existing_batch_lot
    FROM commodity c JOIN productInstance pi ON c.Instance_ID = pi.Instance_ID
    WHERE pi.Product_ID = 113.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next batch

    v_expiration_date := TIMESTAMP '2024-10-07 06:51:13' + INTERVAL '181' DAY;
    v_quantity_to_create := ROUND(0.2, 1);

    INSERT INTO commodity (Instance_ID, Batch_Number, Expiration_Date, Quantity)
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Packaged' THEN
    -- Find max existing Lot_Number for this specific Child_PID
    SELECT NVL(MAX(p.Lot_Number), 0) INTO v_max_existing_batch_lot
    FROM packaged p JOIN productInstance pi ON p.Instance_ID = pi.Instance_ID -- Assuming 'packaged' table name
    WHERE pi.Product_ID = 113.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next lot

    v_expiration_date := TIMESTAMP '2024-10-07 06:51:13' + INTERVAL '48' DAY;
    v_quantity_to_create := ROUND(0.2, 1);

    INSERT INTO packaged (Instance_ID, Lot_Number, Expiration_Date, Quantity) -- Assuming 'packaged' table name
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Serialized' THEN
    -- Assign a unique serial number
    -- Using Instance ID guarantees uniqueness within this context
    v_serial_number := 'SN-' || TO_CHAR(113.0) || '-' || TO_CHAR(v_new_child_instance_id) || '-' || SUBSTR(SYS_GUID(),1,8);
    -- Assign a batch number - use Product_ID of the *parent* instance as the batch for simplicity? Or a sequence?
    -- Let's use the Parent_IID itself as a simple batch identifier for this run.
    v_batch_number := 571.0; -- All children created FOR this parent get same batch number

    INSERT INTO serialized (Instance_ID, Serial_Number, Batch_Number)
    VALUES (v_new_child_instance_id, v_serial_number, v_batch_number);

    -- Quantity for usesComponent link for serialized is typically 1
    v_quantity_to_create := 1;

  END IF;

  -- Step 3: Create the usesComponent link
  -- Quantity_Used is the Quantity_Needed from needsComponent (which matches child quantity for non-serialized)
  IF v_child_category IN ('Commodity', 'Packaged', 'Serialized') THEN -- Only insert if subtype was handled
      INSERT INTO usesComponent (Parent_IID, Child_IID, Quantity_Used)
      VALUES (571.0, v_new_child_instance_id, ROUND(0.2, 1)); -- Use rounded quantity needed
  END IF;

EXCEPTION
  WHEN OTHERS THEN
    DBMS_OUTPUT.PUT_LINE('Error processing Parent_IID=' || 571.0 || ', Child_PID=' || 113.0 || ': ' || SQLERRM);
    -- Decide if you want to rollback just this block or let the main exception handler catch it
END;
/
DECLARE
  v_new_child_instance_id productInstance.Instance_ID%TYPE;
  v_child_category        product.Category%TYPE := 'Commodity'; -- Pass category
  v_max_existing_batch_lot NUMBER;
  v_next_batch_lot_num   NUMBER;
  v_serial_number        serialized.Serial_Number%TYPE;
  v_batch_number         serialized.Batch_Number%TYPE; -- Shared batch for serialized children of *this* parent
  v_expiration_date      commodity.Expiration_Date%TYPE;
  v_quantity_to_create   commodity.Quantity%TYPE; -- Quantity for the new child instance

BEGIN
  -- Step 1: Create the new child productInstance
  INSERT INTO productInstance (Product_ID, Date_Manufactured, Is_Recalled)
  VALUES (124.0, TIMESTAMP '2024-07-04 20:48:24', 0)
  RETURNING Instance_ID INTO v_new_child_instance_id;

  -- Step 2: Create the corresponding subtype record
  IF v_child_category = 'Commodity' THEN
    -- Find max existing Batch_Number for this specific Child_PID
    SELECT NVL(MAX(c.Batch_Number), 0) INTO v_max_existing_batch_lot
    FROM commodity c JOIN productInstance pi ON c.Instance_ID = pi.Instance_ID
    WHERE pi.Product_ID = 124.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next batch

    v_expiration_date := TIMESTAMP '2024-07-04 20:48:24' + INTERVAL '296' DAY;
    v_quantity_to_create := ROUND(1.8, 1);

    INSERT INTO commodity (Instance_ID, Batch_Number, Expiration_Date, Quantity)
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Packaged' THEN
    -- Find max existing Lot_Number for this specific Child_PID
    SELECT NVL(MAX(p.Lot_Number), 0) INTO v_max_existing_batch_lot
    FROM packaged p JOIN productInstance pi ON p.Instance_ID = pi.Instance_ID -- Assuming 'packaged' table name
    WHERE pi.Product_ID = 124.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next lot

    v_expiration_date := TIMESTAMP '2024-07-04 20:48:24' + INTERVAL '406' DAY;
    v_quantity_to_create := ROUND(1.8, 1);

    INSERT INTO packaged (Instance_ID, Lot_Number, Expiration_Date, Quantity) -- Assuming 'packaged' table name
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Serialized' THEN
    -- Assign a unique serial number
    -- Using Instance ID guarantees uniqueness within this context
    v_serial_number := 'SN-' || TO_CHAR(124.0) || '-' || TO_CHAR(v_new_child_instance_id) || '-' || SUBSTR(SYS_GUID(),1,8);
    -- Assign a batch number - use Product_ID of the *parent* instance as the batch for simplicity? Or a sequence?
    -- Let's use the Parent_IID itself as a simple batch identifier for this run.
    v_batch_number := 571.0; -- All children created FOR this parent get same batch number

    INSERT INTO serialized (Instance_ID, Serial_Number, Batch_Number)
    VALUES (v_new_child_instance_id, v_serial_number, v_batch_number);

    -- Quantity for usesComponent link for serialized is typically 1
    v_quantity_to_create := 1;

  END IF;

  -- Step 3: Create the usesComponent link
  -- Quantity_Used is the Quantity_Needed from needsComponent (which matches child quantity for non-serialized)
  IF v_child_category IN ('Commodity', 'Packaged', 'Serialized') THEN -- Only insert if subtype was handled
      INSERT INTO usesComponent (Parent_IID, Child_IID, Quantity_Used)
      VALUES (571.0, v_new_child_instance_id, ROUND(1.8, 1)); -- Use rounded quantity needed
  END IF;

EXCEPTION
  WHEN OTHERS THEN
    DBMS_OUTPUT.PUT_LINE('Error processing Parent_IID=' || 571.0 || ', Child_PID=' || 124.0 || ': ' || SQLERRM);
    -- Decide if you want to rollback just this block or let the main exception handler catch it
END;
/
DECLARE
  v_new_child_instance_id productInstance.Instance_ID%TYPE;
  v_child_category        product.Category%TYPE := 'Commodity'; -- Pass category
  v_max_existing_batch_lot NUMBER;
  v_next_batch_lot_num   NUMBER;
  v_serial_number        serialized.Serial_Number%TYPE;
  v_batch_number         serialized.Batch_Number%TYPE; -- Shared batch for serialized children of *this* parent
  v_expiration_date      commodity.Expiration_Date%TYPE;
  v_quantity_to_create   commodity.Quantity%TYPE; -- Quantity for the new child instance

BEGIN
  -- Step 1: Create the new child productInstance
  INSERT INTO productInstance (Product_ID, Date_Manufactured, Is_Recalled)
  VALUES (158.0, TIMESTAMP '2025-03-28 05:01:11', 0)
  RETURNING Instance_ID INTO v_new_child_instance_id;

  -- Step 2: Create the corresponding subtype record
  IF v_child_category = 'Commodity' THEN
    -- Find max existing Batch_Number for this specific Child_PID
    SELECT NVL(MAX(c.Batch_Number), 0) INTO v_max_existing_batch_lot
    FROM commodity c JOIN productInstance pi ON c.Instance_ID = pi.Instance_ID
    WHERE pi.Product_ID = 158.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next batch

    v_expiration_date := TIMESTAMP '2025-03-28 05:01:11' + INTERVAL '160' DAY;
    v_quantity_to_create := ROUND(0.2, 1);

    INSERT INTO commodity (Instance_ID, Batch_Number, Expiration_Date, Quantity)
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Packaged' THEN
    -- Find max existing Lot_Number for this specific Child_PID
    SELECT NVL(MAX(p.Lot_Number), 0) INTO v_max_existing_batch_lot
    FROM packaged p JOIN productInstance pi ON p.Instance_ID = pi.Instance_ID -- Assuming 'packaged' table name
    WHERE pi.Product_ID = 158.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next lot

    v_expiration_date := TIMESTAMP '2025-03-28 05:01:11' + INTERVAL '633' DAY;
    v_quantity_to_create := ROUND(0.2, 1);

    INSERT INTO packaged (Instance_ID, Lot_Number, Expiration_Date, Quantity) -- Assuming 'packaged' table name
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Serialized' THEN
    -- Assign a unique serial number
    -- Using Instance ID guarantees uniqueness within this context
    v_serial_number := 'SN-' || TO_CHAR(158.0) || '-' || TO_CHAR(v_new_child_instance_id) || '-' || SUBSTR(SYS_GUID(),1,8);
    -- Assign a batch number - use Product_ID of the *parent* instance as the batch for simplicity? Or a sequence?
    -- Let's use the Parent_IID itself as a simple batch identifier for this run.
    v_batch_number := 572.0; -- All children created FOR this parent get same batch number

    INSERT INTO serialized (Instance_ID, Serial_Number, Batch_Number)
    VALUES (v_new_child_instance_id, v_serial_number, v_batch_number);

    -- Quantity for usesComponent link for serialized is typically 1
    v_quantity_to_create := 1;

  END IF;

  -- Step 3: Create the usesComponent link
  -- Quantity_Used is the Quantity_Needed from needsComponent (which matches child quantity for non-serialized)
  IF v_child_category IN ('Commodity', 'Packaged', 'Serialized') THEN -- Only insert if subtype was handled
      INSERT INTO usesComponent (Parent_IID, Child_IID, Quantity_Used)
      VALUES (572.0, v_new_child_instance_id, ROUND(0.2, 1)); -- Use rounded quantity needed
  END IF;

EXCEPTION
  WHEN OTHERS THEN
    DBMS_OUTPUT.PUT_LINE('Error processing Parent_IID=' || 572.0 || ', Child_PID=' || 158.0 || ': ' || SQLERRM);
    -- Decide if you want to rollback just this block or let the main exception handler catch it
END;
/
DECLARE
  v_new_child_instance_id productInstance.Instance_ID%TYPE;
  v_child_category        product.Category%TYPE := 'Commodity'; -- Pass category
  v_max_existing_batch_lot NUMBER;
  v_next_batch_lot_num   NUMBER;
  v_serial_number        serialized.Serial_Number%TYPE;
  v_batch_number         serialized.Batch_Number%TYPE; -- Shared batch for serialized children of *this* parent
  v_expiration_date      commodity.Expiration_Date%TYPE;
  v_quantity_to_create   commodity.Quantity%TYPE; -- Quantity for the new child instance

BEGIN
  -- Step 1: Create the new child productInstance
  INSERT INTO productInstance (Product_ID, Date_Manufactured, Is_Recalled)
  VALUES (113.0, TIMESTAMP '2025-02-28 08:28:32', 0)
  RETURNING Instance_ID INTO v_new_child_instance_id;

  -- Step 2: Create the corresponding subtype record
  IF v_child_category = 'Commodity' THEN
    -- Find max existing Batch_Number for this specific Child_PID
    SELECT NVL(MAX(c.Batch_Number), 0) INTO v_max_existing_batch_lot
    FROM commodity c JOIN productInstance pi ON c.Instance_ID = pi.Instance_ID
    WHERE pi.Product_ID = 113.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next batch

    v_expiration_date := TIMESTAMP '2025-02-28 08:28:32' + INTERVAL '324' DAY;
    v_quantity_to_create := ROUND(0.2, 1);

    INSERT INTO commodity (Instance_ID, Batch_Number, Expiration_Date, Quantity)
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Packaged' THEN
    -- Find max existing Lot_Number for this specific Child_PID
    SELECT NVL(MAX(p.Lot_Number), 0) INTO v_max_existing_batch_lot
    FROM packaged p JOIN productInstance pi ON p.Instance_ID = pi.Instance_ID -- Assuming 'packaged' table name
    WHERE pi.Product_ID = 113.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next lot

    v_expiration_date := TIMESTAMP '2025-02-28 08:28:32' + INTERVAL '452' DAY;
    v_quantity_to_create := ROUND(0.2, 1);

    INSERT INTO packaged (Instance_ID, Lot_Number, Expiration_Date, Quantity) -- Assuming 'packaged' table name
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Serialized' THEN
    -- Assign a unique serial number
    -- Using Instance ID guarantees uniqueness within this context
    v_serial_number := 'SN-' || TO_CHAR(113.0) || '-' || TO_CHAR(v_new_child_instance_id) || '-' || SUBSTR(SYS_GUID(),1,8);
    -- Assign a batch number - use Product_ID of the *parent* instance as the batch for simplicity? Or a sequence?
    -- Let's use the Parent_IID itself as a simple batch identifier for this run.
    v_batch_number := 572.0; -- All children created FOR this parent get same batch number

    INSERT INTO serialized (Instance_ID, Serial_Number, Batch_Number)
    VALUES (v_new_child_instance_id, v_serial_number, v_batch_number);

    -- Quantity for usesComponent link for serialized is typically 1
    v_quantity_to_create := 1;

  END IF;

  -- Step 3: Create the usesComponent link
  -- Quantity_Used is the Quantity_Needed from needsComponent (which matches child quantity for non-serialized)
  IF v_child_category IN ('Commodity', 'Packaged', 'Serialized') THEN -- Only insert if subtype was handled
      INSERT INTO usesComponent (Parent_IID, Child_IID, Quantity_Used)
      VALUES (572.0, v_new_child_instance_id, ROUND(0.2, 1)); -- Use rounded quantity needed
  END IF;

EXCEPTION
  WHEN OTHERS THEN
    DBMS_OUTPUT.PUT_LINE('Error processing Parent_IID=' || 572.0 || ', Child_PID=' || 113.0 || ': ' || SQLERRM);
    -- Decide if you want to rollback just this block or let the main exception handler catch it
END;
/
DECLARE
  v_new_child_instance_id productInstance.Instance_ID%TYPE;
  v_child_category        product.Category%TYPE := 'Commodity'; -- Pass category
  v_max_existing_batch_lot NUMBER;
  v_next_batch_lot_num   NUMBER;
  v_serial_number        serialized.Serial_Number%TYPE;
  v_batch_number         serialized.Batch_Number%TYPE; -- Shared batch for serialized children of *this* parent
  v_expiration_date      commodity.Expiration_Date%TYPE;
  v_quantity_to_create   commodity.Quantity%TYPE; -- Quantity for the new child instance

BEGIN
  -- Step 1: Create the new child productInstance
  INSERT INTO productInstance (Product_ID, Date_Manufactured, Is_Recalled)
  VALUES (124.0, TIMESTAMP '2024-08-07 04:57:19', 0)
  RETURNING Instance_ID INTO v_new_child_instance_id;

  -- Step 2: Create the corresponding subtype record
  IF v_child_category = 'Commodity' THEN
    -- Find max existing Batch_Number for this specific Child_PID
    SELECT NVL(MAX(c.Batch_Number), 0) INTO v_max_existing_batch_lot
    FROM commodity c JOIN productInstance pi ON c.Instance_ID = pi.Instance_ID
    WHERE pi.Product_ID = 124.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next batch

    v_expiration_date := TIMESTAMP '2024-08-07 04:57:19' + INTERVAL '556' DAY;
    v_quantity_to_create := ROUND(1.8, 1);

    INSERT INTO commodity (Instance_ID, Batch_Number, Expiration_Date, Quantity)
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Packaged' THEN
    -- Find max existing Lot_Number for this specific Child_PID
    SELECT NVL(MAX(p.Lot_Number), 0) INTO v_max_existing_batch_lot
    FROM packaged p JOIN productInstance pi ON p.Instance_ID = pi.Instance_ID -- Assuming 'packaged' table name
    WHERE pi.Product_ID = 124.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next lot

    v_expiration_date := TIMESTAMP '2024-08-07 04:57:19' + INTERVAL '324' DAY;
    v_quantity_to_create := ROUND(1.8, 1);

    INSERT INTO packaged (Instance_ID, Lot_Number, Expiration_Date, Quantity) -- Assuming 'packaged' table name
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Serialized' THEN
    -- Assign a unique serial number
    -- Using Instance ID guarantees uniqueness within this context
    v_serial_number := 'SN-' || TO_CHAR(124.0) || '-' || TO_CHAR(v_new_child_instance_id) || '-' || SUBSTR(SYS_GUID(),1,8);
    -- Assign a batch number - use Product_ID of the *parent* instance as the batch for simplicity? Or a sequence?
    -- Let's use the Parent_IID itself as a simple batch identifier for this run.
    v_batch_number := 572.0; -- All children created FOR this parent get same batch number

    INSERT INTO serialized (Instance_ID, Serial_Number, Batch_Number)
    VALUES (v_new_child_instance_id, v_serial_number, v_batch_number);

    -- Quantity for usesComponent link for serialized is typically 1
    v_quantity_to_create := 1;

  END IF;

  -- Step 3: Create the usesComponent link
  -- Quantity_Used is the Quantity_Needed from needsComponent (which matches child quantity for non-serialized)
  IF v_child_category IN ('Commodity', 'Packaged', 'Serialized') THEN -- Only insert if subtype was handled
      INSERT INTO usesComponent (Parent_IID, Child_IID, Quantity_Used)
      VALUES (572.0, v_new_child_instance_id, ROUND(1.8, 1)); -- Use rounded quantity needed
  END IF;

EXCEPTION
  WHEN OTHERS THEN
    DBMS_OUTPUT.PUT_LINE('Error processing Parent_IID=' || 572.0 || ', Child_PID=' || 124.0 || ': ' || SQLERRM);
    -- Decide if you want to rollback just this block or let the main exception handler catch it
END;
/
DECLARE
  v_new_child_instance_id productInstance.Instance_ID%TYPE;
  v_child_category        product.Category%TYPE := 'Commodity'; -- Pass category
  v_max_existing_batch_lot NUMBER;
  v_next_batch_lot_num   NUMBER;
  v_serial_number        serialized.Serial_Number%TYPE;
  v_batch_number         serialized.Batch_Number%TYPE; -- Shared batch for serialized children of *this* parent
  v_expiration_date      commodity.Expiration_Date%TYPE;
  v_quantity_to_create   commodity.Quantity%TYPE; -- Quantity for the new child instance

BEGIN
  -- Step 1: Create the new child productInstance
  INSERT INTO productInstance (Product_ID, Date_Manufactured, Is_Recalled)
  VALUES (158.0, TIMESTAMP '2025-02-10 05:47:06', 0)
  RETURNING Instance_ID INTO v_new_child_instance_id;

  -- Step 2: Create the corresponding subtype record
  IF v_child_category = 'Commodity' THEN
    -- Find max existing Batch_Number for this specific Child_PID
    SELECT NVL(MAX(c.Batch_Number), 0) INTO v_max_existing_batch_lot
    FROM commodity c JOIN productInstance pi ON c.Instance_ID = pi.Instance_ID
    WHERE pi.Product_ID = 158.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next batch

    v_expiration_date := TIMESTAMP '2025-02-10 05:47:06' + INTERVAL '460' DAY;
    v_quantity_to_create := ROUND(0.2, 1);

    INSERT INTO commodity (Instance_ID, Batch_Number, Expiration_Date, Quantity)
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Packaged' THEN
    -- Find max existing Lot_Number for this specific Child_PID
    SELECT NVL(MAX(p.Lot_Number), 0) INTO v_max_existing_batch_lot
    FROM packaged p JOIN productInstance pi ON p.Instance_ID = pi.Instance_ID -- Assuming 'packaged' table name
    WHERE pi.Product_ID = 158.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next lot

    v_expiration_date := TIMESTAMP '2025-02-10 05:47:06' + INTERVAL '310' DAY;
    v_quantity_to_create := ROUND(0.2, 1);

    INSERT INTO packaged (Instance_ID, Lot_Number, Expiration_Date, Quantity) -- Assuming 'packaged' table name
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Serialized' THEN
    -- Assign a unique serial number
    -- Using Instance ID guarantees uniqueness within this context
    v_serial_number := 'SN-' || TO_CHAR(158.0) || '-' || TO_CHAR(v_new_child_instance_id) || '-' || SUBSTR(SYS_GUID(),1,8);
    -- Assign a batch number - use Product_ID of the *parent* instance as the batch for simplicity? Or a sequence?
    -- Let's use the Parent_IID itself as a simple batch identifier for this run.
    v_batch_number := 573.0; -- All children created FOR this parent get same batch number

    INSERT INTO serialized (Instance_ID, Serial_Number, Batch_Number)
    VALUES (v_new_child_instance_id, v_serial_number, v_batch_number);

    -- Quantity for usesComponent link for serialized is typically 1
    v_quantity_to_create := 1;

  END IF;

  -- Step 3: Create the usesComponent link
  -- Quantity_Used is the Quantity_Needed from needsComponent (which matches child quantity for non-serialized)
  IF v_child_category IN ('Commodity', 'Packaged', 'Serialized') THEN -- Only insert if subtype was handled
      INSERT INTO usesComponent (Parent_IID, Child_IID, Quantity_Used)
      VALUES (573.0, v_new_child_instance_id, ROUND(0.2, 1)); -- Use rounded quantity needed
  END IF;

EXCEPTION
  WHEN OTHERS THEN
    DBMS_OUTPUT.PUT_LINE('Error processing Parent_IID=' || 573.0 || ', Child_PID=' || 158.0 || ': ' || SQLERRM);
    -- Decide if you want to rollback just this block or let the main exception handler catch it
END;
/
DECLARE
  v_new_child_instance_id productInstance.Instance_ID%TYPE;
  v_child_category        product.Category%TYPE := 'Commodity'; -- Pass category
  v_max_existing_batch_lot NUMBER;
  v_next_batch_lot_num   NUMBER;
  v_serial_number        serialized.Serial_Number%TYPE;
  v_batch_number         serialized.Batch_Number%TYPE; -- Shared batch for serialized children of *this* parent
  v_expiration_date      commodity.Expiration_Date%TYPE;
  v_quantity_to_create   commodity.Quantity%TYPE; -- Quantity for the new child instance

BEGIN
  -- Step 1: Create the new child productInstance
  INSERT INTO productInstance (Product_ID, Date_Manufactured, Is_Recalled)
  VALUES (113.0, TIMESTAMP '2024-10-14 09:29:56', 0)
  RETURNING Instance_ID INTO v_new_child_instance_id;

  -- Step 2: Create the corresponding subtype record
  IF v_child_category = 'Commodity' THEN
    -- Find max existing Batch_Number for this specific Child_PID
    SELECT NVL(MAX(c.Batch_Number), 0) INTO v_max_existing_batch_lot
    FROM commodity c JOIN productInstance pi ON c.Instance_ID = pi.Instance_ID
    WHERE pi.Product_ID = 113.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next batch

    v_expiration_date := TIMESTAMP '2024-10-14 09:29:56' + INTERVAL '373' DAY;
    v_quantity_to_create := ROUND(0.2, 1);

    INSERT INTO commodity (Instance_ID, Batch_Number, Expiration_Date, Quantity)
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Packaged' THEN
    -- Find max existing Lot_Number for this specific Child_PID
    SELECT NVL(MAX(p.Lot_Number), 0) INTO v_max_existing_batch_lot
    FROM packaged p JOIN productInstance pi ON p.Instance_ID = pi.Instance_ID -- Assuming 'packaged' table name
    WHERE pi.Product_ID = 113.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next lot

    v_expiration_date := TIMESTAMP '2024-10-14 09:29:56' + INTERVAL '527' DAY;
    v_quantity_to_create := ROUND(0.2, 1);

    INSERT INTO packaged (Instance_ID, Lot_Number, Expiration_Date, Quantity) -- Assuming 'packaged' table name
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Serialized' THEN
    -- Assign a unique serial number
    -- Using Instance ID guarantees uniqueness within this context
    v_serial_number := 'SN-' || TO_CHAR(113.0) || '-' || TO_CHAR(v_new_child_instance_id) || '-' || SUBSTR(SYS_GUID(),1,8);
    -- Assign a batch number - use Product_ID of the *parent* instance as the batch for simplicity? Or a sequence?
    -- Let's use the Parent_IID itself as a simple batch identifier for this run.
    v_batch_number := 573.0; -- All children created FOR this parent get same batch number

    INSERT INTO serialized (Instance_ID, Serial_Number, Batch_Number)
    VALUES (v_new_child_instance_id, v_serial_number, v_batch_number);

    -- Quantity for usesComponent link for serialized is typically 1
    v_quantity_to_create := 1;

  END IF;

  -- Step 3: Create the usesComponent link
  -- Quantity_Used is the Quantity_Needed from needsComponent (which matches child quantity for non-serialized)
  IF v_child_category IN ('Commodity', 'Packaged', 'Serialized') THEN -- Only insert if subtype was handled
      INSERT INTO usesComponent (Parent_IID, Child_IID, Quantity_Used)
      VALUES (573.0, v_new_child_instance_id, ROUND(0.2, 1)); -- Use rounded quantity needed
  END IF;

EXCEPTION
  WHEN OTHERS THEN
    DBMS_OUTPUT.PUT_LINE('Error processing Parent_IID=' || 573.0 || ', Child_PID=' || 113.0 || ': ' || SQLERRM);
    -- Decide if you want to rollback just this block or let the main exception handler catch it
END;
/
DECLARE
  v_new_child_instance_id productInstance.Instance_ID%TYPE;
  v_child_category        product.Category%TYPE := 'Commodity'; -- Pass category
  v_max_existing_batch_lot NUMBER;
  v_next_batch_lot_num   NUMBER;
  v_serial_number        serialized.Serial_Number%TYPE;
  v_batch_number         serialized.Batch_Number%TYPE; -- Shared batch for serialized children of *this* parent
  v_expiration_date      commodity.Expiration_Date%TYPE;
  v_quantity_to_create   commodity.Quantity%TYPE; -- Quantity for the new child instance

BEGIN
  -- Step 1: Create the new child productInstance
  INSERT INTO productInstance (Product_ID, Date_Manufactured, Is_Recalled)
  VALUES (124.0, TIMESTAMP '2024-07-21 17:14:01', 0)
  RETURNING Instance_ID INTO v_new_child_instance_id;

  -- Step 2: Create the corresponding subtype record
  IF v_child_category = 'Commodity' THEN
    -- Find max existing Batch_Number for this specific Child_PID
    SELECT NVL(MAX(c.Batch_Number), 0) INTO v_max_existing_batch_lot
    FROM commodity c JOIN productInstance pi ON c.Instance_ID = pi.Instance_ID
    WHERE pi.Product_ID = 124.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next batch

    v_expiration_date := TIMESTAMP '2024-07-21 17:14:01' + INTERVAL '533' DAY;
    v_quantity_to_create := ROUND(1.8, 1);

    INSERT INTO commodity (Instance_ID, Batch_Number, Expiration_Date, Quantity)
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Packaged' THEN
    -- Find max existing Lot_Number for this specific Child_PID
    SELECT NVL(MAX(p.Lot_Number), 0) INTO v_max_existing_batch_lot
    FROM packaged p JOIN productInstance pi ON p.Instance_ID = pi.Instance_ID -- Assuming 'packaged' table name
    WHERE pi.Product_ID = 124.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next lot

    v_expiration_date := TIMESTAMP '2024-07-21 17:14:01' + INTERVAL '441' DAY;
    v_quantity_to_create := ROUND(1.8, 1);

    INSERT INTO packaged (Instance_ID, Lot_Number, Expiration_Date, Quantity) -- Assuming 'packaged' table name
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Serialized' THEN
    -- Assign a unique serial number
    -- Using Instance ID guarantees uniqueness within this context
    v_serial_number := 'SN-' || TO_CHAR(124.0) || '-' || TO_CHAR(v_new_child_instance_id) || '-' || SUBSTR(SYS_GUID(),1,8);
    -- Assign a batch number - use Product_ID of the *parent* instance as the batch for simplicity? Or a sequence?
    -- Let's use the Parent_IID itself as a simple batch identifier for this run.
    v_batch_number := 573.0; -- All children created FOR this parent get same batch number

    INSERT INTO serialized (Instance_ID, Serial_Number, Batch_Number)
    VALUES (v_new_child_instance_id, v_serial_number, v_batch_number);

    -- Quantity for usesComponent link for serialized is typically 1
    v_quantity_to_create := 1;

  END IF;

  -- Step 3: Create the usesComponent link
  -- Quantity_Used is the Quantity_Needed from needsComponent (which matches child quantity for non-serialized)
  IF v_child_category IN ('Commodity', 'Packaged', 'Serialized') THEN -- Only insert if subtype was handled
      INSERT INTO usesComponent (Parent_IID, Child_IID, Quantity_Used)
      VALUES (573.0, v_new_child_instance_id, ROUND(1.8, 1)); -- Use rounded quantity needed
  END IF;

EXCEPTION
  WHEN OTHERS THEN
    DBMS_OUTPUT.PUT_LINE('Error processing Parent_IID=' || 573.0 || ', Child_PID=' || 124.0 || ': ' || SQLERRM);
    -- Decide if you want to rollback just this block or let the main exception handler catch it
END;
/
DECLARE
  v_new_child_instance_id productInstance.Instance_ID%TYPE;
  v_child_category        product.Category%TYPE := 'Commodity'; -- Pass category
  v_max_existing_batch_lot NUMBER;
  v_next_batch_lot_num   NUMBER;
  v_serial_number        serialized.Serial_Number%TYPE;
  v_batch_number         serialized.Batch_Number%TYPE; -- Shared batch for serialized children of *this* parent
  v_expiration_date      commodity.Expiration_Date%TYPE;
  v_quantity_to_create   commodity.Quantity%TYPE; -- Quantity for the new child instance

BEGIN
  -- Step 1: Create the new child productInstance
  INSERT INTO productInstance (Product_ID, Date_Manufactured, Is_Recalled)
  VALUES (601.0, TIMESTAMP '2025-02-01 04:14:31', 0)
  RETURNING Instance_ID INTO v_new_child_instance_id;

  -- Step 2: Create the corresponding subtype record
  IF v_child_category = 'Commodity' THEN
    -- Find max existing Batch_Number for this specific Child_PID
    SELECT NVL(MAX(c.Batch_Number), 0) INTO v_max_existing_batch_lot
    FROM commodity c JOIN productInstance pi ON c.Instance_ID = pi.Instance_ID
    WHERE pi.Product_ID = 601.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next batch

    v_expiration_date := TIMESTAMP '2025-02-01 04:14:31' + INTERVAL '465' DAY;
    v_quantity_to_create := ROUND(1.7, 1);

    INSERT INTO commodity (Instance_ID, Batch_Number, Expiration_Date, Quantity)
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Packaged' THEN
    -- Find max existing Lot_Number for this specific Child_PID
    SELECT NVL(MAX(p.Lot_Number), 0) INTO v_max_existing_batch_lot
    FROM packaged p JOIN productInstance pi ON p.Instance_ID = pi.Instance_ID -- Assuming 'packaged' table name
    WHERE pi.Product_ID = 601.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next lot

    v_expiration_date := TIMESTAMP '2025-02-01 04:14:31' + INTERVAL '123' DAY;
    v_quantity_to_create := ROUND(1.7, 1);

    INSERT INTO packaged (Instance_ID, Lot_Number, Expiration_Date, Quantity) -- Assuming 'packaged' table name
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Serialized' THEN
    -- Assign a unique serial number
    -- Using Instance ID guarantees uniqueness within this context
    v_serial_number := 'SN-' || TO_CHAR(601.0) || '-' || TO_CHAR(v_new_child_instance_id) || '-' || SUBSTR(SYS_GUID(),1,8);
    -- Assign a batch number - use Product_ID of the *parent* instance as the batch for simplicity? Or a sequence?
    -- Let's use the Parent_IID itself as a simple batch identifier for this run.
    v_batch_number := 574.0; -- All children created FOR this parent get same batch number

    INSERT INTO serialized (Instance_ID, Serial_Number, Batch_Number)
    VALUES (v_new_child_instance_id, v_serial_number, v_batch_number);

    -- Quantity for usesComponent link for serialized is typically 1
    v_quantity_to_create := 1;

  END IF;

  -- Step 3: Create the usesComponent link
  -- Quantity_Used is the Quantity_Needed from needsComponent (which matches child quantity for non-serialized)
  IF v_child_category IN ('Commodity', 'Packaged', 'Serialized') THEN -- Only insert if subtype was handled
      INSERT INTO usesComponent (Parent_IID, Child_IID, Quantity_Used)
      VALUES (574.0, v_new_child_instance_id, ROUND(1.7, 1)); -- Use rounded quantity needed
  END IF;

EXCEPTION
  WHEN OTHERS THEN
    DBMS_OUTPUT.PUT_LINE('Error processing Parent_IID=' || 574.0 || ', Child_PID=' || 601.0 || ': ' || SQLERRM);
    -- Decide if you want to rollback just this block or let the main exception handler catch it
END;
/
DECLARE
  v_new_child_instance_id productInstance.Instance_ID%TYPE;
  v_child_category        product.Category%TYPE := 'Commodity'; -- Pass category
  v_max_existing_batch_lot NUMBER;
  v_next_batch_lot_num   NUMBER;
  v_serial_number        serialized.Serial_Number%TYPE;
  v_batch_number         serialized.Batch_Number%TYPE; -- Shared batch for serialized children of *this* parent
  v_expiration_date      commodity.Expiration_Date%TYPE;
  v_quantity_to_create   commodity.Quantity%TYPE; -- Quantity for the new child instance

BEGIN
  -- Step 1: Create the new child productInstance
  INSERT INTO productInstance (Product_ID, Date_Manufactured, Is_Recalled)
  VALUES (601.0, TIMESTAMP '2024-05-24 01:35:47', 0)
  RETURNING Instance_ID INTO v_new_child_instance_id;

  -- Step 2: Create the corresponding subtype record
  IF v_child_category = 'Commodity' THEN
    -- Find max existing Batch_Number for this specific Child_PID
    SELECT NVL(MAX(c.Batch_Number), 0) INTO v_max_existing_batch_lot
    FROM commodity c JOIN productInstance pi ON c.Instance_ID = pi.Instance_ID
    WHERE pi.Product_ID = 601.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next batch

    v_expiration_date := TIMESTAMP '2024-05-24 01:35:47' + INTERVAL '162' DAY;
    v_quantity_to_create := ROUND(1.7, 1);

    INSERT INTO commodity (Instance_ID, Batch_Number, Expiration_Date, Quantity)
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Packaged' THEN
    -- Find max existing Lot_Number for this specific Child_PID
    SELECT NVL(MAX(p.Lot_Number), 0) INTO v_max_existing_batch_lot
    FROM packaged p JOIN productInstance pi ON p.Instance_ID = pi.Instance_ID -- Assuming 'packaged' table name
    WHERE pi.Product_ID = 601.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next lot

    v_expiration_date := TIMESTAMP '2024-05-24 01:35:47' + INTERVAL '241' DAY;
    v_quantity_to_create := ROUND(1.7, 1);

    INSERT INTO packaged (Instance_ID, Lot_Number, Expiration_Date, Quantity) -- Assuming 'packaged' table name
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Serialized' THEN
    -- Assign a unique serial number
    -- Using Instance ID guarantees uniqueness within this context
    v_serial_number := 'SN-' || TO_CHAR(601.0) || '-' || TO_CHAR(v_new_child_instance_id) || '-' || SUBSTR(SYS_GUID(),1,8);
    -- Assign a batch number - use Product_ID of the *parent* instance as the batch for simplicity? Or a sequence?
    -- Let's use the Parent_IID itself as a simple batch identifier for this run.
    v_batch_number := 575.0; -- All children created FOR this parent get same batch number

    INSERT INTO serialized (Instance_ID, Serial_Number, Batch_Number)
    VALUES (v_new_child_instance_id, v_serial_number, v_batch_number);

    -- Quantity for usesComponent link for serialized is typically 1
    v_quantity_to_create := 1;

  END IF;

  -- Step 3: Create the usesComponent link
  -- Quantity_Used is the Quantity_Needed from needsComponent (which matches child quantity for non-serialized)
  IF v_child_category IN ('Commodity', 'Packaged', 'Serialized') THEN -- Only insert if subtype was handled
      INSERT INTO usesComponent (Parent_IID, Child_IID, Quantity_Used)
      VALUES (575.0, v_new_child_instance_id, ROUND(1.7, 1)); -- Use rounded quantity needed
  END IF;

EXCEPTION
  WHEN OTHERS THEN
    DBMS_OUTPUT.PUT_LINE('Error processing Parent_IID=' || 575.0 || ', Child_PID=' || 601.0 || ': ' || SQLERRM);
    -- Decide if you want to rollback just this block or let the main exception handler catch it
END;
/
DECLARE
  v_new_child_instance_id productInstance.Instance_ID%TYPE;
  v_child_category        product.Category%TYPE := 'Commodity'; -- Pass category
  v_max_existing_batch_lot NUMBER;
  v_next_batch_lot_num   NUMBER;
  v_serial_number        serialized.Serial_Number%TYPE;
  v_batch_number         serialized.Batch_Number%TYPE; -- Shared batch for serialized children of *this* parent
  v_expiration_date      commodity.Expiration_Date%TYPE;
  v_quantity_to_create   commodity.Quantity%TYPE; -- Quantity for the new child instance

BEGIN
  -- Step 1: Create the new child productInstance
  INSERT INTO productInstance (Product_ID, Date_Manufactured, Is_Recalled)
  VALUES (601.0, TIMESTAMP '2024-06-26 03:21:55', 0)
  RETURNING Instance_ID INTO v_new_child_instance_id;

  -- Step 2: Create the corresponding subtype record
  IF v_child_category = 'Commodity' THEN
    -- Find max existing Batch_Number for this specific Child_PID
    SELECT NVL(MAX(c.Batch_Number), 0) INTO v_max_existing_batch_lot
    FROM commodity c JOIN productInstance pi ON c.Instance_ID = pi.Instance_ID
    WHERE pi.Product_ID = 601.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next batch

    v_expiration_date := TIMESTAMP '2024-06-26 03:21:55' + INTERVAL '264' DAY;
    v_quantity_to_create := ROUND(1.7, 1);

    INSERT INTO commodity (Instance_ID, Batch_Number, Expiration_Date, Quantity)
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Packaged' THEN
    -- Find max existing Lot_Number for this specific Child_PID
    SELECT NVL(MAX(p.Lot_Number), 0) INTO v_max_existing_batch_lot
    FROM packaged p JOIN productInstance pi ON p.Instance_ID = pi.Instance_ID -- Assuming 'packaged' table name
    WHERE pi.Product_ID = 601.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next lot

    v_expiration_date := TIMESTAMP '2024-06-26 03:21:55' + INTERVAL '56' DAY;
    v_quantity_to_create := ROUND(1.7, 1);

    INSERT INTO packaged (Instance_ID, Lot_Number, Expiration_Date, Quantity) -- Assuming 'packaged' table name
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Serialized' THEN
    -- Assign a unique serial number
    -- Using Instance ID guarantees uniqueness within this context
    v_serial_number := 'SN-' || TO_CHAR(601.0) || '-' || TO_CHAR(v_new_child_instance_id) || '-' || SUBSTR(SYS_GUID(),1,8);
    -- Assign a batch number - use Product_ID of the *parent* instance as the batch for simplicity? Or a sequence?
    -- Let's use the Parent_IID itself as a simple batch identifier for this run.
    v_batch_number := 576.0; -- All children created FOR this parent get same batch number

    INSERT INTO serialized (Instance_ID, Serial_Number, Batch_Number)
    VALUES (v_new_child_instance_id, v_serial_number, v_batch_number);

    -- Quantity for usesComponent link for serialized is typically 1
    v_quantity_to_create := 1;

  END IF;

  -- Step 3: Create the usesComponent link
  -- Quantity_Used is the Quantity_Needed from needsComponent (which matches child quantity for non-serialized)
  IF v_child_category IN ('Commodity', 'Packaged', 'Serialized') THEN -- Only insert if subtype was handled
      INSERT INTO usesComponent (Parent_IID, Child_IID, Quantity_Used)
      VALUES (576.0, v_new_child_instance_id, ROUND(1.7, 1)); -- Use rounded quantity needed
  END IF;

EXCEPTION
  WHEN OTHERS THEN
    DBMS_OUTPUT.PUT_LINE('Error processing Parent_IID=' || 576.0 || ', Child_PID=' || 601.0 || ': ' || SQLERRM);
    -- Decide if you want to rollback just this block or let the main exception handler catch it
END;
/
DECLARE
  v_new_child_instance_id productInstance.Instance_ID%TYPE;
  v_child_category        product.Category%TYPE := 'Commodity'; -- Pass category
  v_max_existing_batch_lot NUMBER;
  v_next_batch_lot_num   NUMBER;
  v_serial_number        serialized.Serial_Number%TYPE;
  v_batch_number         serialized.Batch_Number%TYPE; -- Shared batch for serialized children of *this* parent
  v_expiration_date      commodity.Expiration_Date%TYPE;
  v_quantity_to_create   commodity.Quantity%TYPE; -- Quantity for the new child instance

BEGIN
  -- Step 1: Create the new child productInstance
  INSERT INTO productInstance (Product_ID, Date_Manufactured, Is_Recalled)
  VALUES (601.0, TIMESTAMP '2024-06-08 03:27:38', 0)
  RETURNING Instance_ID INTO v_new_child_instance_id;

  -- Step 2: Create the corresponding subtype record
  IF v_child_category = 'Commodity' THEN
    -- Find max existing Batch_Number for this specific Child_PID
    SELECT NVL(MAX(c.Batch_Number), 0) INTO v_max_existing_batch_lot
    FROM commodity c JOIN productInstance pi ON c.Instance_ID = pi.Instance_ID
    WHERE pi.Product_ID = 601.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next batch

    v_expiration_date := TIMESTAMP '2024-06-08 03:27:38' + INTERVAL '289' DAY;
    v_quantity_to_create := ROUND(1.7, 1);

    INSERT INTO commodity (Instance_ID, Batch_Number, Expiration_Date, Quantity)
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Packaged' THEN
    -- Find max existing Lot_Number for this specific Child_PID
    SELECT NVL(MAX(p.Lot_Number), 0) INTO v_max_existing_batch_lot
    FROM packaged p JOIN productInstance pi ON p.Instance_ID = pi.Instance_ID -- Assuming 'packaged' table name
    WHERE pi.Product_ID = 601.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next lot

    v_expiration_date := TIMESTAMP '2024-06-08 03:27:38' + INTERVAL '189' DAY;
    v_quantity_to_create := ROUND(1.7, 1);

    INSERT INTO packaged (Instance_ID, Lot_Number, Expiration_Date, Quantity) -- Assuming 'packaged' table name
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Serialized' THEN
    -- Assign a unique serial number
    -- Using Instance ID guarantees uniqueness within this context
    v_serial_number := 'SN-' || TO_CHAR(601.0) || '-' || TO_CHAR(v_new_child_instance_id) || '-' || SUBSTR(SYS_GUID(),1,8);
    -- Assign a batch number - use Product_ID of the *parent* instance as the batch for simplicity? Or a sequence?
    -- Let's use the Parent_IID itself as a simple batch identifier for this run.
    v_batch_number := 577.0; -- All children created FOR this parent get same batch number

    INSERT INTO serialized (Instance_ID, Serial_Number, Batch_Number)
    VALUES (v_new_child_instance_id, v_serial_number, v_batch_number);

    -- Quantity for usesComponent link for serialized is typically 1
    v_quantity_to_create := 1;

  END IF;

  -- Step 3: Create the usesComponent link
  -- Quantity_Used is the Quantity_Needed from needsComponent (which matches child quantity for non-serialized)
  IF v_child_category IN ('Commodity', 'Packaged', 'Serialized') THEN -- Only insert if subtype was handled
      INSERT INTO usesComponent (Parent_IID, Child_IID, Quantity_Used)
      VALUES (577.0, v_new_child_instance_id, ROUND(1.7, 1)); -- Use rounded quantity needed
  END IF;

EXCEPTION
  WHEN OTHERS THEN
    DBMS_OUTPUT.PUT_LINE('Error processing Parent_IID=' || 577.0 || ', Child_PID=' || 601.0 || ': ' || SQLERRM);
    -- Decide if you want to rollback just this block or let the main exception handler catch it
END;
/
DECLARE
  v_new_child_instance_id productInstance.Instance_ID%TYPE;
  v_child_category        product.Category%TYPE := 'Commodity'; -- Pass category
  v_max_existing_batch_lot NUMBER;
  v_next_batch_lot_num   NUMBER;
  v_serial_number        serialized.Serial_Number%TYPE;
  v_batch_number         serialized.Batch_Number%TYPE; -- Shared batch for serialized children of *this* parent
  v_expiration_date      commodity.Expiration_Date%TYPE;
  v_quantity_to_create   commodity.Quantity%TYPE; -- Quantity for the new child instance

BEGIN
  -- Step 1: Create the new child productInstance
  INSERT INTO productInstance (Product_ID, Date_Manufactured, Is_Recalled)
  VALUES (231.0, TIMESTAMP '2024-11-01 08:54:02', 0)
  RETURNING Instance_ID INTO v_new_child_instance_id;

  -- Step 2: Create the corresponding subtype record
  IF v_child_category = 'Commodity' THEN
    -- Find max existing Batch_Number for this specific Child_PID
    SELECT NVL(MAX(c.Batch_Number), 0) INTO v_max_existing_batch_lot
    FROM commodity c JOIN productInstance pi ON c.Instance_ID = pi.Instance_ID
    WHERE pi.Product_ID = 231.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next batch

    v_expiration_date := TIMESTAMP '2024-11-01 08:54:02' + INTERVAL '131' DAY;
    v_quantity_to_create := ROUND(0.2, 1);

    INSERT INTO commodity (Instance_ID, Batch_Number, Expiration_Date, Quantity)
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Packaged' THEN
    -- Find max existing Lot_Number for this specific Child_PID
    SELECT NVL(MAX(p.Lot_Number), 0) INTO v_max_existing_batch_lot
    FROM packaged p JOIN productInstance pi ON p.Instance_ID = pi.Instance_ID -- Assuming 'packaged' table name
    WHERE pi.Product_ID = 231.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next lot

    v_expiration_date := TIMESTAMP '2024-11-01 08:54:02' + INTERVAL '438' DAY;
    v_quantity_to_create := ROUND(0.2, 1);

    INSERT INTO packaged (Instance_ID, Lot_Number, Expiration_Date, Quantity) -- Assuming 'packaged' table name
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Serialized' THEN
    -- Assign a unique serial number
    -- Using Instance ID guarantees uniqueness within this context
    v_serial_number := 'SN-' || TO_CHAR(231.0) || '-' || TO_CHAR(v_new_child_instance_id) || '-' || SUBSTR(SYS_GUID(),1,8);
    -- Assign a batch number - use Product_ID of the *parent* instance as the batch for simplicity? Or a sequence?
    -- Let's use the Parent_IID itself as a simple batch identifier for this run.
    v_batch_number := 599.0; -- All children created FOR this parent get same batch number

    INSERT INTO serialized (Instance_ID, Serial_Number, Batch_Number)
    VALUES (v_new_child_instance_id, v_serial_number, v_batch_number);

    -- Quantity for usesComponent link for serialized is typically 1
    v_quantity_to_create := 1;

  END IF;

  -- Step 3: Create the usesComponent link
  -- Quantity_Used is the Quantity_Needed from needsComponent (which matches child quantity for non-serialized)
  IF v_child_category IN ('Commodity', 'Packaged', 'Serialized') THEN -- Only insert if subtype was handled
      INSERT INTO usesComponent (Parent_IID, Child_IID, Quantity_Used)
      VALUES (599.0, v_new_child_instance_id, ROUND(0.2, 1)); -- Use rounded quantity needed
  END IF;

EXCEPTION
  WHEN OTHERS THEN
    DBMS_OUTPUT.PUT_LINE('Error processing Parent_IID=' || 599.0 || ', Child_PID=' || 231.0 || ': ' || SQLERRM);
    -- Decide if you want to rollback just this block or let the main exception handler catch it
END;
/
DECLARE
  v_new_child_instance_id productInstance.Instance_ID%TYPE;
  v_child_category        product.Category%TYPE := 'Commodity'; -- Pass category
  v_max_existing_batch_lot NUMBER;
  v_next_batch_lot_num   NUMBER;
  v_serial_number        serialized.Serial_Number%TYPE;
  v_batch_number         serialized.Batch_Number%TYPE; -- Shared batch for serialized children of *this* parent
  v_expiration_date      commodity.Expiration_Date%TYPE;
  v_quantity_to_create   commodity.Quantity%TYPE; -- Quantity for the new child instance

BEGIN
  -- Step 1: Create the new child productInstance
  INSERT INTO productInstance (Product_ID, Date_Manufactured, Is_Recalled)
  VALUES (144.0, TIMESTAMP '2025-01-06 08:14:03', 0)
  RETURNING Instance_ID INTO v_new_child_instance_id;

  -- Step 2: Create the corresponding subtype record
  IF v_child_category = 'Commodity' THEN
    -- Find max existing Batch_Number for this specific Child_PID
    SELECT NVL(MAX(c.Batch_Number), 0) INTO v_max_existing_batch_lot
    FROM commodity c JOIN productInstance pi ON c.Instance_ID = pi.Instance_ID
    WHERE pi.Product_ID = 144.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next batch

    v_expiration_date := TIMESTAMP '2025-01-06 08:14:03' + INTERVAL '221' DAY;
    v_quantity_to_create := ROUND(1.9, 1);

    INSERT INTO commodity (Instance_ID, Batch_Number, Expiration_Date, Quantity)
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Packaged' THEN
    -- Find max existing Lot_Number for this specific Child_PID
    SELECT NVL(MAX(p.Lot_Number), 0) INTO v_max_existing_batch_lot
    FROM packaged p JOIN productInstance pi ON p.Instance_ID = pi.Instance_ID -- Assuming 'packaged' table name
    WHERE pi.Product_ID = 144.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next lot

    v_expiration_date := TIMESTAMP '2025-01-06 08:14:03' + INTERVAL '33' DAY;
    v_quantity_to_create := ROUND(1.9, 1);

    INSERT INTO packaged (Instance_ID, Lot_Number, Expiration_Date, Quantity) -- Assuming 'packaged' table name
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Serialized' THEN
    -- Assign a unique serial number
    -- Using Instance ID guarantees uniqueness within this context
    v_serial_number := 'SN-' || TO_CHAR(144.0) || '-' || TO_CHAR(v_new_child_instance_id) || '-' || SUBSTR(SYS_GUID(),1,8);
    -- Assign a batch number - use Product_ID of the *parent* instance as the batch for simplicity? Or a sequence?
    -- Let's use the Parent_IID itself as a simple batch identifier for this run.
    v_batch_number := 599.0; -- All children created FOR this parent get same batch number

    INSERT INTO serialized (Instance_ID, Serial_Number, Batch_Number)
    VALUES (v_new_child_instance_id, v_serial_number, v_batch_number);

    -- Quantity for usesComponent link for serialized is typically 1
    v_quantity_to_create := 1;

  END IF;

  -- Step 3: Create the usesComponent link
  -- Quantity_Used is the Quantity_Needed from needsComponent (which matches child quantity for non-serialized)
  IF v_child_category IN ('Commodity', 'Packaged', 'Serialized') THEN -- Only insert if subtype was handled
      INSERT INTO usesComponent (Parent_IID, Child_IID, Quantity_Used)
      VALUES (599.0, v_new_child_instance_id, ROUND(1.9, 1)); -- Use rounded quantity needed
  END IF;

EXCEPTION
  WHEN OTHERS THEN
    DBMS_OUTPUT.PUT_LINE('Error processing Parent_IID=' || 599.0 || ', Child_PID=' || 144.0 || ': ' || SQLERRM);
    -- Decide if you want to rollback just this block or let the main exception handler catch it
END;
/
DECLARE
  v_new_child_instance_id productInstance.Instance_ID%TYPE;
  v_child_category        product.Category%TYPE := 'Commodity'; -- Pass category
  v_max_existing_batch_lot NUMBER;
  v_next_batch_lot_num   NUMBER;
  v_serial_number        serialized.Serial_Number%TYPE;
  v_batch_number         serialized.Batch_Number%TYPE; -- Shared batch for serialized children of *this* parent
  v_expiration_date      commodity.Expiration_Date%TYPE;
  v_quantity_to_create   commodity.Quantity%TYPE; -- Quantity for the new child instance

BEGIN
  -- Step 1: Create the new child productInstance
  INSERT INTO productInstance (Product_ID, Date_Manufactured, Is_Recalled)
  VALUES (167.0, TIMESTAMP '2024-06-02 16:00:40', 0)
  RETURNING Instance_ID INTO v_new_child_instance_id;

  -- Step 2: Create the corresponding subtype record
  IF v_child_category = 'Commodity' THEN
    -- Find max existing Batch_Number for this specific Child_PID
    SELECT NVL(MAX(c.Batch_Number), 0) INTO v_max_existing_batch_lot
    FROM commodity c JOIN productInstance pi ON c.Instance_ID = pi.Instance_ID
    WHERE pi.Product_ID = 167.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next batch

    v_expiration_date := TIMESTAMP '2024-06-02 16:00:40' + INTERVAL '467' DAY;
    v_quantity_to_create := ROUND(0.2, 1);

    INSERT INTO commodity (Instance_ID, Batch_Number, Expiration_Date, Quantity)
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Packaged' THEN
    -- Find max existing Lot_Number for this specific Child_PID
    SELECT NVL(MAX(p.Lot_Number), 0) INTO v_max_existing_batch_lot
    FROM packaged p JOIN productInstance pi ON p.Instance_ID = pi.Instance_ID -- Assuming 'packaged' table name
    WHERE pi.Product_ID = 167.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next lot

    v_expiration_date := TIMESTAMP '2024-06-02 16:00:40' + INTERVAL '656' DAY;
    v_quantity_to_create := ROUND(0.2, 1);

    INSERT INTO packaged (Instance_ID, Lot_Number, Expiration_Date, Quantity) -- Assuming 'packaged' table name
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Serialized' THEN
    -- Assign a unique serial number
    -- Using Instance ID guarantees uniqueness within this context
    v_serial_number := 'SN-' || TO_CHAR(167.0) || '-' || TO_CHAR(v_new_child_instance_id) || '-' || SUBSTR(SYS_GUID(),1,8);
    -- Assign a batch number - use Product_ID of the *parent* instance as the batch for simplicity? Or a sequence?
    -- Let's use the Parent_IID itself as a simple batch identifier for this run.
    v_batch_number := 599.0; -- All children created FOR this parent get same batch number

    INSERT INTO serialized (Instance_ID, Serial_Number, Batch_Number)
    VALUES (v_new_child_instance_id, v_serial_number, v_batch_number);

    -- Quantity for usesComponent link for serialized is typically 1
    v_quantity_to_create := 1;

  END IF;

  -- Step 3: Create the usesComponent link
  -- Quantity_Used is the Quantity_Needed from needsComponent (which matches child quantity for non-serialized)
  IF v_child_category IN ('Commodity', 'Packaged', 'Serialized') THEN -- Only insert if subtype was handled
      INSERT INTO usesComponent (Parent_IID, Child_IID, Quantity_Used)
      VALUES (599.0, v_new_child_instance_id, ROUND(0.2, 1)); -- Use rounded quantity needed
  END IF;

EXCEPTION
  WHEN OTHERS THEN
    DBMS_OUTPUT.PUT_LINE('Error processing Parent_IID=' || 599.0 || ', Child_PID=' || 167.0 || ': ' || SQLERRM);
    -- Decide if you want to rollback just this block or let the main exception handler catch it
END;
/
DECLARE
  v_new_child_instance_id productInstance.Instance_ID%TYPE;
  v_child_category        product.Category%TYPE := 'Commodity'; -- Pass category
  v_max_existing_batch_lot NUMBER;
  v_next_batch_lot_num   NUMBER;
  v_serial_number        serialized.Serial_Number%TYPE;
  v_batch_number         serialized.Batch_Number%TYPE; -- Shared batch for serialized children of *this* parent
  v_expiration_date      commodity.Expiration_Date%TYPE;
  v_quantity_to_create   commodity.Quantity%TYPE; -- Quantity for the new child instance

BEGIN
  -- Step 1: Create the new child productInstance
  INSERT INTO productInstance (Product_ID, Date_Manufactured, Is_Recalled)
  VALUES (231.0, TIMESTAMP '2024-05-18 19:07:35', 0)
  RETURNING Instance_ID INTO v_new_child_instance_id;

  -- Step 2: Create the corresponding subtype record
  IF v_child_category = 'Commodity' THEN
    -- Find max existing Batch_Number for this specific Child_PID
    SELECT NVL(MAX(c.Batch_Number), 0) INTO v_max_existing_batch_lot
    FROM commodity c JOIN productInstance pi ON c.Instance_ID = pi.Instance_ID
    WHERE pi.Product_ID = 231.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next batch

    v_expiration_date := TIMESTAMP '2024-05-18 19:07:35' + INTERVAL '592' DAY;
    v_quantity_to_create := ROUND(0.2, 1);

    INSERT INTO commodity (Instance_ID, Batch_Number, Expiration_Date, Quantity)
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Packaged' THEN
    -- Find max existing Lot_Number for this specific Child_PID
    SELECT NVL(MAX(p.Lot_Number), 0) INTO v_max_existing_batch_lot
    FROM packaged p JOIN productInstance pi ON p.Instance_ID = pi.Instance_ID -- Assuming 'packaged' table name
    WHERE pi.Product_ID = 231.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next lot

    v_expiration_date := TIMESTAMP '2024-05-18 19:07:35' + INTERVAL '253' DAY;
    v_quantity_to_create := ROUND(0.2, 1);

    INSERT INTO packaged (Instance_ID, Lot_Number, Expiration_Date, Quantity) -- Assuming 'packaged' table name
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Serialized' THEN
    -- Assign a unique serial number
    -- Using Instance ID guarantees uniqueness within this context
    v_serial_number := 'SN-' || TO_CHAR(231.0) || '-' || TO_CHAR(v_new_child_instance_id) || '-' || SUBSTR(SYS_GUID(),1,8);
    -- Assign a batch number - use Product_ID of the *parent* instance as the batch for simplicity? Or a sequence?
    -- Let's use the Parent_IID itself as a simple batch identifier for this run.
    v_batch_number := 600.0; -- All children created FOR this parent get same batch number

    INSERT INTO serialized (Instance_ID, Serial_Number, Batch_Number)
    VALUES (v_new_child_instance_id, v_serial_number, v_batch_number);

    -- Quantity for usesComponent link for serialized is typically 1
    v_quantity_to_create := 1;

  END IF;

  -- Step 3: Create the usesComponent link
  -- Quantity_Used is the Quantity_Needed from needsComponent (which matches child quantity for non-serialized)
  IF v_child_category IN ('Commodity', 'Packaged', 'Serialized') THEN -- Only insert if subtype was handled
      INSERT INTO usesComponent (Parent_IID, Child_IID, Quantity_Used)
      VALUES (600.0, v_new_child_instance_id, ROUND(0.2, 1)); -- Use rounded quantity needed
  END IF;

EXCEPTION
  WHEN OTHERS THEN
    DBMS_OUTPUT.PUT_LINE('Error processing Parent_IID=' || 600.0 || ', Child_PID=' || 231.0 || ': ' || SQLERRM);
    -- Decide if you want to rollback just this block or let the main exception handler catch it
END;
/
DECLARE
  v_new_child_instance_id productInstance.Instance_ID%TYPE;
  v_child_category        product.Category%TYPE := 'Commodity'; -- Pass category
  v_max_existing_batch_lot NUMBER;
  v_next_batch_lot_num   NUMBER;
  v_serial_number        serialized.Serial_Number%TYPE;
  v_batch_number         serialized.Batch_Number%TYPE; -- Shared batch for serialized children of *this* parent
  v_expiration_date      commodity.Expiration_Date%TYPE;
  v_quantity_to_create   commodity.Quantity%TYPE; -- Quantity for the new child instance

BEGIN
  -- Step 1: Create the new child productInstance
  INSERT INTO productInstance (Product_ID, Date_Manufactured, Is_Recalled)
  VALUES (144.0, TIMESTAMP '2024-11-22 14:44:00', 0)
  RETURNING Instance_ID INTO v_new_child_instance_id;

  -- Step 2: Create the corresponding subtype record
  IF v_child_category = 'Commodity' THEN
    -- Find max existing Batch_Number for this specific Child_PID
    SELECT NVL(MAX(c.Batch_Number), 0) INTO v_max_existing_batch_lot
    FROM commodity c JOIN productInstance pi ON c.Instance_ID = pi.Instance_ID
    WHERE pi.Product_ID = 144.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next batch

    v_expiration_date := TIMESTAMP '2024-11-22 14:44:00' + INTERVAL '462' DAY;
    v_quantity_to_create := ROUND(1.9, 1);

    INSERT INTO commodity (Instance_ID, Batch_Number, Expiration_Date, Quantity)
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Packaged' THEN
    -- Find max existing Lot_Number for this specific Child_PID
    SELECT NVL(MAX(p.Lot_Number), 0) INTO v_max_existing_batch_lot
    FROM packaged p JOIN productInstance pi ON p.Instance_ID = pi.Instance_ID -- Assuming 'packaged' table name
    WHERE pi.Product_ID = 144.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next lot

    v_expiration_date := TIMESTAMP '2024-11-22 14:44:00' + INTERVAL '385' DAY;
    v_quantity_to_create := ROUND(1.9, 1);

    INSERT INTO packaged (Instance_ID, Lot_Number, Expiration_Date, Quantity) -- Assuming 'packaged' table name
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Serialized' THEN
    -- Assign a unique serial number
    -- Using Instance ID guarantees uniqueness within this context
    v_serial_number := 'SN-' || TO_CHAR(144.0) || '-' || TO_CHAR(v_new_child_instance_id) || '-' || SUBSTR(SYS_GUID(),1,8);
    -- Assign a batch number - use Product_ID of the *parent* instance as the batch for simplicity? Or a sequence?
    -- Let's use the Parent_IID itself as a simple batch identifier for this run.
    v_batch_number := 600.0; -- All children created FOR this parent get same batch number

    INSERT INTO serialized (Instance_ID, Serial_Number, Batch_Number)
    VALUES (v_new_child_instance_id, v_serial_number, v_batch_number);

    -- Quantity for usesComponent link for serialized is typically 1
    v_quantity_to_create := 1;

  END IF;

  -- Step 3: Create the usesComponent link
  -- Quantity_Used is the Quantity_Needed from needsComponent (which matches child quantity for non-serialized)
  IF v_child_category IN ('Commodity', 'Packaged', 'Serialized') THEN -- Only insert if subtype was handled
      INSERT INTO usesComponent (Parent_IID, Child_IID, Quantity_Used)
      VALUES (600.0, v_new_child_instance_id, ROUND(1.9, 1)); -- Use rounded quantity needed
  END IF;

EXCEPTION
  WHEN OTHERS THEN
    DBMS_OUTPUT.PUT_LINE('Error processing Parent_IID=' || 600.0 || ', Child_PID=' || 144.0 || ': ' || SQLERRM);
    -- Decide if you want to rollback just this block or let the main exception handler catch it
END;
/
DECLARE
  v_new_child_instance_id productInstance.Instance_ID%TYPE;
  v_child_category        product.Category%TYPE := 'Commodity'; -- Pass category
  v_max_existing_batch_lot NUMBER;
  v_next_batch_lot_num   NUMBER;
  v_serial_number        serialized.Serial_Number%TYPE;
  v_batch_number         serialized.Batch_Number%TYPE; -- Shared batch for serialized children of *this* parent
  v_expiration_date      commodity.Expiration_Date%TYPE;
  v_quantity_to_create   commodity.Quantity%TYPE; -- Quantity for the new child instance

BEGIN
  -- Step 1: Create the new child productInstance
  INSERT INTO productInstance (Product_ID, Date_Manufactured, Is_Recalled)
  VALUES (167.0, TIMESTAMP '2024-05-17 07:21:25', 0)
  RETURNING Instance_ID INTO v_new_child_instance_id;

  -- Step 2: Create the corresponding subtype record
  IF v_child_category = 'Commodity' THEN
    -- Find max existing Batch_Number for this specific Child_PID
    SELECT NVL(MAX(c.Batch_Number), 0) INTO v_max_existing_batch_lot
    FROM commodity c JOIN productInstance pi ON c.Instance_ID = pi.Instance_ID
    WHERE pi.Product_ID = 167.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next batch

    v_expiration_date := TIMESTAMP '2024-05-17 07:21:25' + INTERVAL '697' DAY;
    v_quantity_to_create := ROUND(0.2, 1);

    INSERT INTO commodity (Instance_ID, Batch_Number, Expiration_Date, Quantity)
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Packaged' THEN
    -- Find max existing Lot_Number for this specific Child_PID
    SELECT NVL(MAX(p.Lot_Number), 0) INTO v_max_existing_batch_lot
    FROM packaged p JOIN productInstance pi ON p.Instance_ID = pi.Instance_ID -- Assuming 'packaged' table name
    WHERE pi.Product_ID = 167.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next lot

    v_expiration_date := TIMESTAMP '2024-05-17 07:21:25' + INTERVAL '135' DAY;
    v_quantity_to_create := ROUND(0.2, 1);

    INSERT INTO packaged (Instance_ID, Lot_Number, Expiration_Date, Quantity) -- Assuming 'packaged' table name
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Serialized' THEN
    -- Assign a unique serial number
    -- Using Instance ID guarantees uniqueness within this context
    v_serial_number := 'SN-' || TO_CHAR(167.0) || '-' || TO_CHAR(v_new_child_instance_id) || '-' || SUBSTR(SYS_GUID(),1,8);
    -- Assign a batch number - use Product_ID of the *parent* instance as the batch for simplicity? Or a sequence?
    -- Let's use the Parent_IID itself as a simple batch identifier for this run.
    v_batch_number := 600.0; -- All children created FOR this parent get same batch number

    INSERT INTO serialized (Instance_ID, Serial_Number, Batch_Number)
    VALUES (v_new_child_instance_id, v_serial_number, v_batch_number);

    -- Quantity for usesComponent link for serialized is typically 1
    v_quantity_to_create := 1;

  END IF;

  -- Step 3: Create the usesComponent link
  -- Quantity_Used is the Quantity_Needed from needsComponent (which matches child quantity for non-serialized)
  IF v_child_category IN ('Commodity', 'Packaged', 'Serialized') THEN -- Only insert if subtype was handled
      INSERT INTO usesComponent (Parent_IID, Child_IID, Quantity_Used)
      VALUES (600.0, v_new_child_instance_id, ROUND(0.2, 1)); -- Use rounded quantity needed
  END IF;

EXCEPTION
  WHEN OTHERS THEN
    DBMS_OUTPUT.PUT_LINE('Error processing Parent_IID=' || 600.0 || ', Child_PID=' || 167.0 || ': ' || SQLERRM);
    -- Decide if you want to rollback just this block or let the main exception handler catch it
END;
/
DECLARE
  v_new_child_instance_id productInstance.Instance_ID%TYPE;
  v_child_category        product.Category%TYPE := 'Commodity'; -- Pass category
  v_max_existing_batch_lot NUMBER;
  v_next_batch_lot_num   NUMBER;
  v_serial_number        serialized.Serial_Number%TYPE;
  v_batch_number         serialized.Batch_Number%TYPE; -- Shared batch for serialized children of *this* parent
  v_expiration_date      commodity.Expiration_Date%TYPE;
  v_quantity_to_create   commodity.Quantity%TYPE; -- Quantity for the new child instance

BEGIN
  -- Step 1: Create the new child productInstance
  INSERT INTO productInstance (Product_ID, Date_Manufactured, Is_Recalled)
  VALUES (231.0, TIMESTAMP '2025-02-08 07:11:31', 0)
  RETURNING Instance_ID INTO v_new_child_instance_id;

  -- Step 2: Create the corresponding subtype record
  IF v_child_category = 'Commodity' THEN
    -- Find max existing Batch_Number for this specific Child_PID
    SELECT NVL(MAX(c.Batch_Number), 0) INTO v_max_existing_batch_lot
    FROM commodity c JOIN productInstance pi ON c.Instance_ID = pi.Instance_ID
    WHERE pi.Product_ID = 231.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next batch

    v_expiration_date := TIMESTAMP '2025-02-08 07:11:31' + INTERVAL '596' DAY;
    v_quantity_to_create := ROUND(0.2, 1);

    INSERT INTO commodity (Instance_ID, Batch_Number, Expiration_Date, Quantity)
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Packaged' THEN
    -- Find max existing Lot_Number for this specific Child_PID
    SELECT NVL(MAX(p.Lot_Number), 0) INTO v_max_existing_batch_lot
    FROM packaged p JOIN productInstance pi ON p.Instance_ID = pi.Instance_ID -- Assuming 'packaged' table name
    WHERE pi.Product_ID = 231.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next lot

    v_expiration_date := TIMESTAMP '2025-02-08 07:11:31' + INTERVAL '725' DAY;
    v_quantity_to_create := ROUND(0.2, 1);

    INSERT INTO packaged (Instance_ID, Lot_Number, Expiration_Date, Quantity) -- Assuming 'packaged' table name
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Serialized' THEN
    -- Assign a unique serial number
    -- Using Instance ID guarantees uniqueness within this context
    v_serial_number := 'SN-' || TO_CHAR(231.0) || '-' || TO_CHAR(v_new_child_instance_id) || '-' || SUBSTR(SYS_GUID(),1,8);
    -- Assign a batch number - use Product_ID of the *parent* instance as the batch for simplicity? Or a sequence?
    -- Let's use the Parent_IID itself as a simple batch identifier for this run.
    v_batch_number := 601.0; -- All children created FOR this parent get same batch number

    INSERT INTO serialized (Instance_ID, Serial_Number, Batch_Number)
    VALUES (v_new_child_instance_id, v_serial_number, v_batch_number);

    -- Quantity for usesComponent link for serialized is typically 1
    v_quantity_to_create := 1;

  END IF;

  -- Step 3: Create the usesComponent link
  -- Quantity_Used is the Quantity_Needed from needsComponent (which matches child quantity for non-serialized)
  IF v_child_category IN ('Commodity', 'Packaged', 'Serialized') THEN -- Only insert if subtype was handled
      INSERT INTO usesComponent (Parent_IID, Child_IID, Quantity_Used)
      VALUES (601.0, v_new_child_instance_id, ROUND(0.2, 1)); -- Use rounded quantity needed
  END IF;

EXCEPTION
  WHEN OTHERS THEN
    DBMS_OUTPUT.PUT_LINE('Error processing Parent_IID=' || 601.0 || ', Child_PID=' || 231.0 || ': ' || SQLERRM);
    -- Decide if you want to rollback just this block or let the main exception handler catch it
END;
/
DECLARE
  v_new_child_instance_id productInstance.Instance_ID%TYPE;
  v_child_category        product.Category%TYPE := 'Commodity'; -- Pass category
  v_max_existing_batch_lot NUMBER;
  v_next_batch_lot_num   NUMBER;
  v_serial_number        serialized.Serial_Number%TYPE;
  v_batch_number         serialized.Batch_Number%TYPE; -- Shared batch for serialized children of *this* parent
  v_expiration_date      commodity.Expiration_Date%TYPE;
  v_quantity_to_create   commodity.Quantity%TYPE; -- Quantity for the new child instance

BEGIN
  -- Step 1: Create the new child productInstance
  INSERT INTO productInstance (Product_ID, Date_Manufactured, Is_Recalled)
  VALUES (144.0, TIMESTAMP '2024-10-09 00:11:20', 0)
  RETURNING Instance_ID INTO v_new_child_instance_id;

  -- Step 2: Create the corresponding subtype record
  IF v_child_category = 'Commodity' THEN
    -- Find max existing Batch_Number for this specific Child_PID
    SELECT NVL(MAX(c.Batch_Number), 0) INTO v_max_existing_batch_lot
    FROM commodity c JOIN productInstance pi ON c.Instance_ID = pi.Instance_ID
    WHERE pi.Product_ID = 144.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next batch

    v_expiration_date := TIMESTAMP '2024-10-09 00:11:20' + INTERVAL '717' DAY;
    v_quantity_to_create := ROUND(1.9, 1);

    INSERT INTO commodity (Instance_ID, Batch_Number, Expiration_Date, Quantity)
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Packaged' THEN
    -- Find max existing Lot_Number for this specific Child_PID
    SELECT NVL(MAX(p.Lot_Number), 0) INTO v_max_existing_batch_lot
    FROM packaged p JOIN productInstance pi ON p.Instance_ID = pi.Instance_ID -- Assuming 'packaged' table name
    WHERE pi.Product_ID = 144.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next lot

    v_expiration_date := TIMESTAMP '2024-10-09 00:11:20' + INTERVAL '151' DAY;
    v_quantity_to_create := ROUND(1.9, 1);

    INSERT INTO packaged (Instance_ID, Lot_Number, Expiration_Date, Quantity) -- Assuming 'packaged' table name
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Serialized' THEN
    -- Assign a unique serial number
    -- Using Instance ID guarantees uniqueness within this context
    v_serial_number := 'SN-' || TO_CHAR(144.0) || '-' || TO_CHAR(v_new_child_instance_id) || '-' || SUBSTR(SYS_GUID(),1,8);
    -- Assign a batch number - use Product_ID of the *parent* instance as the batch for simplicity? Or a sequence?
    -- Let's use the Parent_IID itself as a simple batch identifier for this run.
    v_batch_number := 601.0; -- All children created FOR this parent get same batch number

    INSERT INTO serialized (Instance_ID, Serial_Number, Batch_Number)
    VALUES (v_new_child_instance_id, v_serial_number, v_batch_number);

    -- Quantity for usesComponent link for serialized is typically 1
    v_quantity_to_create := 1;

  END IF;

  -- Step 3: Create the usesComponent link
  -- Quantity_Used is the Quantity_Needed from needsComponent (which matches child quantity for non-serialized)
  IF v_child_category IN ('Commodity', 'Packaged', 'Serialized') THEN -- Only insert if subtype was handled
      INSERT INTO usesComponent (Parent_IID, Child_IID, Quantity_Used)
      VALUES (601.0, v_new_child_instance_id, ROUND(1.9, 1)); -- Use rounded quantity needed
  END IF;

EXCEPTION
  WHEN OTHERS THEN
    DBMS_OUTPUT.PUT_LINE('Error processing Parent_IID=' || 601.0 || ', Child_PID=' || 144.0 || ': ' || SQLERRM);
    -- Decide if you want to rollback just this block or let the main exception handler catch it
END;
/
DECLARE
  v_new_child_instance_id productInstance.Instance_ID%TYPE;
  v_child_category        product.Category%TYPE := 'Commodity'; -- Pass category
  v_max_existing_batch_lot NUMBER;
  v_next_batch_lot_num   NUMBER;
  v_serial_number        serialized.Serial_Number%TYPE;
  v_batch_number         serialized.Batch_Number%TYPE; -- Shared batch for serialized children of *this* parent
  v_expiration_date      commodity.Expiration_Date%TYPE;
  v_quantity_to_create   commodity.Quantity%TYPE; -- Quantity for the new child instance

BEGIN
  -- Step 1: Create the new child productInstance
  INSERT INTO productInstance (Product_ID, Date_Manufactured, Is_Recalled)
  VALUES (167.0, TIMESTAMP '2024-08-10 02:03:21', 0)
  RETURNING Instance_ID INTO v_new_child_instance_id;

  -- Step 2: Create the corresponding subtype record
  IF v_child_category = 'Commodity' THEN
    -- Find max existing Batch_Number for this specific Child_PID
    SELECT NVL(MAX(c.Batch_Number), 0) INTO v_max_existing_batch_lot
    FROM commodity c JOIN productInstance pi ON c.Instance_ID = pi.Instance_ID
    WHERE pi.Product_ID = 167.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next batch

    v_expiration_date := TIMESTAMP '2024-08-10 02:03:21' + INTERVAL '730' DAY;
    v_quantity_to_create := ROUND(0.2, 1);

    INSERT INTO commodity (Instance_ID, Batch_Number, Expiration_Date, Quantity)
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Packaged' THEN
    -- Find max existing Lot_Number for this specific Child_PID
    SELECT NVL(MAX(p.Lot_Number), 0) INTO v_max_existing_batch_lot
    FROM packaged p JOIN productInstance pi ON p.Instance_ID = pi.Instance_ID -- Assuming 'packaged' table name
    WHERE pi.Product_ID = 167.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next lot

    v_expiration_date := TIMESTAMP '2024-08-10 02:03:21' + INTERVAL '315' DAY;
    v_quantity_to_create := ROUND(0.2, 1);

    INSERT INTO packaged (Instance_ID, Lot_Number, Expiration_Date, Quantity) -- Assuming 'packaged' table name
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Serialized' THEN
    -- Assign a unique serial number
    -- Using Instance ID guarantees uniqueness within this context
    v_serial_number := 'SN-' || TO_CHAR(167.0) || '-' || TO_CHAR(v_new_child_instance_id) || '-' || SUBSTR(SYS_GUID(),1,8);
    -- Assign a batch number - use Product_ID of the *parent* instance as the batch for simplicity? Or a sequence?
    -- Let's use the Parent_IID itself as a simple batch identifier for this run.
    v_batch_number := 601.0; -- All children created FOR this parent get same batch number

    INSERT INTO serialized (Instance_ID, Serial_Number, Batch_Number)
    VALUES (v_new_child_instance_id, v_serial_number, v_batch_number);

    -- Quantity for usesComponent link for serialized is typically 1
    v_quantity_to_create := 1;

  END IF;

  -- Step 3: Create the usesComponent link
  -- Quantity_Used is the Quantity_Needed from needsComponent (which matches child quantity for non-serialized)
  IF v_child_category IN ('Commodity', 'Packaged', 'Serialized') THEN -- Only insert if subtype was handled
      INSERT INTO usesComponent (Parent_IID, Child_IID, Quantity_Used)
      VALUES (601.0, v_new_child_instance_id, ROUND(0.2, 1)); -- Use rounded quantity needed
  END IF;

EXCEPTION
  WHEN OTHERS THEN
    DBMS_OUTPUT.PUT_LINE('Error processing Parent_IID=' || 601.0 || ', Child_PID=' || 167.0 || ': ' || SQLERRM);
    -- Decide if you want to rollback just this block or let the main exception handler catch it
END;
/
DECLARE
  v_new_child_instance_id productInstance.Instance_ID%TYPE;
  v_child_category        product.Category%TYPE := 'Commodity'; -- Pass category
  v_max_existing_batch_lot NUMBER;
  v_next_batch_lot_num   NUMBER;
  v_serial_number        serialized.Serial_Number%TYPE;
  v_batch_number         serialized.Batch_Number%TYPE; -- Shared batch for serialized children of *this* parent
  v_expiration_date      commodity.Expiration_Date%TYPE;
  v_quantity_to_create   commodity.Quantity%TYPE; -- Quantity for the new child instance

BEGIN
  -- Step 1: Create the new child productInstance
  INSERT INTO productInstance (Product_ID, Date_Manufactured, Is_Recalled)
  VALUES (231.0, TIMESTAMP '2024-07-07 13:45:03', 0)
  RETURNING Instance_ID INTO v_new_child_instance_id;

  -- Step 2: Create the corresponding subtype record
  IF v_child_category = 'Commodity' THEN
    -- Find max existing Batch_Number for this specific Child_PID
    SELECT NVL(MAX(c.Batch_Number), 0) INTO v_max_existing_batch_lot
    FROM commodity c JOIN productInstance pi ON c.Instance_ID = pi.Instance_ID
    WHERE pi.Product_ID = 231.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next batch

    v_expiration_date := TIMESTAMP '2024-07-07 13:45:03' + INTERVAL '521' DAY;
    v_quantity_to_create := ROUND(0.2, 1);

    INSERT INTO commodity (Instance_ID, Batch_Number, Expiration_Date, Quantity)
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Packaged' THEN
    -- Find max existing Lot_Number for this specific Child_PID
    SELECT NVL(MAX(p.Lot_Number), 0) INTO v_max_existing_batch_lot
    FROM packaged p JOIN productInstance pi ON p.Instance_ID = pi.Instance_ID -- Assuming 'packaged' table name
    WHERE pi.Product_ID = 231.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next lot

    v_expiration_date := TIMESTAMP '2024-07-07 13:45:03' + INTERVAL '78' DAY;
    v_quantity_to_create := ROUND(0.2, 1);

    INSERT INTO packaged (Instance_ID, Lot_Number, Expiration_Date, Quantity) -- Assuming 'packaged' table name
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Serialized' THEN
    -- Assign a unique serial number
    -- Using Instance ID guarantees uniqueness within this context
    v_serial_number := 'SN-' || TO_CHAR(231.0) || '-' || TO_CHAR(v_new_child_instance_id) || '-' || SUBSTR(SYS_GUID(),1,8);
    -- Assign a batch number - use Product_ID of the *parent* instance as the batch for simplicity? Or a sequence?
    -- Let's use the Parent_IID itself as a simple batch identifier for this run.
    v_batch_number := 602.0; -- All children created FOR this parent get same batch number

    INSERT INTO serialized (Instance_ID, Serial_Number, Batch_Number)
    VALUES (v_new_child_instance_id, v_serial_number, v_batch_number);

    -- Quantity for usesComponent link for serialized is typically 1
    v_quantity_to_create := 1;

  END IF;

  -- Step 3: Create the usesComponent link
  -- Quantity_Used is the Quantity_Needed from needsComponent (which matches child quantity for non-serialized)
  IF v_child_category IN ('Commodity', 'Packaged', 'Serialized') THEN -- Only insert if subtype was handled
      INSERT INTO usesComponent (Parent_IID, Child_IID, Quantity_Used)
      VALUES (602.0, v_new_child_instance_id, ROUND(0.2, 1)); -- Use rounded quantity needed
  END IF;

EXCEPTION
  WHEN OTHERS THEN
    DBMS_OUTPUT.PUT_LINE('Error processing Parent_IID=' || 602.0 || ', Child_PID=' || 231.0 || ': ' || SQLERRM);
    -- Decide if you want to rollback just this block or let the main exception handler catch it
END;
/
DECLARE
  v_new_child_instance_id productInstance.Instance_ID%TYPE;
  v_child_category        product.Category%TYPE := 'Commodity'; -- Pass category
  v_max_existing_batch_lot NUMBER;
  v_next_batch_lot_num   NUMBER;
  v_serial_number        serialized.Serial_Number%TYPE;
  v_batch_number         serialized.Batch_Number%TYPE; -- Shared batch for serialized children of *this* parent
  v_expiration_date      commodity.Expiration_Date%TYPE;
  v_quantity_to_create   commodity.Quantity%TYPE; -- Quantity for the new child instance

BEGIN
  -- Step 1: Create the new child productInstance
  INSERT INTO productInstance (Product_ID, Date_Manufactured, Is_Recalled)
  VALUES (144.0, TIMESTAMP '2025-02-28 10:57:38', 0)
  RETURNING Instance_ID INTO v_new_child_instance_id;

  -- Step 2: Create the corresponding subtype record
  IF v_child_category = 'Commodity' THEN
    -- Find max existing Batch_Number for this specific Child_PID
    SELECT NVL(MAX(c.Batch_Number), 0) INTO v_max_existing_batch_lot
    FROM commodity c JOIN productInstance pi ON c.Instance_ID = pi.Instance_ID
    WHERE pi.Product_ID = 144.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next batch

    v_expiration_date := TIMESTAMP '2025-02-28 10:57:38' + INTERVAL '249' DAY;
    v_quantity_to_create := ROUND(1.9, 1);

    INSERT INTO commodity (Instance_ID, Batch_Number, Expiration_Date, Quantity)
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Packaged' THEN
    -- Find max existing Lot_Number for this specific Child_PID
    SELECT NVL(MAX(p.Lot_Number), 0) INTO v_max_existing_batch_lot
    FROM packaged p JOIN productInstance pi ON p.Instance_ID = pi.Instance_ID -- Assuming 'packaged' table name
    WHERE pi.Product_ID = 144.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next lot

    v_expiration_date := TIMESTAMP '2025-02-28 10:57:38' + INTERVAL '723' DAY;
    v_quantity_to_create := ROUND(1.9, 1);

    INSERT INTO packaged (Instance_ID, Lot_Number, Expiration_Date, Quantity) -- Assuming 'packaged' table name
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Serialized' THEN
    -- Assign a unique serial number
    -- Using Instance ID guarantees uniqueness within this context
    v_serial_number := 'SN-' || TO_CHAR(144.0) || '-' || TO_CHAR(v_new_child_instance_id) || '-' || SUBSTR(SYS_GUID(),1,8);
    -- Assign a batch number - use Product_ID of the *parent* instance as the batch for simplicity? Or a sequence?
    -- Let's use the Parent_IID itself as a simple batch identifier for this run.
    v_batch_number := 602.0; -- All children created FOR this parent get same batch number

    INSERT INTO serialized (Instance_ID, Serial_Number, Batch_Number)
    VALUES (v_new_child_instance_id, v_serial_number, v_batch_number);

    -- Quantity for usesComponent link for serialized is typically 1
    v_quantity_to_create := 1;

  END IF;

  -- Step 3: Create the usesComponent link
  -- Quantity_Used is the Quantity_Needed from needsComponent (which matches child quantity for non-serialized)
  IF v_child_category IN ('Commodity', 'Packaged', 'Serialized') THEN -- Only insert if subtype was handled
      INSERT INTO usesComponent (Parent_IID, Child_IID, Quantity_Used)
      VALUES (602.0, v_new_child_instance_id, ROUND(1.9, 1)); -- Use rounded quantity needed
  END IF;

EXCEPTION
  WHEN OTHERS THEN
    DBMS_OUTPUT.PUT_LINE('Error processing Parent_IID=' || 602.0 || ', Child_PID=' || 144.0 || ': ' || SQLERRM);
    -- Decide if you want to rollback just this block or let the main exception handler catch it
END;
/
DECLARE
  v_new_child_instance_id productInstance.Instance_ID%TYPE;
  v_child_category        product.Category%TYPE := 'Commodity'; -- Pass category
  v_max_existing_batch_lot NUMBER;
  v_next_batch_lot_num   NUMBER;
  v_serial_number        serialized.Serial_Number%TYPE;
  v_batch_number         serialized.Batch_Number%TYPE; -- Shared batch for serialized children of *this* parent
  v_expiration_date      commodity.Expiration_Date%TYPE;
  v_quantity_to_create   commodity.Quantity%TYPE; -- Quantity for the new child instance

BEGIN
  -- Step 1: Create the new child productInstance
  INSERT INTO productInstance (Product_ID, Date_Manufactured, Is_Recalled)
  VALUES (167.0, TIMESTAMP '2025-01-04 06:00:35', 0)
  RETURNING Instance_ID INTO v_new_child_instance_id;

  -- Step 2: Create the corresponding subtype record
  IF v_child_category = 'Commodity' THEN
    -- Find max existing Batch_Number for this specific Child_PID
    SELECT NVL(MAX(c.Batch_Number), 0) INTO v_max_existing_batch_lot
    FROM commodity c JOIN productInstance pi ON c.Instance_ID = pi.Instance_ID
    WHERE pi.Product_ID = 167.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next batch

    v_expiration_date := TIMESTAMP '2025-01-04 06:00:35' + INTERVAL '119' DAY;
    v_quantity_to_create := ROUND(0.2, 1);

    INSERT INTO commodity (Instance_ID, Batch_Number, Expiration_Date, Quantity)
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Packaged' THEN
    -- Find max existing Lot_Number for this specific Child_PID
    SELECT NVL(MAX(p.Lot_Number), 0) INTO v_max_existing_batch_lot
    FROM packaged p JOIN productInstance pi ON p.Instance_ID = pi.Instance_ID -- Assuming 'packaged' table name
    WHERE pi.Product_ID = 167.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next lot

    v_expiration_date := TIMESTAMP '2025-01-04 06:00:35' + INTERVAL '429' DAY;
    v_quantity_to_create := ROUND(0.2, 1);

    INSERT INTO packaged (Instance_ID, Lot_Number, Expiration_Date, Quantity) -- Assuming 'packaged' table name
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Serialized' THEN
    -- Assign a unique serial number
    -- Using Instance ID guarantees uniqueness within this context
    v_serial_number := 'SN-' || TO_CHAR(167.0) || '-' || TO_CHAR(v_new_child_instance_id) || '-' || SUBSTR(SYS_GUID(),1,8);
    -- Assign a batch number - use Product_ID of the *parent* instance as the batch for simplicity? Or a sequence?
    -- Let's use the Parent_IID itself as a simple batch identifier for this run.
    v_batch_number := 602.0; -- All children created FOR this parent get same batch number

    INSERT INTO serialized (Instance_ID, Serial_Number, Batch_Number)
    VALUES (v_new_child_instance_id, v_serial_number, v_batch_number);

    -- Quantity for usesComponent link for serialized is typically 1
    v_quantity_to_create := 1;

  END IF;

  -- Step 3: Create the usesComponent link
  -- Quantity_Used is the Quantity_Needed from needsComponent (which matches child quantity for non-serialized)
  IF v_child_category IN ('Commodity', 'Packaged', 'Serialized') THEN -- Only insert if subtype was handled
      INSERT INTO usesComponent (Parent_IID, Child_IID, Quantity_Used)
      VALUES (602.0, v_new_child_instance_id, ROUND(0.2, 1)); -- Use rounded quantity needed
  END IF;

EXCEPTION
  WHEN OTHERS THEN
    DBMS_OUTPUT.PUT_LINE('Error processing Parent_IID=' || 602.0 || ', Child_PID=' || 167.0 || ': ' || SQLERRM);
    -- Decide if you want to rollback just this block or let the main exception handler catch it
END;
/
DECLARE
  v_new_child_instance_id productInstance.Instance_ID%TYPE;
  v_child_category        product.Category%TYPE := 'Commodity'; -- Pass category
  v_max_existing_batch_lot NUMBER;
  v_next_batch_lot_num   NUMBER;
  v_serial_number        serialized.Serial_Number%TYPE;
  v_batch_number         serialized.Batch_Number%TYPE; -- Shared batch for serialized children of *this* parent
  v_expiration_date      commodity.Expiration_Date%TYPE;
  v_quantity_to_create   commodity.Quantity%TYPE; -- Quantity for the new child instance

BEGIN
  -- Step 1: Create the new child productInstance
  INSERT INTO productInstance (Product_ID, Date_Manufactured, Is_Recalled)
  VALUES (176.0, TIMESTAMP '2024-06-16 02:45:06', 0)
  RETURNING Instance_ID INTO v_new_child_instance_id;

  -- Step 2: Create the corresponding subtype record
  IF v_child_category = 'Commodity' THEN
    -- Find max existing Batch_Number for this specific Child_PID
    SELECT NVL(MAX(c.Batch_Number), 0) INTO v_max_existing_batch_lot
    FROM commodity c JOIN productInstance pi ON c.Instance_ID = pi.Instance_ID
    WHERE pi.Product_ID = 176.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next batch

    v_expiration_date := TIMESTAMP '2024-06-16 02:45:06' + INTERVAL '714' DAY;
    v_quantity_to_create := ROUND(1.4, 1);

    INSERT INTO commodity (Instance_ID, Batch_Number, Expiration_Date, Quantity)
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Packaged' THEN
    -- Find max existing Lot_Number for this specific Child_PID
    SELECT NVL(MAX(p.Lot_Number), 0) INTO v_max_existing_batch_lot
    FROM packaged p JOIN productInstance pi ON p.Instance_ID = pi.Instance_ID -- Assuming 'packaged' table name
    WHERE pi.Product_ID = 176.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next lot

    v_expiration_date := TIMESTAMP '2024-06-16 02:45:06' + INTERVAL '488' DAY;
    v_quantity_to_create := ROUND(1.4, 1);

    INSERT INTO packaged (Instance_ID, Lot_Number, Expiration_Date, Quantity) -- Assuming 'packaged' table name
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Serialized' THEN
    -- Assign a unique serial number
    -- Using Instance ID guarantees uniqueness within this context
    v_serial_number := 'SN-' || TO_CHAR(176.0) || '-' || TO_CHAR(v_new_child_instance_id) || '-' || SUBSTR(SYS_GUID(),1,8);
    -- Assign a batch number - use Product_ID of the *parent* instance as the batch for simplicity? Or a sequence?
    -- Let's use the Parent_IID itself as a simple batch identifier for this run.
    v_batch_number := 626.0; -- All children created FOR this parent get same batch number

    INSERT INTO serialized (Instance_ID, Serial_Number, Batch_Number)
    VALUES (v_new_child_instance_id, v_serial_number, v_batch_number);

    -- Quantity for usesComponent link for serialized is typically 1
    v_quantity_to_create := 1;

  END IF;

  -- Step 3: Create the usesComponent link
  -- Quantity_Used is the Quantity_Needed from needsComponent (which matches child quantity for non-serialized)
  IF v_child_category IN ('Commodity', 'Packaged', 'Serialized') THEN -- Only insert if subtype was handled
      INSERT INTO usesComponent (Parent_IID, Child_IID, Quantity_Used)
      VALUES (626.0, v_new_child_instance_id, ROUND(1.4, 1)); -- Use rounded quantity needed
  END IF;

EXCEPTION
  WHEN OTHERS THEN
    DBMS_OUTPUT.PUT_LINE('Error processing Parent_IID=' || 626.0 || ', Child_PID=' || 176.0 || ': ' || SQLERRM);
    -- Decide if you want to rollback just this block or let the main exception handler catch it
END;
/
DECLARE
  v_new_child_instance_id productInstance.Instance_ID%TYPE;
  v_child_category        product.Category%TYPE := 'Commodity'; -- Pass category
  v_max_existing_batch_lot NUMBER;
  v_next_batch_lot_num   NUMBER;
  v_serial_number        serialized.Serial_Number%TYPE;
  v_batch_number         serialized.Batch_Number%TYPE; -- Shared batch for serialized children of *this* parent
  v_expiration_date      commodity.Expiration_Date%TYPE;
  v_quantity_to_create   commodity.Quantity%TYPE; -- Quantity for the new child instance

BEGIN
  -- Step 1: Create the new child productInstance
  INSERT INTO productInstance (Product_ID, Date_Manufactured, Is_Recalled)
  VALUES (215.0, TIMESTAMP '2024-08-21 07:32:57', 0)
  RETURNING Instance_ID INTO v_new_child_instance_id;

  -- Step 2: Create the corresponding subtype record
  IF v_child_category = 'Commodity' THEN
    -- Find max existing Batch_Number for this specific Child_PID
    SELECT NVL(MAX(c.Batch_Number), 0) INTO v_max_existing_batch_lot
    FROM commodity c JOIN productInstance pi ON c.Instance_ID = pi.Instance_ID
    WHERE pi.Product_ID = 215.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next batch

    v_expiration_date := TIMESTAMP '2024-08-21 07:32:57' + INTERVAL '728' DAY;
    v_quantity_to_create := ROUND(0.9, 1);

    INSERT INTO commodity (Instance_ID, Batch_Number, Expiration_Date, Quantity)
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Packaged' THEN
    -- Find max existing Lot_Number for this specific Child_PID
    SELECT NVL(MAX(p.Lot_Number), 0) INTO v_max_existing_batch_lot
    FROM packaged p JOIN productInstance pi ON p.Instance_ID = pi.Instance_ID -- Assuming 'packaged' table name
    WHERE pi.Product_ID = 215.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next lot

    v_expiration_date := TIMESTAMP '2024-08-21 07:32:57' + INTERVAL '550' DAY;
    v_quantity_to_create := ROUND(0.9, 1);

    INSERT INTO packaged (Instance_ID, Lot_Number, Expiration_Date, Quantity) -- Assuming 'packaged' table name
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Serialized' THEN
    -- Assign a unique serial number
    -- Using Instance ID guarantees uniqueness within this context
    v_serial_number := 'SN-' || TO_CHAR(215.0) || '-' || TO_CHAR(v_new_child_instance_id) || '-' || SUBSTR(SYS_GUID(),1,8);
    -- Assign a batch number - use Product_ID of the *parent* instance as the batch for simplicity? Or a sequence?
    -- Let's use the Parent_IID itself as a simple batch identifier for this run.
    v_batch_number := 626.0; -- All children created FOR this parent get same batch number

    INSERT INTO serialized (Instance_ID, Serial_Number, Batch_Number)
    VALUES (v_new_child_instance_id, v_serial_number, v_batch_number);

    -- Quantity for usesComponent link for serialized is typically 1
    v_quantity_to_create := 1;

  END IF;

  -- Step 3: Create the usesComponent link
  -- Quantity_Used is the Quantity_Needed from needsComponent (which matches child quantity for non-serialized)
  IF v_child_category IN ('Commodity', 'Packaged', 'Serialized') THEN -- Only insert if subtype was handled
      INSERT INTO usesComponent (Parent_IID, Child_IID, Quantity_Used)
      VALUES (626.0, v_new_child_instance_id, ROUND(0.9, 1)); -- Use rounded quantity needed
  END IF;

EXCEPTION
  WHEN OTHERS THEN
    DBMS_OUTPUT.PUT_LINE('Error processing Parent_IID=' || 626.0 || ', Child_PID=' || 215.0 || ': ' || SQLERRM);
    -- Decide if you want to rollback just this block or let the main exception handler catch it
END;
/
DECLARE
  v_new_child_instance_id productInstance.Instance_ID%TYPE;
  v_child_category        product.Category%TYPE := 'Commodity'; -- Pass category
  v_max_existing_batch_lot NUMBER;
  v_next_batch_lot_num   NUMBER;
  v_serial_number        serialized.Serial_Number%TYPE;
  v_batch_number         serialized.Batch_Number%TYPE; -- Shared batch for serialized children of *this* parent
  v_expiration_date      commodity.Expiration_Date%TYPE;
  v_quantity_to_create   commodity.Quantity%TYPE; -- Quantity for the new child instance

BEGIN
  -- Step 1: Create the new child productInstance
  INSERT INTO productInstance (Product_ID, Date_Manufactured, Is_Recalled)
  VALUES (161.0, TIMESTAMP '2024-11-08 10:17:51', 0)
  RETURNING Instance_ID INTO v_new_child_instance_id;

  -- Step 2: Create the corresponding subtype record
  IF v_child_category = 'Commodity' THEN
    -- Find max existing Batch_Number for this specific Child_PID
    SELECT NVL(MAX(c.Batch_Number), 0) INTO v_max_existing_batch_lot
    FROM commodity c JOIN productInstance pi ON c.Instance_ID = pi.Instance_ID
    WHERE pi.Product_ID = 161.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next batch

    v_expiration_date := TIMESTAMP '2024-11-08 10:17:51' + INTERVAL '432' DAY;
    v_quantity_to_create := ROUND(1.5, 1);

    INSERT INTO commodity (Instance_ID, Batch_Number, Expiration_Date, Quantity)
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Packaged' THEN
    -- Find max existing Lot_Number for this specific Child_PID
    SELECT NVL(MAX(p.Lot_Number), 0) INTO v_max_existing_batch_lot
    FROM packaged p JOIN productInstance pi ON p.Instance_ID = pi.Instance_ID -- Assuming 'packaged' table name
    WHERE pi.Product_ID = 161.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next lot

    v_expiration_date := TIMESTAMP '2024-11-08 10:17:51' + INTERVAL '148' DAY;
    v_quantity_to_create := ROUND(1.5, 1);

    INSERT INTO packaged (Instance_ID, Lot_Number, Expiration_Date, Quantity) -- Assuming 'packaged' table name
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Serialized' THEN
    -- Assign a unique serial number
    -- Using Instance ID guarantees uniqueness within this context
    v_serial_number := 'SN-' || TO_CHAR(161.0) || '-' || TO_CHAR(v_new_child_instance_id) || '-' || SUBSTR(SYS_GUID(),1,8);
    -- Assign a batch number - use Product_ID of the *parent* instance as the batch for simplicity? Or a sequence?
    -- Let's use the Parent_IID itself as a simple batch identifier for this run.
    v_batch_number := 626.0; -- All children created FOR this parent get same batch number

    INSERT INTO serialized (Instance_ID, Serial_Number, Batch_Number)
    VALUES (v_new_child_instance_id, v_serial_number, v_batch_number);

    -- Quantity for usesComponent link for serialized is typically 1
    v_quantity_to_create := 1;

  END IF;

  -- Step 3: Create the usesComponent link
  -- Quantity_Used is the Quantity_Needed from needsComponent (which matches child quantity for non-serialized)
  IF v_child_category IN ('Commodity', 'Packaged', 'Serialized') THEN -- Only insert if subtype was handled
      INSERT INTO usesComponent (Parent_IID, Child_IID, Quantity_Used)
      VALUES (626.0, v_new_child_instance_id, ROUND(1.5, 1)); -- Use rounded quantity needed
  END IF;

EXCEPTION
  WHEN OTHERS THEN
    DBMS_OUTPUT.PUT_LINE('Error processing Parent_IID=' || 626.0 || ', Child_PID=' || 161.0 || ': ' || SQLERRM);
    -- Decide if you want to rollback just this block or let the main exception handler catch it
END;
/
DECLARE
  v_new_child_instance_id productInstance.Instance_ID%TYPE;
  v_child_category        product.Category%TYPE := 'Commodity'; -- Pass category
  v_max_existing_batch_lot NUMBER;
  v_next_batch_lot_num   NUMBER;
  v_serial_number        serialized.Serial_Number%TYPE;
  v_batch_number         serialized.Batch_Number%TYPE; -- Shared batch for serialized children of *this* parent
  v_expiration_date      commodity.Expiration_Date%TYPE;
  v_quantity_to_create   commodity.Quantity%TYPE; -- Quantity for the new child instance

BEGIN
  -- Step 1: Create the new child productInstance
  INSERT INTO productInstance (Product_ID, Date_Manufactured, Is_Recalled)
  VALUES (176.0, TIMESTAMP '2024-12-20 10:19:39', 0)
  RETURNING Instance_ID INTO v_new_child_instance_id;

  -- Step 2: Create the corresponding subtype record
  IF v_child_category = 'Commodity' THEN
    -- Find max existing Batch_Number for this specific Child_PID
    SELECT NVL(MAX(c.Batch_Number), 0) INTO v_max_existing_batch_lot
    FROM commodity c JOIN productInstance pi ON c.Instance_ID = pi.Instance_ID
    WHERE pi.Product_ID = 176.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next batch

    v_expiration_date := TIMESTAMP '2024-12-20 10:19:39' + INTERVAL '520' DAY;
    v_quantity_to_create := ROUND(1.4, 1);

    INSERT INTO commodity (Instance_ID, Batch_Number, Expiration_Date, Quantity)
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Packaged' THEN
    -- Find max existing Lot_Number for this specific Child_PID
    SELECT NVL(MAX(p.Lot_Number), 0) INTO v_max_existing_batch_lot
    FROM packaged p JOIN productInstance pi ON p.Instance_ID = pi.Instance_ID -- Assuming 'packaged' table name
    WHERE pi.Product_ID = 176.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next lot

    v_expiration_date := TIMESTAMP '2024-12-20 10:19:39' + INTERVAL '138' DAY;
    v_quantity_to_create := ROUND(1.4, 1);

    INSERT INTO packaged (Instance_ID, Lot_Number, Expiration_Date, Quantity) -- Assuming 'packaged' table name
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Serialized' THEN
    -- Assign a unique serial number
    -- Using Instance ID guarantees uniqueness within this context
    v_serial_number := 'SN-' || TO_CHAR(176.0) || '-' || TO_CHAR(v_new_child_instance_id) || '-' || SUBSTR(SYS_GUID(),1,8);
    -- Assign a batch number - use Product_ID of the *parent* instance as the batch for simplicity? Or a sequence?
    -- Let's use the Parent_IID itself as a simple batch identifier for this run.
    v_batch_number := 627.0; -- All children created FOR this parent get same batch number

    INSERT INTO serialized (Instance_ID, Serial_Number, Batch_Number)
    VALUES (v_new_child_instance_id, v_serial_number, v_batch_number);

    -- Quantity for usesComponent link for serialized is typically 1
    v_quantity_to_create := 1;

  END IF;

  -- Step 3: Create the usesComponent link
  -- Quantity_Used is the Quantity_Needed from needsComponent (which matches child quantity for non-serialized)
  IF v_child_category IN ('Commodity', 'Packaged', 'Serialized') THEN -- Only insert if subtype was handled
      INSERT INTO usesComponent (Parent_IID, Child_IID, Quantity_Used)
      VALUES (627.0, v_new_child_instance_id, ROUND(1.4, 1)); -- Use rounded quantity needed
  END IF;

EXCEPTION
  WHEN OTHERS THEN
    DBMS_OUTPUT.PUT_LINE('Error processing Parent_IID=' || 627.0 || ', Child_PID=' || 176.0 || ': ' || SQLERRM);
    -- Decide if you want to rollback just this block or let the main exception handler catch it
END;
/
DECLARE
  v_new_child_instance_id productInstance.Instance_ID%TYPE;
  v_child_category        product.Category%TYPE := 'Commodity'; -- Pass category
  v_max_existing_batch_lot NUMBER;
  v_next_batch_lot_num   NUMBER;
  v_serial_number        serialized.Serial_Number%TYPE;
  v_batch_number         serialized.Batch_Number%TYPE; -- Shared batch for serialized children of *this* parent
  v_expiration_date      commodity.Expiration_Date%TYPE;
  v_quantity_to_create   commodity.Quantity%TYPE; -- Quantity for the new child instance

BEGIN
  -- Step 1: Create the new child productInstance
  INSERT INTO productInstance (Product_ID, Date_Manufactured, Is_Recalled)
  VALUES (215.0, TIMESTAMP '2024-06-25 22:59:10', 0)
  RETURNING Instance_ID INTO v_new_child_instance_id;

  -- Step 2: Create the corresponding subtype record
  IF v_child_category = 'Commodity' THEN
    -- Find max existing Batch_Number for this specific Child_PID
    SELECT NVL(MAX(c.Batch_Number), 0) INTO v_max_existing_batch_lot
    FROM commodity c JOIN productInstance pi ON c.Instance_ID = pi.Instance_ID
    WHERE pi.Product_ID = 215.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next batch

    v_expiration_date := TIMESTAMP '2024-06-25 22:59:10' + INTERVAL '425' DAY;
    v_quantity_to_create := ROUND(0.9, 1);

    INSERT INTO commodity (Instance_ID, Batch_Number, Expiration_Date, Quantity)
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Packaged' THEN
    -- Find max existing Lot_Number for this specific Child_PID
    SELECT NVL(MAX(p.Lot_Number), 0) INTO v_max_existing_batch_lot
    FROM packaged p JOIN productInstance pi ON p.Instance_ID = pi.Instance_ID -- Assuming 'packaged' table name
    WHERE pi.Product_ID = 215.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next lot

    v_expiration_date := TIMESTAMP '2024-06-25 22:59:10' + INTERVAL '658' DAY;
    v_quantity_to_create := ROUND(0.9, 1);

    INSERT INTO packaged (Instance_ID, Lot_Number, Expiration_Date, Quantity) -- Assuming 'packaged' table name
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Serialized' THEN
    -- Assign a unique serial number
    -- Using Instance ID guarantees uniqueness within this context
    v_serial_number := 'SN-' || TO_CHAR(215.0) || '-' || TO_CHAR(v_new_child_instance_id) || '-' || SUBSTR(SYS_GUID(),1,8);
    -- Assign a batch number - use Product_ID of the *parent* instance as the batch for simplicity? Or a sequence?
    -- Let's use the Parent_IID itself as a simple batch identifier for this run.
    v_batch_number := 627.0; -- All children created FOR this parent get same batch number

    INSERT INTO serialized (Instance_ID, Serial_Number, Batch_Number)
    VALUES (v_new_child_instance_id, v_serial_number, v_batch_number);

    -- Quantity for usesComponent link for serialized is typically 1
    v_quantity_to_create := 1;

  END IF;

  -- Step 3: Create the usesComponent link
  -- Quantity_Used is the Quantity_Needed from needsComponent (which matches child quantity for non-serialized)
  IF v_child_category IN ('Commodity', 'Packaged', 'Serialized') THEN -- Only insert if subtype was handled
      INSERT INTO usesComponent (Parent_IID, Child_IID, Quantity_Used)
      VALUES (627.0, v_new_child_instance_id, ROUND(0.9, 1)); -- Use rounded quantity needed
  END IF;

EXCEPTION
  WHEN OTHERS THEN
    DBMS_OUTPUT.PUT_LINE('Error processing Parent_IID=' || 627.0 || ', Child_PID=' || 215.0 || ': ' || SQLERRM);
    -- Decide if you want to rollback just this block or let the main exception handler catch it
END;
/
DECLARE
  v_new_child_instance_id productInstance.Instance_ID%TYPE;
  v_child_category        product.Category%TYPE := 'Commodity'; -- Pass category
  v_max_existing_batch_lot NUMBER;
  v_next_batch_lot_num   NUMBER;
  v_serial_number        serialized.Serial_Number%TYPE;
  v_batch_number         serialized.Batch_Number%TYPE; -- Shared batch for serialized children of *this* parent
  v_expiration_date      commodity.Expiration_Date%TYPE;
  v_quantity_to_create   commodity.Quantity%TYPE; -- Quantity for the new child instance

BEGIN
  -- Step 1: Create the new child productInstance
  INSERT INTO productInstance (Product_ID, Date_Manufactured, Is_Recalled)
  VALUES (161.0, TIMESTAMP '2025-04-15 15:48:07', 0)
  RETURNING Instance_ID INTO v_new_child_instance_id;

  -- Step 2: Create the corresponding subtype record
  IF v_child_category = 'Commodity' THEN
    -- Find max existing Batch_Number for this specific Child_PID
    SELECT NVL(MAX(c.Batch_Number), 0) INTO v_max_existing_batch_lot
    FROM commodity c JOIN productInstance pi ON c.Instance_ID = pi.Instance_ID
    WHERE pi.Product_ID = 161.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next batch

    v_expiration_date := TIMESTAMP '2025-04-15 15:48:07' + INTERVAL '236' DAY;
    v_quantity_to_create := ROUND(1.5, 1);

    INSERT INTO commodity (Instance_ID, Batch_Number, Expiration_Date, Quantity)
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Packaged' THEN
    -- Find max existing Lot_Number for this specific Child_PID
    SELECT NVL(MAX(p.Lot_Number), 0) INTO v_max_existing_batch_lot
    FROM packaged p JOIN productInstance pi ON p.Instance_ID = pi.Instance_ID -- Assuming 'packaged' table name
    WHERE pi.Product_ID = 161.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next lot

    v_expiration_date := TIMESTAMP '2025-04-15 15:48:07' + INTERVAL '201' DAY;
    v_quantity_to_create := ROUND(1.5, 1);

    INSERT INTO packaged (Instance_ID, Lot_Number, Expiration_Date, Quantity) -- Assuming 'packaged' table name
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Serialized' THEN
    -- Assign a unique serial number
    -- Using Instance ID guarantees uniqueness within this context
    v_serial_number := 'SN-' || TO_CHAR(161.0) || '-' || TO_CHAR(v_new_child_instance_id) || '-' || SUBSTR(SYS_GUID(),1,8);
    -- Assign a batch number - use Product_ID of the *parent* instance as the batch for simplicity? Or a sequence?
    -- Let's use the Parent_IID itself as a simple batch identifier for this run.
    v_batch_number := 627.0; -- All children created FOR this parent get same batch number

    INSERT INTO serialized (Instance_ID, Serial_Number, Batch_Number)
    VALUES (v_new_child_instance_id, v_serial_number, v_batch_number);

    -- Quantity for usesComponent link for serialized is typically 1
    v_quantity_to_create := 1;

  END IF;

  -- Step 3: Create the usesComponent link
  -- Quantity_Used is the Quantity_Needed from needsComponent (which matches child quantity for non-serialized)
  IF v_child_category IN ('Commodity', 'Packaged', 'Serialized') THEN -- Only insert if subtype was handled
      INSERT INTO usesComponent (Parent_IID, Child_IID, Quantity_Used)
      VALUES (627.0, v_new_child_instance_id, ROUND(1.5, 1)); -- Use rounded quantity needed
  END IF;

EXCEPTION
  WHEN OTHERS THEN
    DBMS_OUTPUT.PUT_LINE('Error processing Parent_IID=' || 627.0 || ', Child_PID=' || 161.0 || ': ' || SQLERRM);
    -- Decide if you want to rollback just this block or let the main exception handler catch it
END;
/
DECLARE
  v_new_child_instance_id productInstance.Instance_ID%TYPE;
  v_child_category        product.Category%TYPE := 'Commodity'; -- Pass category
  v_max_existing_batch_lot NUMBER;
  v_next_batch_lot_num   NUMBER;
  v_serial_number        serialized.Serial_Number%TYPE;
  v_batch_number         serialized.Batch_Number%TYPE; -- Shared batch for serialized children of *this* parent
  v_expiration_date      commodity.Expiration_Date%TYPE;
  v_quantity_to_create   commodity.Quantity%TYPE; -- Quantity for the new child instance

BEGIN
  -- Step 1: Create the new child productInstance
  INSERT INTO productInstance (Product_ID, Date_Manufactured, Is_Recalled)
  VALUES (247.0, TIMESTAMP '2024-11-17 06:38:03', 0)
  RETURNING Instance_ID INTO v_new_child_instance_id;

  -- Step 2: Create the corresponding subtype record
  IF v_child_category = 'Commodity' THEN
    -- Find max existing Batch_Number for this specific Child_PID
    SELECT NVL(MAX(c.Batch_Number), 0) INTO v_max_existing_batch_lot
    FROM commodity c JOIN productInstance pi ON c.Instance_ID = pi.Instance_ID
    WHERE pi.Product_ID = 247.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next batch

    v_expiration_date := TIMESTAMP '2024-11-17 06:38:03' + INTERVAL '293' DAY;
    v_quantity_to_create := ROUND(1.9, 1);

    INSERT INTO commodity (Instance_ID, Batch_Number, Expiration_Date, Quantity)
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Packaged' THEN
    -- Find max existing Lot_Number for this specific Child_PID
    SELECT NVL(MAX(p.Lot_Number), 0) INTO v_max_existing_batch_lot
    FROM packaged p JOIN productInstance pi ON p.Instance_ID = pi.Instance_ID -- Assuming 'packaged' table name
    WHERE pi.Product_ID = 247.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next lot

    v_expiration_date := TIMESTAMP '2024-11-17 06:38:03' + INTERVAL '456' DAY;
    v_quantity_to_create := ROUND(1.9, 1);

    INSERT INTO packaged (Instance_ID, Lot_Number, Expiration_Date, Quantity) -- Assuming 'packaged' table name
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Serialized' THEN
    -- Assign a unique serial number
    -- Using Instance ID guarantees uniqueness within this context
    v_serial_number := 'SN-' || TO_CHAR(247.0) || '-' || TO_CHAR(v_new_child_instance_id) || '-' || SUBSTR(SYS_GUID(),1,8);
    -- Assign a batch number - use Product_ID of the *parent* instance as the batch for simplicity? Or a sequence?
    -- Let's use the Parent_IID itself as a simple batch identifier for this run.
    v_batch_number := 633.0; -- All children created FOR this parent get same batch number

    INSERT INTO serialized (Instance_ID, Serial_Number, Batch_Number)
    VALUES (v_new_child_instance_id, v_serial_number, v_batch_number);

    -- Quantity for usesComponent link for serialized is typically 1
    v_quantity_to_create := 1;

  END IF;

  -- Step 3: Create the usesComponent link
  -- Quantity_Used is the Quantity_Needed from needsComponent (which matches child quantity for non-serialized)
  IF v_child_category IN ('Commodity', 'Packaged', 'Serialized') THEN -- Only insert if subtype was handled
      INSERT INTO usesComponent (Parent_IID, Child_IID, Quantity_Used)
      VALUES (633.0, v_new_child_instance_id, ROUND(1.9, 1)); -- Use rounded quantity needed
  END IF;

EXCEPTION
  WHEN OTHERS THEN
    DBMS_OUTPUT.PUT_LINE('Error processing Parent_IID=' || 633.0 || ', Child_PID=' || 247.0 || ': ' || SQLERRM);
    -- Decide if you want to rollback just this block or let the main exception handler catch it
END;
/
DECLARE
  v_new_child_instance_id productInstance.Instance_ID%TYPE;
  v_child_category        product.Category%TYPE := 'Commodity'; -- Pass category
  v_max_existing_batch_lot NUMBER;
  v_next_batch_lot_num   NUMBER;
  v_serial_number        serialized.Serial_Number%TYPE;
  v_batch_number         serialized.Batch_Number%TYPE; -- Shared batch for serialized children of *this* parent
  v_expiration_date      commodity.Expiration_Date%TYPE;
  v_quantity_to_create   commodity.Quantity%TYPE; -- Quantity for the new child instance

BEGIN
  -- Step 1: Create the new child productInstance
  INSERT INTO productInstance (Product_ID, Date_Manufactured, Is_Recalled)
  VALUES (111.0, TIMESTAMP '2025-02-11 15:52:23', 0)
  RETURNING Instance_ID INTO v_new_child_instance_id;

  -- Step 2: Create the corresponding subtype record
  IF v_child_category = 'Commodity' THEN
    -- Find max existing Batch_Number for this specific Child_PID
    SELECT NVL(MAX(c.Batch_Number), 0) INTO v_max_existing_batch_lot
    FROM commodity c JOIN productInstance pi ON c.Instance_ID = pi.Instance_ID
    WHERE pi.Product_ID = 111.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next batch

    v_expiration_date := TIMESTAMP '2025-02-11 15:52:23' + INTERVAL '579' DAY;
    v_quantity_to_create := ROUND(1.0, 1);

    INSERT INTO commodity (Instance_ID, Batch_Number, Expiration_Date, Quantity)
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Packaged' THEN
    -- Find max existing Lot_Number for this specific Child_PID
    SELECT NVL(MAX(p.Lot_Number), 0) INTO v_max_existing_batch_lot
    FROM packaged p JOIN productInstance pi ON p.Instance_ID = pi.Instance_ID -- Assuming 'packaged' table name
    WHERE pi.Product_ID = 111.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next lot

    v_expiration_date := TIMESTAMP '2025-02-11 15:52:23' + INTERVAL '325' DAY;
    v_quantity_to_create := ROUND(1.0, 1);

    INSERT INTO packaged (Instance_ID, Lot_Number, Expiration_Date, Quantity) -- Assuming 'packaged' table name
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Serialized' THEN
    -- Assign a unique serial number
    -- Using Instance ID guarantees uniqueness within this context
    v_serial_number := 'SN-' || TO_CHAR(111.0) || '-' || TO_CHAR(v_new_child_instance_id) || '-' || SUBSTR(SYS_GUID(),1,8);
    -- Assign a batch number - use Product_ID of the *parent* instance as the batch for simplicity? Or a sequence?
    -- Let's use the Parent_IID itself as a simple batch identifier for this run.
    v_batch_number := 633.0; -- All children created FOR this parent get same batch number

    INSERT INTO serialized (Instance_ID, Serial_Number, Batch_Number)
    VALUES (v_new_child_instance_id, v_serial_number, v_batch_number);

    -- Quantity for usesComponent link for serialized is typically 1
    v_quantity_to_create := 1;

  END IF;

  -- Step 3: Create the usesComponent link
  -- Quantity_Used is the Quantity_Needed from needsComponent (which matches child quantity for non-serialized)
  IF v_child_category IN ('Commodity', 'Packaged', 'Serialized') THEN -- Only insert if subtype was handled
      INSERT INTO usesComponent (Parent_IID, Child_IID, Quantity_Used)
      VALUES (633.0, v_new_child_instance_id, ROUND(1.0, 1)); -- Use rounded quantity needed
  END IF;

EXCEPTION
  WHEN OTHERS THEN
    DBMS_OUTPUT.PUT_LINE('Error processing Parent_IID=' || 633.0 || ', Child_PID=' || 111.0 || ': ' || SQLERRM);
    -- Decide if you want to rollback just this block or let the main exception handler catch it
END;
/
DECLARE
  v_new_child_instance_id productInstance.Instance_ID%TYPE;
  v_child_category        product.Category%TYPE := 'Commodity'; -- Pass category
  v_max_existing_batch_lot NUMBER;
  v_next_batch_lot_num   NUMBER;
  v_serial_number        serialized.Serial_Number%TYPE;
  v_batch_number         serialized.Batch_Number%TYPE; -- Shared batch for serialized children of *this* parent
  v_expiration_date      commodity.Expiration_Date%TYPE;
  v_quantity_to_create   commodity.Quantity%TYPE; -- Quantity for the new child instance

BEGIN
  -- Step 1: Create the new child productInstance
  INSERT INTO productInstance (Product_ID, Date_Manufactured, Is_Recalled)
  VALUES (136.0, TIMESTAMP '2025-04-01 11:59:05', 0)
  RETURNING Instance_ID INTO v_new_child_instance_id;

  -- Step 2: Create the corresponding subtype record
  IF v_child_category = 'Commodity' THEN
    -- Find max existing Batch_Number for this specific Child_PID
    SELECT NVL(MAX(c.Batch_Number), 0) INTO v_max_existing_batch_lot
    FROM commodity c JOIN productInstance pi ON c.Instance_ID = pi.Instance_ID
    WHERE pi.Product_ID = 136.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next batch

    v_expiration_date := TIMESTAMP '2025-04-01 11:59:05' + INTERVAL '534' DAY;
    v_quantity_to_create := ROUND(0.8, 1);

    INSERT INTO commodity (Instance_ID, Batch_Number, Expiration_Date, Quantity)
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Packaged' THEN
    -- Find max existing Lot_Number for this specific Child_PID
    SELECT NVL(MAX(p.Lot_Number), 0) INTO v_max_existing_batch_lot
    FROM packaged p JOIN productInstance pi ON p.Instance_ID = pi.Instance_ID -- Assuming 'packaged' table name
    WHERE pi.Product_ID = 136.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next lot

    v_expiration_date := TIMESTAMP '2025-04-01 11:59:05' + INTERVAL '678' DAY;
    v_quantity_to_create := ROUND(0.8, 1);

    INSERT INTO packaged (Instance_ID, Lot_Number, Expiration_Date, Quantity) -- Assuming 'packaged' table name
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Serialized' THEN
    -- Assign a unique serial number
    -- Using Instance ID guarantees uniqueness within this context
    v_serial_number := 'SN-' || TO_CHAR(136.0) || '-' || TO_CHAR(v_new_child_instance_id) || '-' || SUBSTR(SYS_GUID(),1,8);
    -- Assign a batch number - use Product_ID of the *parent* instance as the batch for simplicity? Or a sequence?
    -- Let's use the Parent_IID itself as a simple batch identifier for this run.
    v_batch_number := 633.0; -- All children created FOR this parent get same batch number

    INSERT INTO serialized (Instance_ID, Serial_Number, Batch_Number)
    VALUES (v_new_child_instance_id, v_serial_number, v_batch_number);

    -- Quantity for usesComponent link for serialized is typically 1
    v_quantity_to_create := 1;

  END IF;

  -- Step 3: Create the usesComponent link
  -- Quantity_Used is the Quantity_Needed from needsComponent (which matches child quantity for non-serialized)
  IF v_child_category IN ('Commodity', 'Packaged', 'Serialized') THEN -- Only insert if subtype was handled
      INSERT INTO usesComponent (Parent_IID, Child_IID, Quantity_Used)
      VALUES (633.0, v_new_child_instance_id, ROUND(0.8, 1)); -- Use rounded quantity needed
  END IF;

EXCEPTION
  WHEN OTHERS THEN
    DBMS_OUTPUT.PUT_LINE('Error processing Parent_IID=' || 633.0 || ', Child_PID=' || 136.0 || ': ' || SQLERRM);
    -- Decide if you want to rollback just this block or let the main exception handler catch it
END;
/
DECLARE
  v_new_child_instance_id productInstance.Instance_ID%TYPE;
  v_child_category        product.Category%TYPE := 'Commodity'; -- Pass category
  v_max_existing_batch_lot NUMBER;
  v_next_batch_lot_num   NUMBER;
  v_serial_number        serialized.Serial_Number%TYPE;
  v_batch_number         serialized.Batch_Number%TYPE; -- Shared batch for serialized children of *this* parent
  v_expiration_date      commodity.Expiration_Date%TYPE;
  v_quantity_to_create   commodity.Quantity%TYPE; -- Quantity for the new child instance

BEGIN
  -- Step 1: Create the new child productInstance
  INSERT INTO productInstance (Product_ID, Date_Manufactured, Is_Recalled)
  VALUES (179.0, TIMESTAMP '2025-04-11 15:00:49', 0)
  RETURNING Instance_ID INTO v_new_child_instance_id;

  -- Step 2: Create the corresponding subtype record
  IF v_child_category = 'Commodity' THEN
    -- Find max existing Batch_Number for this specific Child_PID
    SELECT NVL(MAX(c.Batch_Number), 0) INTO v_max_existing_batch_lot
    FROM commodity c JOIN productInstance pi ON c.Instance_ID = pi.Instance_ID
    WHERE pi.Product_ID = 179.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next batch

    v_expiration_date := TIMESTAMP '2025-04-11 15:00:49' + INTERVAL '587' DAY;
    v_quantity_to_create := ROUND(1.2, 1);

    INSERT INTO commodity (Instance_ID, Batch_Number, Expiration_Date, Quantity)
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Packaged' THEN
    -- Find max existing Lot_Number for this specific Child_PID
    SELECT NVL(MAX(p.Lot_Number), 0) INTO v_max_existing_batch_lot
    FROM packaged p JOIN productInstance pi ON p.Instance_ID = pi.Instance_ID -- Assuming 'packaged' table name
    WHERE pi.Product_ID = 179.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next lot

    v_expiration_date := TIMESTAMP '2025-04-11 15:00:49' + INTERVAL '249' DAY;
    v_quantity_to_create := ROUND(1.2, 1);

    INSERT INTO packaged (Instance_ID, Lot_Number, Expiration_Date, Quantity) -- Assuming 'packaged' table name
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Serialized' THEN
    -- Assign a unique serial number
    -- Using Instance ID guarantees uniqueness within this context
    v_serial_number := 'SN-' || TO_CHAR(179.0) || '-' || TO_CHAR(v_new_child_instance_id) || '-' || SUBSTR(SYS_GUID(),1,8);
    -- Assign a batch number - use Product_ID of the *parent* instance as the batch for simplicity? Or a sequence?
    -- Let's use the Parent_IID itself as a simple batch identifier for this run.
    v_batch_number := 633.0; -- All children created FOR this parent get same batch number

    INSERT INTO serialized (Instance_ID, Serial_Number, Batch_Number)
    VALUES (v_new_child_instance_id, v_serial_number, v_batch_number);

    -- Quantity for usesComponent link for serialized is typically 1
    v_quantity_to_create := 1;

  END IF;

  -- Step 3: Create the usesComponent link
  -- Quantity_Used is the Quantity_Needed from needsComponent (which matches child quantity for non-serialized)
  IF v_child_category IN ('Commodity', 'Packaged', 'Serialized') THEN -- Only insert if subtype was handled
      INSERT INTO usesComponent (Parent_IID, Child_IID, Quantity_Used)
      VALUES (633.0, v_new_child_instance_id, ROUND(1.2, 1)); -- Use rounded quantity needed
  END IF;

EXCEPTION
  WHEN OTHERS THEN
    DBMS_OUTPUT.PUT_LINE('Error processing Parent_IID=' || 633.0 || ', Child_PID=' || 179.0 || ': ' || SQLERRM);
    -- Decide if you want to rollback just this block or let the main exception handler catch it
END;
/
DECLARE
  v_new_child_instance_id productInstance.Instance_ID%TYPE;
  v_child_category        product.Category%TYPE := 'Commodity'; -- Pass category
  v_max_existing_batch_lot NUMBER;
  v_next_batch_lot_num   NUMBER;
  v_serial_number        serialized.Serial_Number%TYPE;
  v_batch_number         serialized.Batch_Number%TYPE; -- Shared batch for serialized children of *this* parent
  v_expiration_date      commodity.Expiration_Date%TYPE;
  v_quantity_to_create   commodity.Quantity%TYPE; -- Quantity for the new child instance

BEGIN
  -- Step 1: Create the new child productInstance
  INSERT INTO productInstance (Product_ID, Date_Manufactured, Is_Recalled)
  VALUES (247.0, TIMESTAMP '2025-03-01 08:17:11', 0)
  RETURNING Instance_ID INTO v_new_child_instance_id;

  -- Step 2: Create the corresponding subtype record
  IF v_child_category = 'Commodity' THEN
    -- Find max existing Batch_Number for this specific Child_PID
    SELECT NVL(MAX(c.Batch_Number), 0) INTO v_max_existing_batch_lot
    FROM commodity c JOIN productInstance pi ON c.Instance_ID = pi.Instance_ID
    WHERE pi.Product_ID = 247.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next batch

    v_expiration_date := TIMESTAMP '2025-03-01 08:17:11' + INTERVAL '668' DAY;
    v_quantity_to_create := ROUND(1.9, 1);

    INSERT INTO commodity (Instance_ID, Batch_Number, Expiration_Date, Quantity)
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Packaged' THEN
    -- Find max existing Lot_Number for this specific Child_PID
    SELECT NVL(MAX(p.Lot_Number), 0) INTO v_max_existing_batch_lot
    FROM packaged p JOIN productInstance pi ON p.Instance_ID = pi.Instance_ID -- Assuming 'packaged' table name
    WHERE pi.Product_ID = 247.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next lot

    v_expiration_date := TIMESTAMP '2025-03-01 08:17:11' + INTERVAL '375' DAY;
    v_quantity_to_create := ROUND(1.9, 1);

    INSERT INTO packaged (Instance_ID, Lot_Number, Expiration_Date, Quantity) -- Assuming 'packaged' table name
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Serialized' THEN
    -- Assign a unique serial number
    -- Using Instance ID guarantees uniqueness within this context
    v_serial_number := 'SN-' || TO_CHAR(247.0) || '-' || TO_CHAR(v_new_child_instance_id) || '-' || SUBSTR(SYS_GUID(),1,8);
    -- Assign a batch number - use Product_ID of the *parent* instance as the batch for simplicity? Or a sequence?
    -- Let's use the Parent_IID itself as a simple batch identifier for this run.
    v_batch_number := 634.0; -- All children created FOR this parent get same batch number

    INSERT INTO serialized (Instance_ID, Serial_Number, Batch_Number)
    VALUES (v_new_child_instance_id, v_serial_number, v_batch_number);

    -- Quantity for usesComponent link for serialized is typically 1
    v_quantity_to_create := 1;

  END IF;

  -- Step 3: Create the usesComponent link
  -- Quantity_Used is the Quantity_Needed from needsComponent (which matches child quantity for non-serialized)
  IF v_child_category IN ('Commodity', 'Packaged', 'Serialized') THEN -- Only insert if subtype was handled
      INSERT INTO usesComponent (Parent_IID, Child_IID, Quantity_Used)
      VALUES (634.0, v_new_child_instance_id, ROUND(1.9, 1)); -- Use rounded quantity needed
  END IF;

EXCEPTION
  WHEN OTHERS THEN
    DBMS_OUTPUT.PUT_LINE('Error processing Parent_IID=' || 634.0 || ', Child_PID=' || 247.0 || ': ' || SQLERRM);
    -- Decide if you want to rollback just this block or let the main exception handler catch it
END;
/
DECLARE
  v_new_child_instance_id productInstance.Instance_ID%TYPE;
  v_child_category        product.Category%TYPE := 'Commodity'; -- Pass category
  v_max_existing_batch_lot NUMBER;
  v_next_batch_lot_num   NUMBER;
  v_serial_number        serialized.Serial_Number%TYPE;
  v_batch_number         serialized.Batch_Number%TYPE; -- Shared batch for serialized children of *this* parent
  v_expiration_date      commodity.Expiration_Date%TYPE;
  v_quantity_to_create   commodity.Quantity%TYPE; -- Quantity for the new child instance

BEGIN
  -- Step 1: Create the new child productInstance
  INSERT INTO productInstance (Product_ID, Date_Manufactured, Is_Recalled)
  VALUES (111.0, TIMESTAMP '2025-03-29 10:30:36', 0)
  RETURNING Instance_ID INTO v_new_child_instance_id;

  -- Step 2: Create the corresponding subtype record
  IF v_child_category = 'Commodity' THEN
    -- Find max existing Batch_Number for this specific Child_PID
    SELECT NVL(MAX(c.Batch_Number), 0) INTO v_max_existing_batch_lot
    FROM commodity c JOIN productInstance pi ON c.Instance_ID = pi.Instance_ID
    WHERE pi.Product_ID = 111.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next batch

    v_expiration_date := TIMESTAMP '2025-03-29 10:30:36' + INTERVAL '527' DAY;
    v_quantity_to_create := ROUND(1.0, 1);

    INSERT INTO commodity (Instance_ID, Batch_Number, Expiration_Date, Quantity)
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Packaged' THEN
    -- Find max existing Lot_Number for this specific Child_PID
    SELECT NVL(MAX(p.Lot_Number), 0) INTO v_max_existing_batch_lot
    FROM packaged p JOIN productInstance pi ON p.Instance_ID = pi.Instance_ID -- Assuming 'packaged' table name
    WHERE pi.Product_ID = 111.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next lot

    v_expiration_date := TIMESTAMP '2025-03-29 10:30:36' + INTERVAL '135' DAY;
    v_quantity_to_create := ROUND(1.0, 1);

    INSERT INTO packaged (Instance_ID, Lot_Number, Expiration_Date, Quantity) -- Assuming 'packaged' table name
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Serialized' THEN
    -- Assign a unique serial number
    -- Using Instance ID guarantees uniqueness within this context
    v_serial_number := 'SN-' || TO_CHAR(111.0) || '-' || TO_CHAR(v_new_child_instance_id) || '-' || SUBSTR(SYS_GUID(),1,8);
    -- Assign a batch number - use Product_ID of the *parent* instance as the batch for simplicity? Or a sequence?
    -- Let's use the Parent_IID itself as a simple batch identifier for this run.
    v_batch_number := 634.0; -- All children created FOR this parent get same batch number

    INSERT INTO serialized (Instance_ID, Serial_Number, Batch_Number)
    VALUES (v_new_child_instance_id, v_serial_number, v_batch_number);

    -- Quantity for usesComponent link for serialized is typically 1
    v_quantity_to_create := 1;

  END IF;

  -- Step 3: Create the usesComponent link
  -- Quantity_Used is the Quantity_Needed from needsComponent (which matches child quantity for non-serialized)
  IF v_child_category IN ('Commodity', 'Packaged', 'Serialized') THEN -- Only insert if subtype was handled
      INSERT INTO usesComponent (Parent_IID, Child_IID, Quantity_Used)
      VALUES (634.0, v_new_child_instance_id, ROUND(1.0, 1)); -- Use rounded quantity needed
  END IF;

EXCEPTION
  WHEN OTHERS THEN
    DBMS_OUTPUT.PUT_LINE('Error processing Parent_IID=' || 634.0 || ', Child_PID=' || 111.0 || ': ' || SQLERRM);
    -- Decide if you want to rollback just this block or let the main exception handler catch it
END;
/
DECLARE
  v_new_child_instance_id productInstance.Instance_ID%TYPE;
  v_child_category        product.Category%TYPE := 'Commodity'; -- Pass category
  v_max_existing_batch_lot NUMBER;
  v_next_batch_lot_num   NUMBER;
  v_serial_number        serialized.Serial_Number%TYPE;
  v_batch_number         serialized.Batch_Number%TYPE; -- Shared batch for serialized children of *this* parent
  v_expiration_date      commodity.Expiration_Date%TYPE;
  v_quantity_to_create   commodity.Quantity%TYPE; -- Quantity for the new child instance

BEGIN
  -- Step 1: Create the new child productInstance
  INSERT INTO productInstance (Product_ID, Date_Manufactured, Is_Recalled)
  VALUES (136.0, TIMESTAMP '2024-05-02 08:45:49', 0)
  RETURNING Instance_ID INTO v_new_child_instance_id;

  -- Step 2: Create the corresponding subtype record
  IF v_child_category = 'Commodity' THEN
    -- Find max existing Batch_Number for this specific Child_PID
    SELECT NVL(MAX(c.Batch_Number), 0) INTO v_max_existing_batch_lot
    FROM commodity c JOIN productInstance pi ON c.Instance_ID = pi.Instance_ID
    WHERE pi.Product_ID = 136.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next batch

    v_expiration_date := TIMESTAMP '2024-05-02 08:45:49' + INTERVAL '703' DAY;
    v_quantity_to_create := ROUND(0.8, 1);

    INSERT INTO commodity (Instance_ID, Batch_Number, Expiration_Date, Quantity)
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Packaged' THEN
    -- Find max existing Lot_Number for this specific Child_PID
    SELECT NVL(MAX(p.Lot_Number), 0) INTO v_max_existing_batch_lot
    FROM packaged p JOIN productInstance pi ON p.Instance_ID = pi.Instance_ID -- Assuming 'packaged' table name
    WHERE pi.Product_ID = 136.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next lot

    v_expiration_date := TIMESTAMP '2024-05-02 08:45:49' + INTERVAL '385' DAY;
    v_quantity_to_create := ROUND(0.8, 1);

    INSERT INTO packaged (Instance_ID, Lot_Number, Expiration_Date, Quantity) -- Assuming 'packaged' table name
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Serialized' THEN
    -- Assign a unique serial number
    -- Using Instance ID guarantees uniqueness within this context
    v_serial_number := 'SN-' || TO_CHAR(136.0) || '-' || TO_CHAR(v_new_child_instance_id) || '-' || SUBSTR(SYS_GUID(),1,8);
    -- Assign a batch number - use Product_ID of the *parent* instance as the batch for simplicity? Or a sequence?
    -- Let's use the Parent_IID itself as a simple batch identifier for this run.
    v_batch_number := 634.0; -- All children created FOR this parent get same batch number

    INSERT INTO serialized (Instance_ID, Serial_Number, Batch_Number)
    VALUES (v_new_child_instance_id, v_serial_number, v_batch_number);

    -- Quantity for usesComponent link for serialized is typically 1
    v_quantity_to_create := 1;

  END IF;

  -- Step 3: Create the usesComponent link
  -- Quantity_Used is the Quantity_Needed from needsComponent (which matches child quantity for non-serialized)
  IF v_child_category IN ('Commodity', 'Packaged', 'Serialized') THEN -- Only insert if subtype was handled
      INSERT INTO usesComponent (Parent_IID, Child_IID, Quantity_Used)
      VALUES (634.0, v_new_child_instance_id, ROUND(0.8, 1)); -- Use rounded quantity needed
  END IF;

EXCEPTION
  WHEN OTHERS THEN
    DBMS_OUTPUT.PUT_LINE('Error processing Parent_IID=' || 634.0 || ', Child_PID=' || 136.0 || ': ' || SQLERRM);
    -- Decide if you want to rollback just this block or let the main exception handler catch it
END;
/
DECLARE
  v_new_child_instance_id productInstance.Instance_ID%TYPE;
  v_child_category        product.Category%TYPE := 'Commodity'; -- Pass category
  v_max_existing_batch_lot NUMBER;
  v_next_batch_lot_num   NUMBER;
  v_serial_number        serialized.Serial_Number%TYPE;
  v_batch_number         serialized.Batch_Number%TYPE; -- Shared batch for serialized children of *this* parent
  v_expiration_date      commodity.Expiration_Date%TYPE;
  v_quantity_to_create   commodity.Quantity%TYPE; -- Quantity for the new child instance

BEGIN
  -- Step 1: Create the new child productInstance
  INSERT INTO productInstance (Product_ID, Date_Manufactured, Is_Recalled)
  VALUES (179.0, TIMESTAMP '2025-04-23 14:09:44', 0)
  RETURNING Instance_ID INTO v_new_child_instance_id;

  -- Step 2: Create the corresponding subtype record
  IF v_child_category = 'Commodity' THEN
    -- Find max existing Batch_Number for this specific Child_PID
    SELECT NVL(MAX(c.Batch_Number), 0) INTO v_max_existing_batch_lot
    FROM commodity c JOIN productInstance pi ON c.Instance_ID = pi.Instance_ID
    WHERE pi.Product_ID = 179.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next batch

    v_expiration_date := TIMESTAMP '2025-04-23 14:09:44' + INTERVAL '303' DAY;
    v_quantity_to_create := ROUND(1.2, 1);

    INSERT INTO commodity (Instance_ID, Batch_Number, Expiration_Date, Quantity)
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Packaged' THEN
    -- Find max existing Lot_Number for this specific Child_PID
    SELECT NVL(MAX(p.Lot_Number), 0) INTO v_max_existing_batch_lot
    FROM packaged p JOIN productInstance pi ON p.Instance_ID = pi.Instance_ID -- Assuming 'packaged' table name
    WHERE pi.Product_ID = 179.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next lot

    v_expiration_date := TIMESTAMP '2025-04-23 14:09:44' + INTERVAL '87' DAY;
    v_quantity_to_create := ROUND(1.2, 1);

    INSERT INTO packaged (Instance_ID, Lot_Number, Expiration_Date, Quantity) -- Assuming 'packaged' table name
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Serialized' THEN
    -- Assign a unique serial number
    -- Using Instance ID guarantees uniqueness within this context
    v_serial_number := 'SN-' || TO_CHAR(179.0) || '-' || TO_CHAR(v_new_child_instance_id) || '-' || SUBSTR(SYS_GUID(),1,8);
    -- Assign a batch number - use Product_ID of the *parent* instance as the batch for simplicity? Or a sequence?
    -- Let's use the Parent_IID itself as a simple batch identifier for this run.
    v_batch_number := 634.0; -- All children created FOR this parent get same batch number

    INSERT INTO serialized (Instance_ID, Serial_Number, Batch_Number)
    VALUES (v_new_child_instance_id, v_serial_number, v_batch_number);

    -- Quantity for usesComponent link for serialized is typically 1
    v_quantity_to_create := 1;

  END IF;

  -- Step 3: Create the usesComponent link
  -- Quantity_Used is the Quantity_Needed from needsComponent (which matches child quantity for non-serialized)
  IF v_child_category IN ('Commodity', 'Packaged', 'Serialized') THEN -- Only insert if subtype was handled
      INSERT INTO usesComponent (Parent_IID, Child_IID, Quantity_Used)
      VALUES (634.0, v_new_child_instance_id, ROUND(1.2, 1)); -- Use rounded quantity needed
  END IF;

EXCEPTION
  WHEN OTHERS THEN
    DBMS_OUTPUT.PUT_LINE('Error processing Parent_IID=' || 634.0 || ', Child_PID=' || 179.0 || ': ' || SQLERRM);
    -- Decide if you want to rollback just this block or let the main exception handler catch it
END;
/
DECLARE
  v_new_child_instance_id productInstance.Instance_ID%TYPE;
  v_child_category        product.Category%TYPE := 'Commodity'; -- Pass category
  v_max_existing_batch_lot NUMBER;
  v_next_batch_lot_num   NUMBER;
  v_serial_number        serialized.Serial_Number%TYPE;
  v_batch_number         serialized.Batch_Number%TYPE; -- Shared batch for serialized children of *this* parent
  v_expiration_date      commodity.Expiration_Date%TYPE;
  v_quantity_to_create   commodity.Quantity%TYPE; -- Quantity for the new child instance

BEGIN
  -- Step 1: Create the new child productInstance
  INSERT INTO productInstance (Product_ID, Date_Manufactured, Is_Recalled)
  VALUES (247.0, TIMESTAMP '2024-11-24 23:07:17', 0)
  RETURNING Instance_ID INTO v_new_child_instance_id;

  -- Step 2: Create the corresponding subtype record
  IF v_child_category = 'Commodity' THEN
    -- Find max existing Batch_Number for this specific Child_PID
    SELECT NVL(MAX(c.Batch_Number), 0) INTO v_max_existing_batch_lot
    FROM commodity c JOIN productInstance pi ON c.Instance_ID = pi.Instance_ID
    WHERE pi.Product_ID = 247.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next batch

    v_expiration_date := TIMESTAMP '2024-11-24 23:07:17' + INTERVAL '670' DAY;
    v_quantity_to_create := ROUND(1.9, 1);

    INSERT INTO commodity (Instance_ID, Batch_Number, Expiration_Date, Quantity)
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Packaged' THEN
    -- Find max existing Lot_Number for this specific Child_PID
    SELECT NVL(MAX(p.Lot_Number), 0) INTO v_max_existing_batch_lot
    FROM packaged p JOIN productInstance pi ON p.Instance_ID = pi.Instance_ID -- Assuming 'packaged' table name
    WHERE pi.Product_ID = 247.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next lot

    v_expiration_date := TIMESTAMP '2024-11-24 23:07:17' + INTERVAL '480' DAY;
    v_quantity_to_create := ROUND(1.9, 1);

    INSERT INTO packaged (Instance_ID, Lot_Number, Expiration_Date, Quantity) -- Assuming 'packaged' table name
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Serialized' THEN
    -- Assign a unique serial number
    -- Using Instance ID guarantees uniqueness within this context
    v_serial_number := 'SN-' || TO_CHAR(247.0) || '-' || TO_CHAR(v_new_child_instance_id) || '-' || SUBSTR(SYS_GUID(),1,8);
    -- Assign a batch number - use Product_ID of the *parent* instance as the batch for simplicity? Or a sequence?
    -- Let's use the Parent_IID itself as a simple batch identifier for this run.
    v_batch_number := 635.0; -- All children created FOR this parent get same batch number

    INSERT INTO serialized (Instance_ID, Serial_Number, Batch_Number)
    VALUES (v_new_child_instance_id, v_serial_number, v_batch_number);

    -- Quantity for usesComponent link for serialized is typically 1
    v_quantity_to_create := 1;

  END IF;

  -- Step 3: Create the usesComponent link
  -- Quantity_Used is the Quantity_Needed from needsComponent (which matches child quantity for non-serialized)
  IF v_child_category IN ('Commodity', 'Packaged', 'Serialized') THEN -- Only insert if subtype was handled
      INSERT INTO usesComponent (Parent_IID, Child_IID, Quantity_Used)
      VALUES (635.0, v_new_child_instance_id, ROUND(1.9, 1)); -- Use rounded quantity needed
  END IF;

EXCEPTION
  WHEN OTHERS THEN
    DBMS_OUTPUT.PUT_LINE('Error processing Parent_IID=' || 635.0 || ', Child_PID=' || 247.0 || ': ' || SQLERRM);
    -- Decide if you want to rollback just this block or let the main exception handler catch it
END;
/
DECLARE
  v_new_child_instance_id productInstance.Instance_ID%TYPE;
  v_child_category        product.Category%TYPE := 'Commodity'; -- Pass category
  v_max_existing_batch_lot NUMBER;
  v_next_batch_lot_num   NUMBER;
  v_serial_number        serialized.Serial_Number%TYPE;
  v_batch_number         serialized.Batch_Number%TYPE; -- Shared batch for serialized children of *this* parent
  v_expiration_date      commodity.Expiration_Date%TYPE;
  v_quantity_to_create   commodity.Quantity%TYPE; -- Quantity for the new child instance

BEGIN
  -- Step 1: Create the new child productInstance
  INSERT INTO productInstance (Product_ID, Date_Manufactured, Is_Recalled)
  VALUES (111.0, TIMESTAMP '2024-08-23 11:53:52', 0)
  RETURNING Instance_ID INTO v_new_child_instance_id;

  -- Step 2: Create the corresponding subtype record
  IF v_child_category = 'Commodity' THEN
    -- Find max existing Batch_Number for this specific Child_PID
    SELECT NVL(MAX(c.Batch_Number), 0) INTO v_max_existing_batch_lot
    FROM commodity c JOIN productInstance pi ON c.Instance_ID = pi.Instance_ID
    WHERE pi.Product_ID = 111.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next batch

    v_expiration_date := TIMESTAMP '2024-08-23 11:53:52' + INTERVAL '133' DAY;
    v_quantity_to_create := ROUND(1.0, 1);

    INSERT INTO commodity (Instance_ID, Batch_Number, Expiration_Date, Quantity)
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Packaged' THEN
    -- Find max existing Lot_Number for this specific Child_PID
    SELECT NVL(MAX(p.Lot_Number), 0) INTO v_max_existing_batch_lot
    FROM packaged p JOIN productInstance pi ON p.Instance_ID = pi.Instance_ID -- Assuming 'packaged' table name
    WHERE pi.Product_ID = 111.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next lot

    v_expiration_date := TIMESTAMP '2024-08-23 11:53:52' + INTERVAL '264' DAY;
    v_quantity_to_create := ROUND(1.0, 1);

    INSERT INTO packaged (Instance_ID, Lot_Number, Expiration_Date, Quantity) -- Assuming 'packaged' table name
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Serialized' THEN
    -- Assign a unique serial number
    -- Using Instance ID guarantees uniqueness within this context
    v_serial_number := 'SN-' || TO_CHAR(111.0) || '-' || TO_CHAR(v_new_child_instance_id) || '-' || SUBSTR(SYS_GUID(),1,8);
    -- Assign a batch number - use Product_ID of the *parent* instance as the batch for simplicity? Or a sequence?
    -- Let's use the Parent_IID itself as a simple batch identifier for this run.
    v_batch_number := 635.0; -- All children created FOR this parent get same batch number

    INSERT INTO serialized (Instance_ID, Serial_Number, Batch_Number)
    VALUES (v_new_child_instance_id, v_serial_number, v_batch_number);

    -- Quantity for usesComponent link for serialized is typically 1
    v_quantity_to_create := 1;

  END IF;

  -- Step 3: Create the usesComponent link
  -- Quantity_Used is the Quantity_Needed from needsComponent (which matches child quantity for non-serialized)
  IF v_child_category IN ('Commodity', 'Packaged', 'Serialized') THEN -- Only insert if subtype was handled
      INSERT INTO usesComponent (Parent_IID, Child_IID, Quantity_Used)
      VALUES (635.0, v_new_child_instance_id, ROUND(1.0, 1)); -- Use rounded quantity needed
  END IF;

EXCEPTION
  WHEN OTHERS THEN
    DBMS_OUTPUT.PUT_LINE('Error processing Parent_IID=' || 635.0 || ', Child_PID=' || 111.0 || ': ' || SQLERRM);
    -- Decide if you want to rollback just this block or let the main exception handler catch it
END;
/
DECLARE
  v_new_child_instance_id productInstance.Instance_ID%TYPE;
  v_child_category        product.Category%TYPE := 'Commodity'; -- Pass category
  v_max_existing_batch_lot NUMBER;
  v_next_batch_lot_num   NUMBER;
  v_serial_number        serialized.Serial_Number%TYPE;
  v_batch_number         serialized.Batch_Number%TYPE; -- Shared batch for serialized children of *this* parent
  v_expiration_date      commodity.Expiration_Date%TYPE;
  v_quantity_to_create   commodity.Quantity%TYPE; -- Quantity for the new child instance

BEGIN
  -- Step 1: Create the new child productInstance
  INSERT INTO productInstance (Product_ID, Date_Manufactured, Is_Recalled)
  VALUES (136.0, TIMESTAMP '2024-11-12 07:59:34', 0)
  RETURNING Instance_ID INTO v_new_child_instance_id;

  -- Step 2: Create the corresponding subtype record
  IF v_child_category = 'Commodity' THEN
    -- Find max existing Batch_Number for this specific Child_PID
    SELECT NVL(MAX(c.Batch_Number), 0) INTO v_max_existing_batch_lot
    FROM commodity c JOIN productInstance pi ON c.Instance_ID = pi.Instance_ID
    WHERE pi.Product_ID = 136.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next batch

    v_expiration_date := TIMESTAMP '2024-11-12 07:59:34' + INTERVAL '311' DAY;
    v_quantity_to_create := ROUND(0.8, 1);

    INSERT INTO commodity (Instance_ID, Batch_Number, Expiration_Date, Quantity)
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Packaged' THEN
    -- Find max existing Lot_Number for this specific Child_PID
    SELECT NVL(MAX(p.Lot_Number), 0) INTO v_max_existing_batch_lot
    FROM packaged p JOIN productInstance pi ON p.Instance_ID = pi.Instance_ID -- Assuming 'packaged' table name
    WHERE pi.Product_ID = 136.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next lot

    v_expiration_date := TIMESTAMP '2024-11-12 07:59:34' + INTERVAL '306' DAY;
    v_quantity_to_create := ROUND(0.8, 1);

    INSERT INTO packaged (Instance_ID, Lot_Number, Expiration_Date, Quantity) -- Assuming 'packaged' table name
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Serialized' THEN
    -- Assign a unique serial number
    -- Using Instance ID guarantees uniqueness within this context
    v_serial_number := 'SN-' || TO_CHAR(136.0) || '-' || TO_CHAR(v_new_child_instance_id) || '-' || SUBSTR(SYS_GUID(),1,8);
    -- Assign a batch number - use Product_ID of the *parent* instance as the batch for simplicity? Or a sequence?
    -- Let's use the Parent_IID itself as a simple batch identifier for this run.
    v_batch_number := 635.0; -- All children created FOR this parent get same batch number

    INSERT INTO serialized (Instance_ID, Serial_Number, Batch_Number)
    VALUES (v_new_child_instance_id, v_serial_number, v_batch_number);

    -- Quantity for usesComponent link for serialized is typically 1
    v_quantity_to_create := 1;

  END IF;

  -- Step 3: Create the usesComponent link
  -- Quantity_Used is the Quantity_Needed from needsComponent (which matches child quantity for non-serialized)
  IF v_child_category IN ('Commodity', 'Packaged', 'Serialized') THEN -- Only insert if subtype was handled
      INSERT INTO usesComponent (Parent_IID, Child_IID, Quantity_Used)
      VALUES (635.0, v_new_child_instance_id, ROUND(0.8, 1)); -- Use rounded quantity needed
  END IF;

EXCEPTION
  WHEN OTHERS THEN
    DBMS_OUTPUT.PUT_LINE('Error processing Parent_IID=' || 635.0 || ', Child_PID=' || 136.0 || ': ' || SQLERRM);
    -- Decide if you want to rollback just this block or let the main exception handler catch it
END;
/
DECLARE
  v_new_child_instance_id productInstance.Instance_ID%TYPE;
  v_child_category        product.Category%TYPE := 'Commodity'; -- Pass category
  v_max_existing_batch_lot NUMBER;
  v_next_batch_lot_num   NUMBER;
  v_serial_number        serialized.Serial_Number%TYPE;
  v_batch_number         serialized.Batch_Number%TYPE; -- Shared batch for serialized children of *this* parent
  v_expiration_date      commodity.Expiration_Date%TYPE;
  v_quantity_to_create   commodity.Quantity%TYPE; -- Quantity for the new child instance

BEGIN
  -- Step 1: Create the new child productInstance
  INSERT INTO productInstance (Product_ID, Date_Manufactured, Is_Recalled)
  VALUES (179.0, TIMESTAMP '2025-01-28 07:47:45', 0)
  RETURNING Instance_ID INTO v_new_child_instance_id;

  -- Step 2: Create the corresponding subtype record
  IF v_child_category = 'Commodity' THEN
    -- Find max existing Batch_Number for this specific Child_PID
    SELECT NVL(MAX(c.Batch_Number), 0) INTO v_max_existing_batch_lot
    FROM commodity c JOIN productInstance pi ON c.Instance_ID = pi.Instance_ID
    WHERE pi.Product_ID = 179.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next batch

    v_expiration_date := TIMESTAMP '2025-01-28 07:47:45' + INTERVAL '282' DAY;
    v_quantity_to_create := ROUND(1.2, 1);

    INSERT INTO commodity (Instance_ID, Batch_Number, Expiration_Date, Quantity)
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Packaged' THEN
    -- Find max existing Lot_Number for this specific Child_PID
    SELECT NVL(MAX(p.Lot_Number), 0) INTO v_max_existing_batch_lot
    FROM packaged p JOIN productInstance pi ON p.Instance_ID = pi.Instance_ID -- Assuming 'packaged' table name
    WHERE pi.Product_ID = 179.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next lot

    v_expiration_date := TIMESTAMP '2025-01-28 07:47:45' + INTERVAL '451' DAY;
    v_quantity_to_create := ROUND(1.2, 1);

    INSERT INTO packaged (Instance_ID, Lot_Number, Expiration_Date, Quantity) -- Assuming 'packaged' table name
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Serialized' THEN
    -- Assign a unique serial number
    -- Using Instance ID guarantees uniqueness within this context
    v_serial_number := 'SN-' || TO_CHAR(179.0) || '-' || TO_CHAR(v_new_child_instance_id) || '-' || SUBSTR(SYS_GUID(),1,8);
    -- Assign a batch number - use Product_ID of the *parent* instance as the batch for simplicity? Or a sequence?
    -- Let's use the Parent_IID itself as a simple batch identifier for this run.
    v_batch_number := 635.0; -- All children created FOR this parent get same batch number

    INSERT INTO serialized (Instance_ID, Serial_Number, Batch_Number)
    VALUES (v_new_child_instance_id, v_serial_number, v_batch_number);

    -- Quantity for usesComponent link for serialized is typically 1
    v_quantity_to_create := 1;

  END IF;

  -- Step 3: Create the usesComponent link
  -- Quantity_Used is the Quantity_Needed from needsComponent (which matches child quantity for non-serialized)
  IF v_child_category IN ('Commodity', 'Packaged', 'Serialized') THEN -- Only insert if subtype was handled
      INSERT INTO usesComponent (Parent_IID, Child_IID, Quantity_Used)
      VALUES (635.0, v_new_child_instance_id, ROUND(1.2, 1)); -- Use rounded quantity needed
  END IF;

EXCEPTION
  WHEN OTHERS THEN
    DBMS_OUTPUT.PUT_LINE('Error processing Parent_IID=' || 635.0 || ', Child_PID=' || 179.0 || ': ' || SQLERRM);
    -- Decide if you want to rollback just this block or let the main exception handler catch it
END;
/
DECLARE
  v_new_child_instance_id productInstance.Instance_ID%TYPE;
  v_child_category        product.Category%TYPE := 'Commodity'; -- Pass category
  v_max_existing_batch_lot NUMBER;
  v_next_batch_lot_num   NUMBER;
  v_serial_number        serialized.Serial_Number%TYPE;
  v_batch_number         serialized.Batch_Number%TYPE; -- Shared batch for serialized children of *this* parent
  v_expiration_date      commodity.Expiration_Date%TYPE;
  v_quantity_to_create   commodity.Quantity%TYPE; -- Quantity for the new child instance

BEGIN
  -- Step 1: Create the new child productInstance
  INSERT INTO productInstance (Product_ID, Date_Manufactured, Is_Recalled)
  VALUES (247.0, TIMESTAMP '2024-06-25 15:33:38', 0)
  RETURNING Instance_ID INTO v_new_child_instance_id;

  -- Step 2: Create the corresponding subtype record
  IF v_child_category = 'Commodity' THEN
    -- Find max existing Batch_Number for this specific Child_PID
    SELECT NVL(MAX(c.Batch_Number), 0) INTO v_max_existing_batch_lot
    FROM commodity c JOIN productInstance pi ON c.Instance_ID = pi.Instance_ID
    WHERE pi.Product_ID = 247.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next batch

    v_expiration_date := TIMESTAMP '2024-06-25 15:33:38' + INTERVAL '163' DAY;
    v_quantity_to_create := ROUND(1.9, 1);

    INSERT INTO commodity (Instance_ID, Batch_Number, Expiration_Date, Quantity)
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Packaged' THEN
    -- Find max existing Lot_Number for this specific Child_PID
    SELECT NVL(MAX(p.Lot_Number), 0) INTO v_max_existing_batch_lot
    FROM packaged p JOIN productInstance pi ON p.Instance_ID = pi.Instance_ID -- Assuming 'packaged' table name
    WHERE pi.Product_ID = 247.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next lot

    v_expiration_date := TIMESTAMP '2024-06-25 15:33:38' + INTERVAL '292' DAY;
    v_quantity_to_create := ROUND(1.9, 1);

    INSERT INTO packaged (Instance_ID, Lot_Number, Expiration_Date, Quantity) -- Assuming 'packaged' table name
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Serialized' THEN
    -- Assign a unique serial number
    -- Using Instance ID guarantees uniqueness within this context
    v_serial_number := 'SN-' || TO_CHAR(247.0) || '-' || TO_CHAR(v_new_child_instance_id) || '-' || SUBSTR(SYS_GUID(),1,8);
    -- Assign a batch number - use Product_ID of the *parent* instance as the batch for simplicity? Or a sequence?
    -- Let's use the Parent_IID itself as a simple batch identifier for this run.
    v_batch_number := 636.0; -- All children created FOR this parent get same batch number

    INSERT INTO serialized (Instance_ID, Serial_Number, Batch_Number)
    VALUES (v_new_child_instance_id, v_serial_number, v_batch_number);

    -- Quantity for usesComponent link for serialized is typically 1
    v_quantity_to_create := 1;

  END IF;

  -- Step 3: Create the usesComponent link
  -- Quantity_Used is the Quantity_Needed from needsComponent (which matches child quantity for non-serialized)
  IF v_child_category IN ('Commodity', 'Packaged', 'Serialized') THEN -- Only insert if subtype was handled
      INSERT INTO usesComponent (Parent_IID, Child_IID, Quantity_Used)
      VALUES (636.0, v_new_child_instance_id, ROUND(1.9, 1)); -- Use rounded quantity needed
  END IF;

EXCEPTION
  WHEN OTHERS THEN
    DBMS_OUTPUT.PUT_LINE('Error processing Parent_IID=' || 636.0 || ', Child_PID=' || 247.0 || ': ' || SQLERRM);
    -- Decide if you want to rollback just this block or let the main exception handler catch it
END;
/
DECLARE
  v_new_child_instance_id productInstance.Instance_ID%TYPE;
  v_child_category        product.Category%TYPE := 'Commodity'; -- Pass category
  v_max_existing_batch_lot NUMBER;
  v_next_batch_lot_num   NUMBER;
  v_serial_number        serialized.Serial_Number%TYPE;
  v_batch_number         serialized.Batch_Number%TYPE; -- Shared batch for serialized children of *this* parent
  v_expiration_date      commodity.Expiration_Date%TYPE;
  v_quantity_to_create   commodity.Quantity%TYPE; -- Quantity for the new child instance

BEGIN
  -- Step 1: Create the new child productInstance
  INSERT INTO productInstance (Product_ID, Date_Manufactured, Is_Recalled)
  VALUES (111.0, TIMESTAMP '2024-07-13 21:23:15', 0)
  RETURNING Instance_ID INTO v_new_child_instance_id;

  -- Step 2: Create the corresponding subtype record
  IF v_child_category = 'Commodity' THEN
    -- Find max existing Batch_Number for this specific Child_PID
    SELECT NVL(MAX(c.Batch_Number), 0) INTO v_max_existing_batch_lot
    FROM commodity c JOIN productInstance pi ON c.Instance_ID = pi.Instance_ID
    WHERE pi.Product_ID = 111.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next batch

    v_expiration_date := TIMESTAMP '2024-07-13 21:23:15' + INTERVAL '447' DAY;
    v_quantity_to_create := ROUND(1.0, 1);

    INSERT INTO commodity (Instance_ID, Batch_Number, Expiration_Date, Quantity)
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Packaged' THEN
    -- Find max existing Lot_Number for this specific Child_PID
    SELECT NVL(MAX(p.Lot_Number), 0) INTO v_max_existing_batch_lot
    FROM packaged p JOIN productInstance pi ON p.Instance_ID = pi.Instance_ID -- Assuming 'packaged' table name
    WHERE pi.Product_ID = 111.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next lot

    v_expiration_date := TIMESTAMP '2024-07-13 21:23:15' + INTERVAL '604' DAY;
    v_quantity_to_create := ROUND(1.0, 1);

    INSERT INTO packaged (Instance_ID, Lot_Number, Expiration_Date, Quantity) -- Assuming 'packaged' table name
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Serialized' THEN
    -- Assign a unique serial number
    -- Using Instance ID guarantees uniqueness within this context
    v_serial_number := 'SN-' || TO_CHAR(111.0) || '-' || TO_CHAR(v_new_child_instance_id) || '-' || SUBSTR(SYS_GUID(),1,8);
    -- Assign a batch number - use Product_ID of the *parent* instance as the batch for simplicity? Or a sequence?
    -- Let's use the Parent_IID itself as a simple batch identifier for this run.
    v_batch_number := 636.0; -- All children created FOR this parent get same batch number

    INSERT INTO serialized (Instance_ID, Serial_Number, Batch_Number)
    VALUES (v_new_child_instance_id, v_serial_number, v_batch_number);

    -- Quantity for usesComponent link for serialized is typically 1
    v_quantity_to_create := 1;

  END IF;

  -- Step 3: Create the usesComponent link
  -- Quantity_Used is the Quantity_Needed from needsComponent (which matches child quantity for non-serialized)
  IF v_child_category IN ('Commodity', 'Packaged', 'Serialized') THEN -- Only insert if subtype was handled
      INSERT INTO usesComponent (Parent_IID, Child_IID, Quantity_Used)
      VALUES (636.0, v_new_child_instance_id, ROUND(1.0, 1)); -- Use rounded quantity needed
  END IF;

EXCEPTION
  WHEN OTHERS THEN
    DBMS_OUTPUT.PUT_LINE('Error processing Parent_IID=' || 636.0 || ', Child_PID=' || 111.0 || ': ' || SQLERRM);
    -- Decide if you want to rollback just this block or let the main exception handler catch it
END;
/
DECLARE
  v_new_child_instance_id productInstance.Instance_ID%TYPE;
  v_child_category        product.Category%TYPE := 'Commodity'; -- Pass category
  v_max_existing_batch_lot NUMBER;
  v_next_batch_lot_num   NUMBER;
  v_serial_number        serialized.Serial_Number%TYPE;
  v_batch_number         serialized.Batch_Number%TYPE; -- Shared batch for serialized children of *this* parent
  v_expiration_date      commodity.Expiration_Date%TYPE;
  v_quantity_to_create   commodity.Quantity%TYPE; -- Quantity for the new child instance

BEGIN
  -- Step 1: Create the new child productInstance
  INSERT INTO productInstance (Product_ID, Date_Manufactured, Is_Recalled)
  VALUES (136.0, TIMESTAMP '2024-12-29 17:13:45', 0)
  RETURNING Instance_ID INTO v_new_child_instance_id;

  -- Step 2: Create the corresponding subtype record
  IF v_child_category = 'Commodity' THEN
    -- Find max existing Batch_Number for this specific Child_PID
    SELECT NVL(MAX(c.Batch_Number), 0) INTO v_max_existing_batch_lot
    FROM commodity c JOIN productInstance pi ON c.Instance_ID = pi.Instance_ID
    WHERE pi.Product_ID = 136.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next batch

    v_expiration_date := TIMESTAMP '2024-12-29 17:13:45' + INTERVAL '642' DAY;
    v_quantity_to_create := ROUND(0.8, 1);

    INSERT INTO commodity (Instance_ID, Batch_Number, Expiration_Date, Quantity)
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Packaged' THEN
    -- Find max existing Lot_Number for this specific Child_PID
    SELECT NVL(MAX(p.Lot_Number), 0) INTO v_max_existing_batch_lot
    FROM packaged p JOIN productInstance pi ON p.Instance_ID = pi.Instance_ID -- Assuming 'packaged' table name
    WHERE pi.Product_ID = 136.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next lot

    v_expiration_date := TIMESTAMP '2024-12-29 17:13:45' + INTERVAL '89' DAY;
    v_quantity_to_create := ROUND(0.8, 1);

    INSERT INTO packaged (Instance_ID, Lot_Number, Expiration_Date, Quantity) -- Assuming 'packaged' table name
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Serialized' THEN
    -- Assign a unique serial number
    -- Using Instance ID guarantees uniqueness within this context
    v_serial_number := 'SN-' || TO_CHAR(136.0) || '-' || TO_CHAR(v_new_child_instance_id) || '-' || SUBSTR(SYS_GUID(),1,8);
    -- Assign a batch number - use Product_ID of the *parent* instance as the batch for simplicity? Or a sequence?
    -- Let's use the Parent_IID itself as a simple batch identifier for this run.
    v_batch_number := 636.0; -- All children created FOR this parent get same batch number

    INSERT INTO serialized (Instance_ID, Serial_Number, Batch_Number)
    VALUES (v_new_child_instance_id, v_serial_number, v_batch_number);

    -- Quantity for usesComponent link for serialized is typically 1
    v_quantity_to_create := 1;

  END IF;

  -- Step 3: Create the usesComponent link
  -- Quantity_Used is the Quantity_Needed from needsComponent (which matches child quantity for non-serialized)
  IF v_child_category IN ('Commodity', 'Packaged', 'Serialized') THEN -- Only insert if subtype was handled
      INSERT INTO usesComponent (Parent_IID, Child_IID, Quantity_Used)
      VALUES (636.0, v_new_child_instance_id, ROUND(0.8, 1)); -- Use rounded quantity needed
  END IF;

EXCEPTION
  WHEN OTHERS THEN
    DBMS_OUTPUT.PUT_LINE('Error processing Parent_IID=' || 636.0 || ', Child_PID=' || 136.0 || ': ' || SQLERRM);
    -- Decide if you want to rollback just this block or let the main exception handler catch it
END;
/
DECLARE
  v_new_child_instance_id productInstance.Instance_ID%TYPE;
  v_child_category        product.Category%TYPE := 'Commodity'; -- Pass category
  v_max_existing_batch_lot NUMBER;
  v_next_batch_lot_num   NUMBER;
  v_serial_number        serialized.Serial_Number%TYPE;
  v_batch_number         serialized.Batch_Number%TYPE; -- Shared batch for serialized children of *this* parent
  v_expiration_date      commodity.Expiration_Date%TYPE;
  v_quantity_to_create   commodity.Quantity%TYPE; -- Quantity for the new child instance

BEGIN
  -- Step 1: Create the new child productInstance
  INSERT INTO productInstance (Product_ID, Date_Manufactured, Is_Recalled)
  VALUES (179.0, TIMESTAMP '2024-11-21 22:49:48', 0)
  RETURNING Instance_ID INTO v_new_child_instance_id;

  -- Step 2: Create the corresponding subtype record
  IF v_child_category = 'Commodity' THEN
    -- Find max existing Batch_Number for this specific Child_PID
    SELECT NVL(MAX(c.Batch_Number), 0) INTO v_max_existing_batch_lot
    FROM commodity c JOIN productInstance pi ON c.Instance_ID = pi.Instance_ID
    WHERE pi.Product_ID = 179.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next batch

    v_expiration_date := TIMESTAMP '2024-11-21 22:49:48' + INTERVAL '653' DAY;
    v_quantity_to_create := ROUND(1.2, 1);

    INSERT INTO commodity (Instance_ID, Batch_Number, Expiration_Date, Quantity)
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Packaged' THEN
    -- Find max existing Lot_Number for this specific Child_PID
    SELECT NVL(MAX(p.Lot_Number), 0) INTO v_max_existing_batch_lot
    FROM packaged p JOIN productInstance pi ON p.Instance_ID = pi.Instance_ID -- Assuming 'packaged' table name
    WHERE pi.Product_ID = 179.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next lot

    v_expiration_date := TIMESTAMP '2024-11-21 22:49:48' + INTERVAL '551' DAY;
    v_quantity_to_create := ROUND(1.2, 1);

    INSERT INTO packaged (Instance_ID, Lot_Number, Expiration_Date, Quantity) -- Assuming 'packaged' table name
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Serialized' THEN
    -- Assign a unique serial number
    -- Using Instance ID guarantees uniqueness within this context
    v_serial_number := 'SN-' || TO_CHAR(179.0) || '-' || TO_CHAR(v_new_child_instance_id) || '-' || SUBSTR(SYS_GUID(),1,8);
    -- Assign a batch number - use Product_ID of the *parent* instance as the batch for simplicity? Or a sequence?
    -- Let's use the Parent_IID itself as a simple batch identifier for this run.
    v_batch_number := 636.0; -- All children created FOR this parent get same batch number

    INSERT INTO serialized (Instance_ID, Serial_Number, Batch_Number)
    VALUES (v_new_child_instance_id, v_serial_number, v_batch_number);

    -- Quantity for usesComponent link for serialized is typically 1
    v_quantity_to_create := 1;

  END IF;

  -- Step 3: Create the usesComponent link
  -- Quantity_Used is the Quantity_Needed from needsComponent (which matches child quantity for non-serialized)
  IF v_child_category IN ('Commodity', 'Packaged', 'Serialized') THEN -- Only insert if subtype was handled
      INSERT INTO usesComponent (Parent_IID, Child_IID, Quantity_Used)
      VALUES (636.0, v_new_child_instance_id, ROUND(1.2, 1)); -- Use rounded quantity needed
  END IF;

EXCEPTION
  WHEN OTHERS THEN
    DBMS_OUTPUT.PUT_LINE('Error processing Parent_IID=' || 636.0 || ', Child_PID=' || 179.0 || ': ' || SQLERRM);
    -- Decide if you want to rollback just this block or let the main exception handler catch it
END;
/
DECLARE
  v_new_child_instance_id productInstance.Instance_ID%TYPE;
  v_child_category        product.Category%TYPE := 'Commodity'; -- Pass category
  v_max_existing_batch_lot NUMBER;
  v_next_batch_lot_num   NUMBER;
  v_serial_number        serialized.Serial_Number%TYPE;
  v_batch_number         serialized.Batch_Number%TYPE; -- Shared batch for serialized children of *this* parent
  v_expiration_date      commodity.Expiration_Date%TYPE;
  v_quantity_to_create   commodity.Quantity%TYPE; -- Quantity for the new child instance

BEGIN
  -- Step 1: Create the new child productInstance
  INSERT INTO productInstance (Product_ID, Date_Manufactured, Is_Recalled)
  VALUES (230.0, TIMESTAMP '2024-06-25 20:23:16', 0)
  RETURNING Instance_ID INTO v_new_child_instance_id;

  -- Step 2: Create the corresponding subtype record
  IF v_child_category = 'Commodity' THEN
    -- Find max existing Batch_Number for this specific Child_PID
    SELECT NVL(MAX(c.Batch_Number), 0) INTO v_max_existing_batch_lot
    FROM commodity c JOIN productInstance pi ON c.Instance_ID = pi.Instance_ID
    WHERE pi.Product_ID = 230.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next batch

    v_expiration_date := TIMESTAMP '2024-06-25 20:23:16' + INTERVAL '453' DAY;
    v_quantity_to_create := ROUND(1.7, 1);

    INSERT INTO commodity (Instance_ID, Batch_Number, Expiration_Date, Quantity)
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Packaged' THEN
    -- Find max existing Lot_Number for this specific Child_PID
    SELECT NVL(MAX(p.Lot_Number), 0) INTO v_max_existing_batch_lot
    FROM packaged p JOIN productInstance pi ON p.Instance_ID = pi.Instance_ID -- Assuming 'packaged' table name
    WHERE pi.Product_ID = 230.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next lot

    v_expiration_date := TIMESTAMP '2024-06-25 20:23:16' + INTERVAL '306' DAY;
    v_quantity_to_create := ROUND(1.7, 1);

    INSERT INTO packaged (Instance_ID, Lot_Number, Expiration_Date, Quantity) -- Assuming 'packaged' table name
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Serialized' THEN
    -- Assign a unique serial number
    -- Using Instance ID guarantees uniqueness within this context
    v_serial_number := 'SN-' || TO_CHAR(230.0) || '-' || TO_CHAR(v_new_child_instance_id) || '-' || SUBSTR(SYS_GUID(),1,8);
    -- Assign a batch number - use Product_ID of the *parent* instance as the batch for simplicity? Or a sequence?
    -- Let's use the Parent_IID itself as a simple batch identifier for this run.
    v_batch_number := 650.0; -- All children created FOR this parent get same batch number

    INSERT INTO serialized (Instance_ID, Serial_Number, Batch_Number)
    VALUES (v_new_child_instance_id, v_serial_number, v_batch_number);

    -- Quantity for usesComponent link for serialized is typically 1
    v_quantity_to_create := 1;

  END IF;

  -- Step 3: Create the usesComponent link
  -- Quantity_Used is the Quantity_Needed from needsComponent (which matches child quantity for non-serialized)
  IF v_child_category IN ('Commodity', 'Packaged', 'Serialized') THEN -- Only insert if subtype was handled
      INSERT INTO usesComponent (Parent_IID, Child_IID, Quantity_Used)
      VALUES (650.0, v_new_child_instance_id, ROUND(1.7, 1)); -- Use rounded quantity needed
  END IF;

EXCEPTION
  WHEN OTHERS THEN
    DBMS_OUTPUT.PUT_LINE('Error processing Parent_IID=' || 650.0 || ', Child_PID=' || 230.0 || ': ' || SQLERRM);
    -- Decide if you want to rollback just this block or let the main exception handler catch it
END;
/
DECLARE
  v_new_child_instance_id productInstance.Instance_ID%TYPE;
  v_child_category        product.Category%TYPE := 'Commodity'; -- Pass category
  v_max_existing_batch_lot NUMBER;
  v_next_batch_lot_num   NUMBER;
  v_serial_number        serialized.Serial_Number%TYPE;
  v_batch_number         serialized.Batch_Number%TYPE; -- Shared batch for serialized children of *this* parent
  v_expiration_date      commodity.Expiration_Date%TYPE;
  v_quantity_to_create   commodity.Quantity%TYPE; -- Quantity for the new child instance

BEGIN
  -- Step 1: Create the new child productInstance
  INSERT INTO productInstance (Product_ID, Date_Manufactured, Is_Recalled)
  VALUES (217.0, TIMESTAMP '2024-08-15 16:48:17', 0)
  RETURNING Instance_ID INTO v_new_child_instance_id;

  -- Step 2: Create the corresponding subtype record
  IF v_child_category = 'Commodity' THEN
    -- Find max existing Batch_Number for this specific Child_PID
    SELECT NVL(MAX(c.Batch_Number), 0) INTO v_max_existing_batch_lot
    FROM commodity c JOIN productInstance pi ON c.Instance_ID = pi.Instance_ID
    WHERE pi.Product_ID = 217.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next batch

    v_expiration_date := TIMESTAMP '2024-08-15 16:48:17' + INTERVAL '521' DAY;
    v_quantity_to_create := ROUND(1.1, 1);

    INSERT INTO commodity (Instance_ID, Batch_Number, Expiration_Date, Quantity)
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Packaged' THEN
    -- Find max existing Lot_Number for this specific Child_PID
    SELECT NVL(MAX(p.Lot_Number), 0) INTO v_max_existing_batch_lot
    FROM packaged p JOIN productInstance pi ON p.Instance_ID = pi.Instance_ID -- Assuming 'packaged' table name
    WHERE pi.Product_ID = 217.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next lot

    v_expiration_date := TIMESTAMP '2024-08-15 16:48:17' + INTERVAL '343' DAY;
    v_quantity_to_create := ROUND(1.1, 1);

    INSERT INTO packaged (Instance_ID, Lot_Number, Expiration_Date, Quantity) -- Assuming 'packaged' table name
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Serialized' THEN
    -- Assign a unique serial number
    -- Using Instance ID guarantees uniqueness within this context
    v_serial_number := 'SN-' || TO_CHAR(217.0) || '-' || TO_CHAR(v_new_child_instance_id) || '-' || SUBSTR(SYS_GUID(),1,8);
    -- Assign a batch number - use Product_ID of the *parent* instance as the batch for simplicity? Or a sequence?
    -- Let's use the Parent_IID itself as a simple batch identifier for this run.
    v_batch_number := 650.0; -- All children created FOR this parent get same batch number

    INSERT INTO serialized (Instance_ID, Serial_Number, Batch_Number)
    VALUES (v_new_child_instance_id, v_serial_number, v_batch_number);

    -- Quantity for usesComponent link for serialized is typically 1
    v_quantity_to_create := 1;

  END IF;

  -- Step 3: Create the usesComponent link
  -- Quantity_Used is the Quantity_Needed from needsComponent (which matches child quantity for non-serialized)
  IF v_child_category IN ('Commodity', 'Packaged', 'Serialized') THEN -- Only insert if subtype was handled
      INSERT INTO usesComponent (Parent_IID, Child_IID, Quantity_Used)
      VALUES (650.0, v_new_child_instance_id, ROUND(1.1, 1)); -- Use rounded quantity needed
  END IF;

EXCEPTION
  WHEN OTHERS THEN
    DBMS_OUTPUT.PUT_LINE('Error processing Parent_IID=' || 650.0 || ', Child_PID=' || 217.0 || ': ' || SQLERRM);
    -- Decide if you want to rollback just this block or let the main exception handler catch it
END;
/
DECLARE
  v_new_child_instance_id productInstance.Instance_ID%TYPE;
  v_child_category        product.Category%TYPE := 'Commodity'; -- Pass category
  v_max_existing_batch_lot NUMBER;
  v_next_batch_lot_num   NUMBER;
  v_serial_number        serialized.Serial_Number%TYPE;
  v_batch_number         serialized.Batch_Number%TYPE; -- Shared batch for serialized children of *this* parent
  v_expiration_date      commodity.Expiration_Date%TYPE;
  v_quantity_to_create   commodity.Quantity%TYPE; -- Quantity for the new child instance

BEGIN
  -- Step 1: Create the new child productInstance
  INSERT INTO productInstance (Product_ID, Date_Manufactured, Is_Recalled)
  VALUES (133.0, TIMESTAMP '2024-08-10 18:06:54', 0)
  RETURNING Instance_ID INTO v_new_child_instance_id;

  -- Step 2: Create the corresponding subtype record
  IF v_child_category = 'Commodity' THEN
    -- Find max existing Batch_Number for this specific Child_PID
    SELECT NVL(MAX(c.Batch_Number), 0) INTO v_max_existing_batch_lot
    FROM commodity c JOIN productInstance pi ON c.Instance_ID = pi.Instance_ID
    WHERE pi.Product_ID = 133.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next batch

    v_expiration_date := TIMESTAMP '2024-08-10 18:06:54' + INTERVAL '533' DAY;
    v_quantity_to_create := ROUND(1.2, 1);

    INSERT INTO commodity (Instance_ID, Batch_Number, Expiration_Date, Quantity)
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Packaged' THEN
    -- Find max existing Lot_Number for this specific Child_PID
    SELECT NVL(MAX(p.Lot_Number), 0) INTO v_max_existing_batch_lot
    FROM packaged p JOIN productInstance pi ON p.Instance_ID = pi.Instance_ID -- Assuming 'packaged' table name
    WHERE pi.Product_ID = 133.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next lot

    v_expiration_date := TIMESTAMP '2024-08-10 18:06:54' + INTERVAL '249' DAY;
    v_quantity_to_create := ROUND(1.2, 1);

    INSERT INTO packaged (Instance_ID, Lot_Number, Expiration_Date, Quantity) -- Assuming 'packaged' table name
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Serialized' THEN
    -- Assign a unique serial number
    -- Using Instance ID guarantees uniqueness within this context
    v_serial_number := 'SN-' || TO_CHAR(133.0) || '-' || TO_CHAR(v_new_child_instance_id) || '-' || SUBSTR(SYS_GUID(),1,8);
    -- Assign a batch number - use Product_ID of the *parent* instance as the batch for simplicity? Or a sequence?
    -- Let's use the Parent_IID itself as a simple batch identifier for this run.
    v_batch_number := 650.0; -- All children created FOR this parent get same batch number

    INSERT INTO serialized (Instance_ID, Serial_Number, Batch_Number)
    VALUES (v_new_child_instance_id, v_serial_number, v_batch_number);

    -- Quantity for usesComponent link for serialized is typically 1
    v_quantity_to_create := 1;

  END IF;

  -- Step 3: Create the usesComponent link
  -- Quantity_Used is the Quantity_Needed from needsComponent (which matches child quantity for non-serialized)
  IF v_child_category IN ('Commodity', 'Packaged', 'Serialized') THEN -- Only insert if subtype was handled
      INSERT INTO usesComponent (Parent_IID, Child_IID, Quantity_Used)
      VALUES (650.0, v_new_child_instance_id, ROUND(1.2, 1)); -- Use rounded quantity needed
  END IF;

EXCEPTION
  WHEN OTHERS THEN
    DBMS_OUTPUT.PUT_LINE('Error processing Parent_IID=' || 650.0 || ', Child_PID=' || 133.0 || ': ' || SQLERRM);
    -- Decide if you want to rollback just this block or let the main exception handler catch it
END;
/
DECLARE
  v_new_child_instance_id productInstance.Instance_ID%TYPE;
  v_child_category        product.Category%TYPE := 'Commodity'; -- Pass category
  v_max_existing_batch_lot NUMBER;
  v_next_batch_lot_num   NUMBER;
  v_serial_number        serialized.Serial_Number%TYPE;
  v_batch_number         serialized.Batch_Number%TYPE; -- Shared batch for serialized children of *this* parent
  v_expiration_date      commodity.Expiration_Date%TYPE;
  v_quantity_to_create   commodity.Quantity%TYPE; -- Quantity for the new child instance

BEGIN
  -- Step 1: Create the new child productInstance
  INSERT INTO productInstance (Product_ID, Date_Manufactured, Is_Recalled)
  VALUES (101.0, TIMESTAMP '2024-11-08 17:43:26', 0)
  RETURNING Instance_ID INTO v_new_child_instance_id;

  -- Step 2: Create the corresponding subtype record
  IF v_child_category = 'Commodity' THEN
    -- Find max existing Batch_Number for this specific Child_PID
    SELECT NVL(MAX(c.Batch_Number), 0) INTO v_max_existing_batch_lot
    FROM commodity c JOIN productInstance pi ON c.Instance_ID = pi.Instance_ID
    WHERE pi.Product_ID = 101.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next batch

    v_expiration_date := TIMESTAMP '2024-11-08 17:43:26' + INTERVAL '406' DAY;
    v_quantity_to_create := ROUND(0.2, 1);

    INSERT INTO commodity (Instance_ID, Batch_Number, Expiration_Date, Quantity)
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Packaged' THEN
    -- Find max existing Lot_Number for this specific Child_PID
    SELECT NVL(MAX(p.Lot_Number), 0) INTO v_max_existing_batch_lot
    FROM packaged p JOIN productInstance pi ON p.Instance_ID = pi.Instance_ID -- Assuming 'packaged' table name
    WHERE pi.Product_ID = 101.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next lot

    v_expiration_date := TIMESTAMP '2024-11-08 17:43:26' + INTERVAL '643' DAY;
    v_quantity_to_create := ROUND(0.2, 1);

    INSERT INTO packaged (Instance_ID, Lot_Number, Expiration_Date, Quantity) -- Assuming 'packaged' table name
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Serialized' THEN
    -- Assign a unique serial number
    -- Using Instance ID guarantees uniqueness within this context
    v_serial_number := 'SN-' || TO_CHAR(101.0) || '-' || TO_CHAR(v_new_child_instance_id) || '-' || SUBSTR(SYS_GUID(),1,8);
    -- Assign a batch number - use Product_ID of the *parent* instance as the batch for simplicity? Or a sequence?
    -- Let's use the Parent_IID itself as a simple batch identifier for this run.
    v_batch_number := 650.0; -- All children created FOR this parent get same batch number

    INSERT INTO serialized (Instance_ID, Serial_Number, Batch_Number)
    VALUES (v_new_child_instance_id, v_serial_number, v_batch_number);

    -- Quantity for usesComponent link for serialized is typically 1
    v_quantity_to_create := 1;

  END IF;

  -- Step 3: Create the usesComponent link
  -- Quantity_Used is the Quantity_Needed from needsComponent (which matches child quantity for non-serialized)
  IF v_child_category IN ('Commodity', 'Packaged', 'Serialized') THEN -- Only insert if subtype was handled
      INSERT INTO usesComponent (Parent_IID, Child_IID, Quantity_Used)
      VALUES (650.0, v_new_child_instance_id, ROUND(0.2, 1)); -- Use rounded quantity needed
  END IF;

EXCEPTION
  WHEN OTHERS THEN
    DBMS_OUTPUT.PUT_LINE('Error processing Parent_IID=' || 650.0 || ', Child_PID=' || 101.0 || ': ' || SQLERRM);
    -- Decide if you want to rollback just this block or let the main exception handler catch it
END;
/
DECLARE
  v_new_child_instance_id productInstance.Instance_ID%TYPE;
  v_child_category        product.Category%TYPE := 'Commodity'; -- Pass category
  v_max_existing_batch_lot NUMBER;
  v_next_batch_lot_num   NUMBER;
  v_serial_number        serialized.Serial_Number%TYPE;
  v_batch_number         serialized.Batch_Number%TYPE; -- Shared batch for serialized children of *this* parent
  v_expiration_date      commodity.Expiration_Date%TYPE;
  v_quantity_to_create   commodity.Quantity%TYPE; -- Quantity for the new child instance

BEGIN
  -- Step 1: Create the new child productInstance
  INSERT INTO productInstance (Product_ID, Date_Manufactured, Is_Recalled)
  VALUES (216.0, TIMESTAMP '2024-10-28 18:47:46', 0)
  RETURNING Instance_ID INTO v_new_child_instance_id;

  -- Step 2: Create the corresponding subtype record
  IF v_child_category = 'Commodity' THEN
    -- Find max existing Batch_Number for this specific Child_PID
    SELECT NVL(MAX(c.Batch_Number), 0) INTO v_max_existing_batch_lot
    FROM commodity c JOIN productInstance pi ON c.Instance_ID = pi.Instance_ID
    WHERE pi.Product_ID = 216.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next batch

    v_expiration_date := TIMESTAMP '2024-10-28 18:47:46' + INTERVAL '277' DAY;
    v_quantity_to_create := ROUND(0.8, 1);

    INSERT INTO commodity (Instance_ID, Batch_Number, Expiration_Date, Quantity)
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Packaged' THEN
    -- Find max existing Lot_Number for this specific Child_PID
    SELECT NVL(MAX(p.Lot_Number), 0) INTO v_max_existing_batch_lot
    FROM packaged p JOIN productInstance pi ON p.Instance_ID = pi.Instance_ID -- Assuming 'packaged' table name
    WHERE pi.Product_ID = 216.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next lot

    v_expiration_date := TIMESTAMP '2024-10-28 18:47:46' + INTERVAL '376' DAY;
    v_quantity_to_create := ROUND(0.8, 1);

    INSERT INTO packaged (Instance_ID, Lot_Number, Expiration_Date, Quantity) -- Assuming 'packaged' table name
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Serialized' THEN
    -- Assign a unique serial number
    -- Using Instance ID guarantees uniqueness within this context
    v_serial_number := 'SN-' || TO_CHAR(216.0) || '-' || TO_CHAR(v_new_child_instance_id) || '-' || SUBSTR(SYS_GUID(),1,8);
    -- Assign a batch number - use Product_ID of the *parent* instance as the batch for simplicity? Or a sequence?
    -- Let's use the Parent_IID itself as a simple batch identifier for this run.
    v_batch_number := 653.0; -- All children created FOR this parent get same batch number

    INSERT INTO serialized (Instance_ID, Serial_Number, Batch_Number)
    VALUES (v_new_child_instance_id, v_serial_number, v_batch_number);

    -- Quantity for usesComponent link for serialized is typically 1
    v_quantity_to_create := 1;

  END IF;

  -- Step 3: Create the usesComponent link
  -- Quantity_Used is the Quantity_Needed from needsComponent (which matches child quantity for non-serialized)
  IF v_child_category IN ('Commodity', 'Packaged', 'Serialized') THEN -- Only insert if subtype was handled
      INSERT INTO usesComponent (Parent_IID, Child_IID, Quantity_Used)
      VALUES (653.0, v_new_child_instance_id, ROUND(0.8, 1)); -- Use rounded quantity needed
  END IF;

EXCEPTION
  WHEN OTHERS THEN
    DBMS_OUTPUT.PUT_LINE('Error processing Parent_IID=' || 653.0 || ', Child_PID=' || 216.0 || ': ' || SQLERRM);
    -- Decide if you want to rollback just this block or let the main exception handler catch it
END;
/
DECLARE
  v_new_child_instance_id productInstance.Instance_ID%TYPE;
  v_child_category        product.Category%TYPE := 'Commodity'; -- Pass category
  v_max_existing_batch_lot NUMBER;
  v_next_batch_lot_num   NUMBER;
  v_serial_number        serialized.Serial_Number%TYPE;
  v_batch_number         serialized.Batch_Number%TYPE; -- Shared batch for serialized children of *this* parent
  v_expiration_date      commodity.Expiration_Date%TYPE;
  v_quantity_to_create   commodity.Quantity%TYPE; -- Quantity for the new child instance

BEGIN
  -- Step 1: Create the new child productInstance
  INSERT INTO productInstance (Product_ID, Date_Manufactured, Is_Recalled)
  VALUES (216.0, TIMESTAMP '2024-07-06 10:52:48', 0)
  RETURNING Instance_ID INTO v_new_child_instance_id;

  -- Step 2: Create the corresponding subtype record
  IF v_child_category = 'Commodity' THEN
    -- Find max existing Batch_Number for this specific Child_PID
    SELECT NVL(MAX(c.Batch_Number), 0) INTO v_max_existing_batch_lot
    FROM commodity c JOIN productInstance pi ON c.Instance_ID = pi.Instance_ID
    WHERE pi.Product_ID = 216.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next batch

    v_expiration_date := TIMESTAMP '2024-07-06 10:52:48' + INTERVAL '650' DAY;
    v_quantity_to_create := ROUND(0.8, 1);

    INSERT INTO commodity (Instance_ID, Batch_Number, Expiration_Date, Quantity)
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Packaged' THEN
    -- Find max existing Lot_Number for this specific Child_PID
    SELECT NVL(MAX(p.Lot_Number), 0) INTO v_max_existing_batch_lot
    FROM packaged p JOIN productInstance pi ON p.Instance_ID = pi.Instance_ID -- Assuming 'packaged' table name
    WHERE pi.Product_ID = 216.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next lot

    v_expiration_date := TIMESTAMP '2024-07-06 10:52:48' + INTERVAL '215' DAY;
    v_quantity_to_create := ROUND(0.8, 1);

    INSERT INTO packaged (Instance_ID, Lot_Number, Expiration_Date, Quantity) -- Assuming 'packaged' table name
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Serialized' THEN
    -- Assign a unique serial number
    -- Using Instance ID guarantees uniqueness within this context
    v_serial_number := 'SN-' || TO_CHAR(216.0) || '-' || TO_CHAR(v_new_child_instance_id) || '-' || SUBSTR(SYS_GUID(),1,8);
    -- Assign a batch number - use Product_ID of the *parent* instance as the batch for simplicity? Or a sequence?
    -- Let's use the Parent_IID itself as a simple batch identifier for this run.
    v_batch_number := 654.0; -- All children created FOR this parent get same batch number

    INSERT INTO serialized (Instance_ID, Serial_Number, Batch_Number)
    VALUES (v_new_child_instance_id, v_serial_number, v_batch_number);

    -- Quantity for usesComponent link for serialized is typically 1
    v_quantity_to_create := 1;

  END IF;

  -- Step 3: Create the usesComponent link
  -- Quantity_Used is the Quantity_Needed from needsComponent (which matches child quantity for non-serialized)
  IF v_child_category IN ('Commodity', 'Packaged', 'Serialized') THEN -- Only insert if subtype was handled
      INSERT INTO usesComponent (Parent_IID, Child_IID, Quantity_Used)
      VALUES (654.0, v_new_child_instance_id, ROUND(0.8, 1)); -- Use rounded quantity needed
  END IF;

EXCEPTION
  WHEN OTHERS THEN
    DBMS_OUTPUT.PUT_LINE('Error processing Parent_IID=' || 654.0 || ', Child_PID=' || 216.0 || ': ' || SQLERRM);
    -- Decide if you want to rollback just this block or let the main exception handler catch it
END;
/
DECLARE
  v_new_child_instance_id productInstance.Instance_ID%TYPE;
  v_child_category        product.Category%TYPE := 'Commodity'; -- Pass category
  v_max_existing_batch_lot NUMBER;
  v_next_batch_lot_num   NUMBER;
  v_serial_number        serialized.Serial_Number%TYPE;
  v_batch_number         serialized.Batch_Number%TYPE; -- Shared batch for serialized children of *this* parent
  v_expiration_date      commodity.Expiration_Date%TYPE;
  v_quantity_to_create   commodity.Quantity%TYPE; -- Quantity for the new child instance

BEGIN
  -- Step 1: Create the new child productInstance
  INSERT INTO productInstance (Product_ID, Date_Manufactured, Is_Recalled)
  VALUES (216.0, TIMESTAMP '2025-02-10 02:52:08', 0)
  RETURNING Instance_ID INTO v_new_child_instance_id;

  -- Step 2: Create the corresponding subtype record
  IF v_child_category = 'Commodity' THEN
    -- Find max existing Batch_Number for this specific Child_PID
    SELECT NVL(MAX(c.Batch_Number), 0) INTO v_max_existing_batch_lot
    FROM commodity c JOIN productInstance pi ON c.Instance_ID = pi.Instance_ID
    WHERE pi.Product_ID = 216.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next batch

    v_expiration_date := TIMESTAMP '2025-02-10 02:52:08' + INTERVAL '624' DAY;
    v_quantity_to_create := ROUND(0.8, 1);

    INSERT INTO commodity (Instance_ID, Batch_Number, Expiration_Date, Quantity)
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Packaged' THEN
    -- Find max existing Lot_Number for this specific Child_PID
    SELECT NVL(MAX(p.Lot_Number), 0) INTO v_max_existing_batch_lot
    FROM packaged p JOIN productInstance pi ON p.Instance_ID = pi.Instance_ID -- Assuming 'packaged' table name
    WHERE pi.Product_ID = 216.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next lot

    v_expiration_date := TIMESTAMP '2025-02-10 02:52:08' + INTERVAL '491' DAY;
    v_quantity_to_create := ROUND(0.8, 1);

    INSERT INTO packaged (Instance_ID, Lot_Number, Expiration_Date, Quantity) -- Assuming 'packaged' table name
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Serialized' THEN
    -- Assign a unique serial number
    -- Using Instance ID guarantees uniqueness within this context
    v_serial_number := 'SN-' || TO_CHAR(216.0) || '-' || TO_CHAR(v_new_child_instance_id) || '-' || SUBSTR(SYS_GUID(),1,8);
    -- Assign a batch number - use Product_ID of the *parent* instance as the batch for simplicity? Or a sequence?
    -- Let's use the Parent_IID itself as a simple batch identifier for this run.
    v_batch_number := 655.0; -- All children created FOR this parent get same batch number

    INSERT INTO serialized (Instance_ID, Serial_Number, Batch_Number)
    VALUES (v_new_child_instance_id, v_serial_number, v_batch_number);

    -- Quantity for usesComponent link for serialized is typically 1
    v_quantity_to_create := 1;

  END IF;

  -- Step 3: Create the usesComponent link
  -- Quantity_Used is the Quantity_Needed from needsComponent (which matches child quantity for non-serialized)
  IF v_child_category IN ('Commodity', 'Packaged', 'Serialized') THEN -- Only insert if subtype was handled
      INSERT INTO usesComponent (Parent_IID, Child_IID, Quantity_Used)
      VALUES (655.0, v_new_child_instance_id, ROUND(0.8, 1)); -- Use rounded quantity needed
  END IF;

EXCEPTION
  WHEN OTHERS THEN
    DBMS_OUTPUT.PUT_LINE('Error processing Parent_IID=' || 655.0 || ', Child_PID=' || 216.0 || ': ' || SQLERRM);
    -- Decide if you want to rollback just this block or let the main exception handler catch it
END;
/
DECLARE
  v_new_child_instance_id productInstance.Instance_ID%TYPE;
  v_child_category        product.Category%TYPE := 'Commodity'; -- Pass category
  v_max_existing_batch_lot NUMBER;
  v_next_batch_lot_num   NUMBER;
  v_serial_number        serialized.Serial_Number%TYPE;
  v_batch_number         serialized.Batch_Number%TYPE; -- Shared batch for serialized children of *this* parent
  v_expiration_date      commodity.Expiration_Date%TYPE;
  v_quantity_to_create   commodity.Quantity%TYPE; -- Quantity for the new child instance

BEGIN
  -- Step 1: Create the new child productInstance
  INSERT INTO productInstance (Product_ID, Date_Manufactured, Is_Recalled)
  VALUES (216.0, TIMESTAMP '2024-11-22 17:18:56', 0)
  RETURNING Instance_ID INTO v_new_child_instance_id;

  -- Step 2: Create the corresponding subtype record
  IF v_child_category = 'Commodity' THEN
    -- Find max existing Batch_Number for this specific Child_PID
    SELECT NVL(MAX(c.Batch_Number), 0) INTO v_max_existing_batch_lot
    FROM commodity c JOIN productInstance pi ON c.Instance_ID = pi.Instance_ID
    WHERE pi.Product_ID = 216.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next batch

    v_expiration_date := TIMESTAMP '2024-11-22 17:18:56' + INTERVAL '183' DAY;
    v_quantity_to_create := ROUND(0.8, 1);

    INSERT INTO commodity (Instance_ID, Batch_Number, Expiration_Date, Quantity)
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Packaged' THEN
    -- Find max existing Lot_Number for this specific Child_PID
    SELECT NVL(MAX(p.Lot_Number), 0) INTO v_max_existing_batch_lot
    FROM packaged p JOIN productInstance pi ON p.Instance_ID = pi.Instance_ID -- Assuming 'packaged' table name
    WHERE pi.Product_ID = 216.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next lot

    v_expiration_date := TIMESTAMP '2024-11-22 17:18:56' + INTERVAL '89' DAY;
    v_quantity_to_create := ROUND(0.8, 1);

    INSERT INTO packaged (Instance_ID, Lot_Number, Expiration_Date, Quantity) -- Assuming 'packaged' table name
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Serialized' THEN
    -- Assign a unique serial number
    -- Using Instance ID guarantees uniqueness within this context
    v_serial_number := 'SN-' || TO_CHAR(216.0) || '-' || TO_CHAR(v_new_child_instance_id) || '-' || SUBSTR(SYS_GUID(),1,8);
    -- Assign a batch number - use Product_ID of the *parent* instance as the batch for simplicity? Or a sequence?
    -- Let's use the Parent_IID itself as a simple batch identifier for this run.
    v_batch_number := 656.0; -- All children created FOR this parent get same batch number

    INSERT INTO serialized (Instance_ID, Serial_Number, Batch_Number)
    VALUES (v_new_child_instance_id, v_serial_number, v_batch_number);

    -- Quantity for usesComponent link for serialized is typically 1
    v_quantity_to_create := 1;

  END IF;

  -- Step 3: Create the usesComponent link
  -- Quantity_Used is the Quantity_Needed from needsComponent (which matches child quantity for non-serialized)
  IF v_child_category IN ('Commodity', 'Packaged', 'Serialized') THEN -- Only insert if subtype was handled
      INSERT INTO usesComponent (Parent_IID, Child_IID, Quantity_Used)
      VALUES (656.0, v_new_child_instance_id, ROUND(0.8, 1)); -- Use rounded quantity needed
  END IF;

EXCEPTION
  WHEN OTHERS THEN
    DBMS_OUTPUT.PUT_LINE('Error processing Parent_IID=' || 656.0 || ', Child_PID=' || 216.0 || ': ' || SQLERRM);
    -- Decide if you want to rollback just this block or let the main exception handler catch it
END;
/
DECLARE
  v_new_child_instance_id productInstance.Instance_ID%TYPE;
  v_child_category        product.Category%TYPE := 'Commodity'; -- Pass category
  v_max_existing_batch_lot NUMBER;
  v_next_batch_lot_num   NUMBER;
  v_serial_number        serialized.Serial_Number%TYPE;
  v_batch_number         serialized.Batch_Number%TYPE; -- Shared batch for serialized children of *this* parent
  v_expiration_date      commodity.Expiration_Date%TYPE;
  v_quantity_to_create   commodity.Quantity%TYPE; -- Quantity for the new child instance

BEGIN
  -- Step 1: Create the new child productInstance
  INSERT INTO productInstance (Product_ID, Date_Manufactured, Is_Recalled)
  VALUES (123.0, TIMESTAMP '2024-11-10 18:04:56', 0)
  RETURNING Instance_ID INTO v_new_child_instance_id;

  -- Step 2: Create the corresponding subtype record
  IF v_child_category = 'Commodity' THEN
    -- Find max existing Batch_Number for this specific Child_PID
    SELECT NVL(MAX(c.Batch_Number), 0) INTO v_max_existing_batch_lot
    FROM commodity c JOIN productInstance pi ON c.Instance_ID = pi.Instance_ID
    WHERE pi.Product_ID = 123.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next batch

    v_expiration_date := TIMESTAMP '2024-11-10 18:04:56' + INTERVAL '363' DAY;
    v_quantity_to_create := ROUND(1.9, 1);

    INSERT INTO commodity (Instance_ID, Batch_Number, Expiration_Date, Quantity)
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Packaged' THEN
    -- Find max existing Lot_Number for this specific Child_PID
    SELECT NVL(MAX(p.Lot_Number), 0) INTO v_max_existing_batch_lot
    FROM packaged p JOIN productInstance pi ON p.Instance_ID = pi.Instance_ID -- Assuming 'packaged' table name
    WHERE pi.Product_ID = 123.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next lot

    v_expiration_date := TIMESTAMP '2024-11-10 18:04:56' + INTERVAL '571' DAY;
    v_quantity_to_create := ROUND(1.9, 1);

    INSERT INTO packaged (Instance_ID, Lot_Number, Expiration_Date, Quantity) -- Assuming 'packaged' table name
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Serialized' THEN
    -- Assign a unique serial number
    -- Using Instance ID guarantees uniqueness within this context
    v_serial_number := 'SN-' || TO_CHAR(123.0) || '-' || TO_CHAR(v_new_child_instance_id) || '-' || SUBSTR(SYS_GUID(),1,8);
    -- Assign a batch number - use Product_ID of the *parent* instance as the batch for simplicity? Or a sequence?
    -- Let's use the Parent_IID itself as a simple batch identifier for this run.
    v_batch_number := 664.0; -- All children created FOR this parent get same batch number

    INSERT INTO serialized (Instance_ID, Serial_Number, Batch_Number)
    VALUES (v_new_child_instance_id, v_serial_number, v_batch_number);

    -- Quantity for usesComponent link for serialized is typically 1
    v_quantity_to_create := 1;

  END IF;

  -- Step 3: Create the usesComponent link
  -- Quantity_Used is the Quantity_Needed from needsComponent (which matches child quantity for non-serialized)
  IF v_child_category IN ('Commodity', 'Packaged', 'Serialized') THEN -- Only insert if subtype was handled
      INSERT INTO usesComponent (Parent_IID, Child_IID, Quantity_Used)
      VALUES (664.0, v_new_child_instance_id, ROUND(1.9, 1)); -- Use rounded quantity needed
  END IF;

EXCEPTION
  WHEN OTHERS THEN
    DBMS_OUTPUT.PUT_LINE('Error processing Parent_IID=' || 664.0 || ', Child_PID=' || 123.0 || ': ' || SQLERRM);
    -- Decide if you want to rollback just this block or let the main exception handler catch it
END;
/
DECLARE
  v_new_child_instance_id productInstance.Instance_ID%TYPE;
  v_child_category        product.Category%TYPE := 'Commodity'; -- Pass category
  v_max_existing_batch_lot NUMBER;
  v_next_batch_lot_num   NUMBER;
  v_serial_number        serialized.Serial_Number%TYPE;
  v_batch_number         serialized.Batch_Number%TYPE; -- Shared batch for serialized children of *this* parent
  v_expiration_date      commodity.Expiration_Date%TYPE;
  v_quantity_to_create   commodity.Quantity%TYPE; -- Quantity for the new child instance

BEGIN
  -- Step 1: Create the new child productInstance
  INSERT INTO productInstance (Product_ID, Date_Manufactured, Is_Recalled)
  VALUES (163.0, TIMESTAMP '2025-01-22 01:13:40', 0)
  RETURNING Instance_ID INTO v_new_child_instance_id;

  -- Step 2: Create the corresponding subtype record
  IF v_child_category = 'Commodity' THEN
    -- Find max existing Batch_Number for this specific Child_PID
    SELECT NVL(MAX(c.Batch_Number), 0) INTO v_max_existing_batch_lot
    FROM commodity c JOIN productInstance pi ON c.Instance_ID = pi.Instance_ID
    WHERE pi.Product_ID = 163.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next batch

    v_expiration_date := TIMESTAMP '2025-01-22 01:13:40' + INTERVAL '168' DAY;
    v_quantity_to_create := ROUND(1.2, 1);

    INSERT INTO commodity (Instance_ID, Batch_Number, Expiration_Date, Quantity)
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Packaged' THEN
    -- Find max existing Lot_Number for this specific Child_PID
    SELECT NVL(MAX(p.Lot_Number), 0) INTO v_max_existing_batch_lot
    FROM packaged p JOIN productInstance pi ON p.Instance_ID = pi.Instance_ID -- Assuming 'packaged' table name
    WHERE pi.Product_ID = 163.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next lot

    v_expiration_date := TIMESTAMP '2025-01-22 01:13:40' + INTERVAL '690' DAY;
    v_quantity_to_create := ROUND(1.2, 1);

    INSERT INTO packaged (Instance_ID, Lot_Number, Expiration_Date, Quantity) -- Assuming 'packaged' table name
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Serialized' THEN
    -- Assign a unique serial number
    -- Using Instance ID guarantees uniqueness within this context
    v_serial_number := 'SN-' || TO_CHAR(163.0) || '-' || TO_CHAR(v_new_child_instance_id) || '-' || SUBSTR(SYS_GUID(),1,8);
    -- Assign a batch number - use Product_ID of the *parent* instance as the batch for simplicity? Or a sequence?
    -- Let's use the Parent_IID itself as a simple batch identifier for this run.
    v_batch_number := 664.0; -- All children created FOR this parent get same batch number

    INSERT INTO serialized (Instance_ID, Serial_Number, Batch_Number)
    VALUES (v_new_child_instance_id, v_serial_number, v_batch_number);

    -- Quantity for usesComponent link for serialized is typically 1
    v_quantity_to_create := 1;

  END IF;

  -- Step 3: Create the usesComponent link
  -- Quantity_Used is the Quantity_Needed from needsComponent (which matches child quantity for non-serialized)
  IF v_child_category IN ('Commodity', 'Packaged', 'Serialized') THEN -- Only insert if subtype was handled
      INSERT INTO usesComponent (Parent_IID, Child_IID, Quantity_Used)
      VALUES (664.0, v_new_child_instance_id, ROUND(1.2, 1)); -- Use rounded quantity needed
  END IF;

EXCEPTION
  WHEN OTHERS THEN
    DBMS_OUTPUT.PUT_LINE('Error processing Parent_IID=' || 664.0 || ', Child_PID=' || 163.0 || ': ' || SQLERRM);
    -- Decide if you want to rollback just this block or let the main exception handler catch it
END;
/
DECLARE
  v_new_child_instance_id productInstance.Instance_ID%TYPE;
  v_child_category        product.Category%TYPE := 'Commodity'; -- Pass category
  v_max_existing_batch_lot NUMBER;
  v_next_batch_lot_num   NUMBER;
  v_serial_number        serialized.Serial_Number%TYPE;
  v_batch_number         serialized.Batch_Number%TYPE; -- Shared batch for serialized children of *this* parent
  v_expiration_date      commodity.Expiration_Date%TYPE;
  v_quantity_to_create   commodity.Quantity%TYPE; -- Quantity for the new child instance

BEGIN
  -- Step 1: Create the new child productInstance
  INSERT INTO productInstance (Product_ID, Date_Manufactured, Is_Recalled)
  VALUES (123.0, TIMESTAMP '2025-02-18 17:47:59', 0)
  RETURNING Instance_ID INTO v_new_child_instance_id;

  -- Step 2: Create the corresponding subtype record
  IF v_child_category = 'Commodity' THEN
    -- Find max existing Batch_Number for this specific Child_PID
    SELECT NVL(MAX(c.Batch_Number), 0) INTO v_max_existing_batch_lot
    FROM commodity c JOIN productInstance pi ON c.Instance_ID = pi.Instance_ID
    WHERE pi.Product_ID = 123.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next batch

    v_expiration_date := TIMESTAMP '2025-02-18 17:47:59' + INTERVAL '248' DAY;
    v_quantity_to_create := ROUND(1.9, 1);

    INSERT INTO commodity (Instance_ID, Batch_Number, Expiration_Date, Quantity)
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Packaged' THEN
    -- Find max existing Lot_Number for this specific Child_PID
    SELECT NVL(MAX(p.Lot_Number), 0) INTO v_max_existing_batch_lot
    FROM packaged p JOIN productInstance pi ON p.Instance_ID = pi.Instance_ID -- Assuming 'packaged' table name
    WHERE pi.Product_ID = 123.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next lot

    v_expiration_date := TIMESTAMP '2025-02-18 17:47:59' + INTERVAL '352' DAY;
    v_quantity_to_create := ROUND(1.9, 1);

    INSERT INTO packaged (Instance_ID, Lot_Number, Expiration_Date, Quantity) -- Assuming 'packaged' table name
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Serialized' THEN
    -- Assign a unique serial number
    -- Using Instance ID guarantees uniqueness within this context
    v_serial_number := 'SN-' || TO_CHAR(123.0) || '-' || TO_CHAR(v_new_child_instance_id) || '-' || SUBSTR(SYS_GUID(),1,8);
    -- Assign a batch number - use Product_ID of the *parent* instance as the batch for simplicity? Or a sequence?
    -- Let's use the Parent_IID itself as a simple batch identifier for this run.
    v_batch_number := 665.0; -- All children created FOR this parent get same batch number

    INSERT INTO serialized (Instance_ID, Serial_Number, Batch_Number)
    VALUES (v_new_child_instance_id, v_serial_number, v_batch_number);

    -- Quantity for usesComponent link for serialized is typically 1
    v_quantity_to_create := 1;

  END IF;

  -- Step 3: Create the usesComponent link
  -- Quantity_Used is the Quantity_Needed from needsComponent (which matches child quantity for non-serialized)
  IF v_child_category IN ('Commodity', 'Packaged', 'Serialized') THEN -- Only insert if subtype was handled
      INSERT INTO usesComponent (Parent_IID, Child_IID, Quantity_Used)
      VALUES (665.0, v_new_child_instance_id, ROUND(1.9, 1)); -- Use rounded quantity needed
  END IF;

EXCEPTION
  WHEN OTHERS THEN
    DBMS_OUTPUT.PUT_LINE('Error processing Parent_IID=' || 665.0 || ', Child_PID=' || 123.0 || ': ' || SQLERRM);
    -- Decide if you want to rollback just this block or let the main exception handler catch it
END;
/
DECLARE
  v_new_child_instance_id productInstance.Instance_ID%TYPE;
  v_child_category        product.Category%TYPE := 'Commodity'; -- Pass category
  v_max_existing_batch_lot NUMBER;
  v_next_batch_lot_num   NUMBER;
  v_serial_number        serialized.Serial_Number%TYPE;
  v_batch_number         serialized.Batch_Number%TYPE; -- Shared batch for serialized children of *this* parent
  v_expiration_date      commodity.Expiration_Date%TYPE;
  v_quantity_to_create   commodity.Quantity%TYPE; -- Quantity for the new child instance

BEGIN
  -- Step 1: Create the new child productInstance
  INSERT INTO productInstance (Product_ID, Date_Manufactured, Is_Recalled)
  VALUES (163.0, TIMESTAMP '2024-12-26 19:31:33', 0)
  RETURNING Instance_ID INTO v_new_child_instance_id;

  -- Step 2: Create the corresponding subtype record
  IF v_child_category = 'Commodity' THEN
    -- Find max existing Batch_Number for this specific Child_PID
    SELECT NVL(MAX(c.Batch_Number), 0) INTO v_max_existing_batch_lot
    FROM commodity c JOIN productInstance pi ON c.Instance_ID = pi.Instance_ID
    WHERE pi.Product_ID = 163.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next batch

    v_expiration_date := TIMESTAMP '2024-12-26 19:31:33' + INTERVAL '535' DAY;
    v_quantity_to_create := ROUND(1.2, 1);

    INSERT INTO commodity (Instance_ID, Batch_Number, Expiration_Date, Quantity)
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Packaged' THEN
    -- Find max existing Lot_Number for this specific Child_PID
    SELECT NVL(MAX(p.Lot_Number), 0) INTO v_max_existing_batch_lot
    FROM packaged p JOIN productInstance pi ON p.Instance_ID = pi.Instance_ID -- Assuming 'packaged' table name
    WHERE pi.Product_ID = 163.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next lot

    v_expiration_date := TIMESTAMP '2024-12-26 19:31:33' + INTERVAL '521' DAY;
    v_quantity_to_create := ROUND(1.2, 1);

    INSERT INTO packaged (Instance_ID, Lot_Number, Expiration_Date, Quantity) -- Assuming 'packaged' table name
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Serialized' THEN
    -- Assign a unique serial number
    -- Using Instance ID guarantees uniqueness within this context
    v_serial_number := 'SN-' || TO_CHAR(163.0) || '-' || TO_CHAR(v_new_child_instance_id) || '-' || SUBSTR(SYS_GUID(),1,8);
    -- Assign a batch number - use Product_ID of the *parent* instance as the batch for simplicity? Or a sequence?
    -- Let's use the Parent_IID itself as a simple batch identifier for this run.
    v_batch_number := 665.0; -- All children created FOR this parent get same batch number

    INSERT INTO serialized (Instance_ID, Serial_Number, Batch_Number)
    VALUES (v_new_child_instance_id, v_serial_number, v_batch_number);

    -- Quantity for usesComponent link for serialized is typically 1
    v_quantity_to_create := 1;

  END IF;

  -- Step 3: Create the usesComponent link
  -- Quantity_Used is the Quantity_Needed from needsComponent (which matches child quantity for non-serialized)
  IF v_child_category IN ('Commodity', 'Packaged', 'Serialized') THEN -- Only insert if subtype was handled
      INSERT INTO usesComponent (Parent_IID, Child_IID, Quantity_Used)
      VALUES (665.0, v_new_child_instance_id, ROUND(1.2, 1)); -- Use rounded quantity needed
  END IF;

EXCEPTION
  WHEN OTHERS THEN
    DBMS_OUTPUT.PUT_LINE('Error processing Parent_IID=' || 665.0 || ', Child_PID=' || 163.0 || ': ' || SQLERRM);
    -- Decide if you want to rollback just this block or let the main exception handler catch it
END;
/
DECLARE
  v_new_child_instance_id productInstance.Instance_ID%TYPE;
  v_child_category        product.Category%TYPE := 'Commodity'; -- Pass category
  v_max_existing_batch_lot NUMBER;
  v_next_batch_lot_num   NUMBER;
  v_serial_number        serialized.Serial_Number%TYPE;
  v_batch_number         serialized.Batch_Number%TYPE; -- Shared batch for serialized children of *this* parent
  v_expiration_date      commodity.Expiration_Date%TYPE;
  v_quantity_to_create   commodity.Quantity%TYPE; -- Quantity for the new child instance

BEGIN
  -- Step 1: Create the new child productInstance
  INSERT INTO productInstance (Product_ID, Date_Manufactured, Is_Recalled)
  VALUES (203.0, TIMESTAMP '2024-09-04 05:10:18', 0)
  RETURNING Instance_ID INTO v_new_child_instance_id;

  -- Step 2: Create the corresponding subtype record
  IF v_child_category = 'Commodity' THEN
    -- Find max existing Batch_Number for this specific Child_PID
    SELECT NVL(MAX(c.Batch_Number), 0) INTO v_max_existing_batch_lot
    FROM commodity c JOIN productInstance pi ON c.Instance_ID = pi.Instance_ID
    WHERE pi.Product_ID = 203.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next batch

    v_expiration_date := TIMESTAMP '2024-09-04 05:10:18' + INTERVAL '151' DAY;
    v_quantity_to_create := ROUND(0.4, 1);

    INSERT INTO commodity (Instance_ID, Batch_Number, Expiration_Date, Quantity)
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Packaged' THEN
    -- Find max existing Lot_Number for this specific Child_PID
    SELECT NVL(MAX(p.Lot_Number), 0) INTO v_max_existing_batch_lot
    FROM packaged p JOIN productInstance pi ON p.Instance_ID = pi.Instance_ID -- Assuming 'packaged' table name
    WHERE pi.Product_ID = 203.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next lot

    v_expiration_date := TIMESTAMP '2024-09-04 05:10:18' + INTERVAL '160' DAY;
    v_quantity_to_create := ROUND(0.4, 1);

    INSERT INTO packaged (Instance_ID, Lot_Number, Expiration_Date, Quantity) -- Assuming 'packaged' table name
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Serialized' THEN
    -- Assign a unique serial number
    -- Using Instance ID guarantees uniqueness within this context
    v_serial_number := 'SN-' || TO_CHAR(203.0) || '-' || TO_CHAR(v_new_child_instance_id) || '-' || SUBSTR(SYS_GUID(),1,8);
    -- Assign a batch number - use Product_ID of the *parent* instance as the batch for simplicity? Or a sequence?
    -- Let's use the Parent_IID itself as a simple batch identifier for this run.
    v_batch_number := 684.0; -- All children created FOR this parent get same batch number

    INSERT INTO serialized (Instance_ID, Serial_Number, Batch_Number)
    VALUES (v_new_child_instance_id, v_serial_number, v_batch_number);

    -- Quantity for usesComponent link for serialized is typically 1
    v_quantity_to_create := 1;

  END IF;

  -- Step 3: Create the usesComponent link
  -- Quantity_Used is the Quantity_Needed from needsComponent (which matches child quantity for non-serialized)
  IF v_child_category IN ('Commodity', 'Packaged', 'Serialized') THEN -- Only insert if subtype was handled
      INSERT INTO usesComponent (Parent_IID, Child_IID, Quantity_Used)
      VALUES (684.0, v_new_child_instance_id, ROUND(0.4, 1)); -- Use rounded quantity needed
  END IF;

EXCEPTION
  WHEN OTHERS THEN
    DBMS_OUTPUT.PUT_LINE('Error processing Parent_IID=' || 684.0 || ', Child_PID=' || 203.0 || ': ' || SQLERRM);
    -- Decide if you want to rollback just this block or let the main exception handler catch it
END;
/
DECLARE
  v_new_child_instance_id productInstance.Instance_ID%TYPE;
  v_child_category        product.Category%TYPE := 'Commodity'; -- Pass category
  v_max_existing_batch_lot NUMBER;
  v_next_batch_lot_num   NUMBER;
  v_serial_number        serialized.Serial_Number%TYPE;
  v_batch_number         serialized.Batch_Number%TYPE; -- Shared batch for serialized children of *this* parent
  v_expiration_date      commodity.Expiration_Date%TYPE;
  v_quantity_to_create   commodity.Quantity%TYPE; -- Quantity for the new child instance

BEGIN
  -- Step 1: Create the new child productInstance
  INSERT INTO productInstance (Product_ID, Date_Manufactured, Is_Recalled)
  VALUES (102.0, TIMESTAMP '2025-04-08 14:46:27', 0)
  RETURNING Instance_ID INTO v_new_child_instance_id;

  -- Step 2: Create the corresponding subtype record
  IF v_child_category = 'Commodity' THEN
    -- Find max existing Batch_Number for this specific Child_PID
    SELECT NVL(MAX(c.Batch_Number), 0) INTO v_max_existing_batch_lot
    FROM commodity c JOIN productInstance pi ON c.Instance_ID = pi.Instance_ID
    WHERE pi.Product_ID = 102.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next batch

    v_expiration_date := TIMESTAMP '2025-04-08 14:46:27' + INTERVAL '173' DAY;
    v_quantity_to_create := ROUND(1.5, 1);

    INSERT INTO commodity (Instance_ID, Batch_Number, Expiration_Date, Quantity)
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Packaged' THEN
    -- Find max existing Lot_Number for this specific Child_PID
    SELECT NVL(MAX(p.Lot_Number), 0) INTO v_max_existing_batch_lot
    FROM packaged p JOIN productInstance pi ON p.Instance_ID = pi.Instance_ID -- Assuming 'packaged' table name
    WHERE pi.Product_ID = 102.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next lot

    v_expiration_date := TIMESTAMP '2025-04-08 14:46:27' + INTERVAL '292' DAY;
    v_quantity_to_create := ROUND(1.5, 1);

    INSERT INTO packaged (Instance_ID, Lot_Number, Expiration_Date, Quantity) -- Assuming 'packaged' table name
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Serialized' THEN
    -- Assign a unique serial number
    -- Using Instance ID guarantees uniqueness within this context
    v_serial_number := 'SN-' || TO_CHAR(102.0) || '-' || TO_CHAR(v_new_child_instance_id) || '-' || SUBSTR(SYS_GUID(),1,8);
    -- Assign a batch number - use Product_ID of the *parent* instance as the batch for simplicity? Or a sequence?
    -- Let's use the Parent_IID itself as a simple batch identifier for this run.
    v_batch_number := 684.0; -- All children created FOR this parent get same batch number

    INSERT INTO serialized (Instance_ID, Serial_Number, Batch_Number)
    VALUES (v_new_child_instance_id, v_serial_number, v_batch_number);

    -- Quantity for usesComponent link for serialized is typically 1
    v_quantity_to_create := 1;

  END IF;

  -- Step 3: Create the usesComponent link
  -- Quantity_Used is the Quantity_Needed from needsComponent (which matches child quantity for non-serialized)
  IF v_child_category IN ('Commodity', 'Packaged', 'Serialized') THEN -- Only insert if subtype was handled
      INSERT INTO usesComponent (Parent_IID, Child_IID, Quantity_Used)
      VALUES (684.0, v_new_child_instance_id, ROUND(1.5, 1)); -- Use rounded quantity needed
  END IF;

EXCEPTION
  WHEN OTHERS THEN
    DBMS_OUTPUT.PUT_LINE('Error processing Parent_IID=' || 684.0 || ', Child_PID=' || 102.0 || ': ' || SQLERRM);
    -- Decide if you want to rollback just this block or let the main exception handler catch it
END;
/
DECLARE
  v_new_child_instance_id productInstance.Instance_ID%TYPE;
  v_child_category        product.Category%TYPE := 'Commodity'; -- Pass category
  v_max_existing_batch_lot NUMBER;
  v_next_batch_lot_num   NUMBER;
  v_serial_number        serialized.Serial_Number%TYPE;
  v_batch_number         serialized.Batch_Number%TYPE; -- Shared batch for serialized children of *this* parent
  v_expiration_date      commodity.Expiration_Date%TYPE;
  v_quantity_to_create   commodity.Quantity%TYPE; -- Quantity for the new child instance

BEGIN
  -- Step 1: Create the new child productInstance
  INSERT INTO productInstance (Product_ID, Date_Manufactured, Is_Recalled)
  VALUES (174.0, TIMESTAMP '2024-07-25 10:22:21', 0)
  RETURNING Instance_ID INTO v_new_child_instance_id;

  -- Step 2: Create the corresponding subtype record
  IF v_child_category = 'Commodity' THEN
    -- Find max existing Batch_Number for this specific Child_PID
    SELECT NVL(MAX(c.Batch_Number), 0) INTO v_max_existing_batch_lot
    FROM commodity c JOIN productInstance pi ON c.Instance_ID = pi.Instance_ID
    WHERE pi.Product_ID = 174.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next batch

    v_expiration_date := TIMESTAMP '2024-07-25 10:22:21' + INTERVAL '120' DAY;
    v_quantity_to_create := ROUND(0.4, 1);

    INSERT INTO commodity (Instance_ID, Batch_Number, Expiration_Date, Quantity)
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Packaged' THEN
    -- Find max existing Lot_Number for this specific Child_PID
    SELECT NVL(MAX(p.Lot_Number), 0) INTO v_max_existing_batch_lot
    FROM packaged p JOIN productInstance pi ON p.Instance_ID = pi.Instance_ID -- Assuming 'packaged' table name
    WHERE pi.Product_ID = 174.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next lot

    v_expiration_date := TIMESTAMP '2024-07-25 10:22:21' + INTERVAL '680' DAY;
    v_quantity_to_create := ROUND(0.4, 1);

    INSERT INTO packaged (Instance_ID, Lot_Number, Expiration_Date, Quantity) -- Assuming 'packaged' table name
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Serialized' THEN
    -- Assign a unique serial number
    -- Using Instance ID guarantees uniqueness within this context
    v_serial_number := 'SN-' || TO_CHAR(174.0) || '-' || TO_CHAR(v_new_child_instance_id) || '-' || SUBSTR(SYS_GUID(),1,8);
    -- Assign a batch number - use Product_ID of the *parent* instance as the batch for simplicity? Or a sequence?
    -- Let's use the Parent_IID itself as a simple batch identifier for this run.
    v_batch_number := 684.0; -- All children created FOR this parent get same batch number

    INSERT INTO serialized (Instance_ID, Serial_Number, Batch_Number)
    VALUES (v_new_child_instance_id, v_serial_number, v_batch_number);

    -- Quantity for usesComponent link for serialized is typically 1
    v_quantity_to_create := 1;

  END IF;

  -- Step 3: Create the usesComponent link
  -- Quantity_Used is the Quantity_Needed from needsComponent (which matches child quantity for non-serialized)
  IF v_child_category IN ('Commodity', 'Packaged', 'Serialized') THEN -- Only insert if subtype was handled
      INSERT INTO usesComponent (Parent_IID, Child_IID, Quantity_Used)
      VALUES (684.0, v_new_child_instance_id, ROUND(0.4, 1)); -- Use rounded quantity needed
  END IF;

EXCEPTION
  WHEN OTHERS THEN
    DBMS_OUTPUT.PUT_LINE('Error processing Parent_IID=' || 684.0 || ', Child_PID=' || 174.0 || ': ' || SQLERRM);
    -- Decide if you want to rollback just this block or let the main exception handler catch it
END;
/
DECLARE
  v_new_child_instance_id productInstance.Instance_ID%TYPE;
  v_child_category        product.Category%TYPE := 'Commodity'; -- Pass category
  v_max_existing_batch_lot NUMBER;
  v_next_batch_lot_num   NUMBER;
  v_serial_number        serialized.Serial_Number%TYPE;
  v_batch_number         serialized.Batch_Number%TYPE; -- Shared batch for serialized children of *this* parent
  v_expiration_date      commodity.Expiration_Date%TYPE;
  v_quantity_to_create   commodity.Quantity%TYPE; -- Quantity for the new child instance

BEGIN
  -- Step 1: Create the new child productInstance
  INSERT INTO productInstance (Product_ID, Date_Manufactured, Is_Recalled)
  VALUES (216.0, TIMESTAMP '2024-11-24 07:10:44', 0)
  RETURNING Instance_ID INTO v_new_child_instance_id;

  -- Step 2: Create the corresponding subtype record
  IF v_child_category = 'Commodity' THEN
    -- Find max existing Batch_Number for this specific Child_PID
    SELECT NVL(MAX(c.Batch_Number), 0) INTO v_max_existing_batch_lot
    FROM commodity c JOIN productInstance pi ON c.Instance_ID = pi.Instance_ID
    WHERE pi.Product_ID = 216.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next batch

    v_expiration_date := TIMESTAMP '2024-11-24 07:10:44' + INTERVAL '81' DAY;
    v_quantity_to_create := ROUND(1.4, 1);

    INSERT INTO commodity (Instance_ID, Batch_Number, Expiration_Date, Quantity)
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Packaged' THEN
    -- Find max existing Lot_Number for this specific Child_PID
    SELECT NVL(MAX(p.Lot_Number), 0) INTO v_max_existing_batch_lot
    FROM packaged p JOIN productInstance pi ON p.Instance_ID = pi.Instance_ID -- Assuming 'packaged' table name
    WHERE pi.Product_ID = 216.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next lot

    v_expiration_date := TIMESTAMP '2024-11-24 07:10:44' + INTERVAL '606' DAY;
    v_quantity_to_create := ROUND(1.4, 1);

    INSERT INTO packaged (Instance_ID, Lot_Number, Expiration_Date, Quantity) -- Assuming 'packaged' table name
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Serialized' THEN
    -- Assign a unique serial number
    -- Using Instance ID guarantees uniqueness within this context
    v_serial_number := 'SN-' || TO_CHAR(216.0) || '-' || TO_CHAR(v_new_child_instance_id) || '-' || SUBSTR(SYS_GUID(),1,8);
    -- Assign a batch number - use Product_ID of the *parent* instance as the batch for simplicity? Or a sequence?
    -- Let's use the Parent_IID itself as a simple batch identifier for this run.
    v_batch_number := 684.0; -- All children created FOR this parent get same batch number

    INSERT INTO serialized (Instance_ID, Serial_Number, Batch_Number)
    VALUES (v_new_child_instance_id, v_serial_number, v_batch_number);

    -- Quantity for usesComponent link for serialized is typically 1
    v_quantity_to_create := 1;

  END IF;

  -- Step 3: Create the usesComponent link
  -- Quantity_Used is the Quantity_Needed from needsComponent (which matches child quantity for non-serialized)
  IF v_child_category IN ('Commodity', 'Packaged', 'Serialized') THEN -- Only insert if subtype was handled
      INSERT INTO usesComponent (Parent_IID, Child_IID, Quantity_Used)
      VALUES (684.0, v_new_child_instance_id, ROUND(1.4, 1)); -- Use rounded quantity needed
  END IF;

EXCEPTION
  WHEN OTHERS THEN
    DBMS_OUTPUT.PUT_LINE('Error processing Parent_IID=' || 684.0 || ', Child_PID=' || 216.0 || ': ' || SQLERRM);
    -- Decide if you want to rollback just this block or let the main exception handler catch it
END;
/
DECLARE
  v_new_child_instance_id productInstance.Instance_ID%TYPE;
  v_child_category        product.Category%TYPE := 'Commodity'; -- Pass category
  v_max_existing_batch_lot NUMBER;
  v_next_batch_lot_num   NUMBER;
  v_serial_number        serialized.Serial_Number%TYPE;
  v_batch_number         serialized.Batch_Number%TYPE; -- Shared batch for serialized children of *this* parent
  v_expiration_date      commodity.Expiration_Date%TYPE;
  v_quantity_to_create   commodity.Quantity%TYPE; -- Quantity for the new child instance

BEGIN
  -- Step 1: Create the new child productInstance
  INSERT INTO productInstance (Product_ID, Date_Manufactured, Is_Recalled)
  VALUES (203.0, TIMESTAMP '2024-07-04 20:53:49', 0)
  RETURNING Instance_ID INTO v_new_child_instance_id;

  -- Step 2: Create the corresponding subtype record
  IF v_child_category = 'Commodity' THEN
    -- Find max existing Batch_Number for this specific Child_PID
    SELECT NVL(MAX(c.Batch_Number), 0) INTO v_max_existing_batch_lot
    FROM commodity c JOIN productInstance pi ON c.Instance_ID = pi.Instance_ID
    WHERE pi.Product_ID = 203.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next batch

    v_expiration_date := TIMESTAMP '2024-07-04 20:53:49' + INTERVAL '148' DAY;
    v_quantity_to_create := ROUND(0.4, 1);

    INSERT INTO commodity (Instance_ID, Batch_Number, Expiration_Date, Quantity)
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Packaged' THEN
    -- Find max existing Lot_Number for this specific Child_PID
    SELECT NVL(MAX(p.Lot_Number), 0) INTO v_max_existing_batch_lot
    FROM packaged p JOIN productInstance pi ON p.Instance_ID = pi.Instance_ID -- Assuming 'packaged' table name
    WHERE pi.Product_ID = 203.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next lot

    v_expiration_date := TIMESTAMP '2024-07-04 20:53:49' + INTERVAL '261' DAY;
    v_quantity_to_create := ROUND(0.4, 1);

    INSERT INTO packaged (Instance_ID, Lot_Number, Expiration_Date, Quantity) -- Assuming 'packaged' table name
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Serialized' THEN
    -- Assign a unique serial number
    -- Using Instance ID guarantees uniqueness within this context
    v_serial_number := 'SN-' || TO_CHAR(203.0) || '-' || TO_CHAR(v_new_child_instance_id) || '-' || SUBSTR(SYS_GUID(),1,8);
    -- Assign a batch number - use Product_ID of the *parent* instance as the batch for simplicity? Or a sequence?
    -- Let's use the Parent_IID itself as a simple batch identifier for this run.
    v_batch_number := 685.0; -- All children created FOR this parent get same batch number

    INSERT INTO serialized (Instance_ID, Serial_Number, Batch_Number)
    VALUES (v_new_child_instance_id, v_serial_number, v_batch_number);

    -- Quantity for usesComponent link for serialized is typically 1
    v_quantity_to_create := 1;

  END IF;

  -- Step 3: Create the usesComponent link
  -- Quantity_Used is the Quantity_Needed from needsComponent (which matches child quantity for non-serialized)
  IF v_child_category IN ('Commodity', 'Packaged', 'Serialized') THEN -- Only insert if subtype was handled
      INSERT INTO usesComponent (Parent_IID, Child_IID, Quantity_Used)
      VALUES (685.0, v_new_child_instance_id, ROUND(0.4, 1)); -- Use rounded quantity needed
  END IF;

EXCEPTION
  WHEN OTHERS THEN
    DBMS_OUTPUT.PUT_LINE('Error processing Parent_IID=' || 685.0 || ', Child_PID=' || 203.0 || ': ' || SQLERRM);
    -- Decide if you want to rollback just this block or let the main exception handler catch it
END;
/
DECLARE
  v_new_child_instance_id productInstance.Instance_ID%TYPE;
  v_child_category        product.Category%TYPE := 'Commodity'; -- Pass category
  v_max_existing_batch_lot NUMBER;
  v_next_batch_lot_num   NUMBER;
  v_serial_number        serialized.Serial_Number%TYPE;
  v_batch_number         serialized.Batch_Number%TYPE; -- Shared batch for serialized children of *this* parent
  v_expiration_date      commodity.Expiration_Date%TYPE;
  v_quantity_to_create   commodity.Quantity%TYPE; -- Quantity for the new child instance

BEGIN
  -- Step 1: Create the new child productInstance
  INSERT INTO productInstance (Product_ID, Date_Manufactured, Is_Recalled)
  VALUES (102.0, TIMESTAMP '2024-12-03 18:55:41', 0)
  RETURNING Instance_ID INTO v_new_child_instance_id;

  -- Step 2: Create the corresponding subtype record
  IF v_child_category = 'Commodity' THEN
    -- Find max existing Batch_Number for this specific Child_PID
    SELECT NVL(MAX(c.Batch_Number), 0) INTO v_max_existing_batch_lot
    FROM commodity c JOIN productInstance pi ON c.Instance_ID = pi.Instance_ID
    WHERE pi.Product_ID = 102.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next batch

    v_expiration_date := TIMESTAMP '2024-12-03 18:55:41' + INTERVAL '234' DAY;
    v_quantity_to_create := ROUND(1.5, 1);

    INSERT INTO commodity (Instance_ID, Batch_Number, Expiration_Date, Quantity)
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Packaged' THEN
    -- Find max existing Lot_Number for this specific Child_PID
    SELECT NVL(MAX(p.Lot_Number), 0) INTO v_max_existing_batch_lot
    FROM packaged p JOIN productInstance pi ON p.Instance_ID = pi.Instance_ID -- Assuming 'packaged' table name
    WHERE pi.Product_ID = 102.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next lot

    v_expiration_date := TIMESTAMP '2024-12-03 18:55:41' + INTERVAL '545' DAY;
    v_quantity_to_create := ROUND(1.5, 1);

    INSERT INTO packaged (Instance_ID, Lot_Number, Expiration_Date, Quantity) -- Assuming 'packaged' table name
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Serialized' THEN
    -- Assign a unique serial number
    -- Using Instance ID guarantees uniqueness within this context
    v_serial_number := 'SN-' || TO_CHAR(102.0) || '-' || TO_CHAR(v_new_child_instance_id) || '-' || SUBSTR(SYS_GUID(),1,8);
    -- Assign a batch number - use Product_ID of the *parent* instance as the batch for simplicity? Or a sequence?
    -- Let's use the Parent_IID itself as a simple batch identifier for this run.
    v_batch_number := 685.0; -- All children created FOR this parent get same batch number

    INSERT INTO serialized (Instance_ID, Serial_Number, Batch_Number)
    VALUES (v_new_child_instance_id, v_serial_number, v_batch_number);

    -- Quantity for usesComponent link for serialized is typically 1
    v_quantity_to_create := 1;

  END IF;

  -- Step 3: Create the usesComponent link
  -- Quantity_Used is the Quantity_Needed from needsComponent (which matches child quantity for non-serialized)
  IF v_child_category IN ('Commodity', 'Packaged', 'Serialized') THEN -- Only insert if subtype was handled
      INSERT INTO usesComponent (Parent_IID, Child_IID, Quantity_Used)
      VALUES (685.0, v_new_child_instance_id, ROUND(1.5, 1)); -- Use rounded quantity needed
  END IF;

EXCEPTION
  WHEN OTHERS THEN
    DBMS_OUTPUT.PUT_LINE('Error processing Parent_IID=' || 685.0 || ', Child_PID=' || 102.0 || ': ' || SQLERRM);
    -- Decide if you want to rollback just this block or let the main exception handler catch it
END;
/
DECLARE
  v_new_child_instance_id productInstance.Instance_ID%TYPE;
  v_child_category        product.Category%TYPE := 'Commodity'; -- Pass category
  v_max_existing_batch_lot NUMBER;
  v_next_batch_lot_num   NUMBER;
  v_serial_number        serialized.Serial_Number%TYPE;
  v_batch_number         serialized.Batch_Number%TYPE; -- Shared batch for serialized children of *this* parent
  v_expiration_date      commodity.Expiration_Date%TYPE;
  v_quantity_to_create   commodity.Quantity%TYPE; -- Quantity for the new child instance

BEGIN
  -- Step 1: Create the new child productInstance
  INSERT INTO productInstance (Product_ID, Date_Manufactured, Is_Recalled)
  VALUES (174.0, TIMESTAMP '2024-12-05 11:08:31', 0)
  RETURNING Instance_ID INTO v_new_child_instance_id;

  -- Step 2: Create the corresponding subtype record
  IF v_child_category = 'Commodity' THEN
    -- Find max existing Batch_Number for this specific Child_PID
    SELECT NVL(MAX(c.Batch_Number), 0) INTO v_max_existing_batch_lot
    FROM commodity c JOIN productInstance pi ON c.Instance_ID = pi.Instance_ID
    WHERE pi.Product_ID = 174.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next batch

    v_expiration_date := TIMESTAMP '2024-12-05 11:08:31' + INTERVAL '705' DAY;
    v_quantity_to_create := ROUND(0.4, 1);

    INSERT INTO commodity (Instance_ID, Batch_Number, Expiration_Date, Quantity)
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Packaged' THEN
    -- Find max existing Lot_Number for this specific Child_PID
    SELECT NVL(MAX(p.Lot_Number), 0) INTO v_max_existing_batch_lot
    FROM packaged p JOIN productInstance pi ON p.Instance_ID = pi.Instance_ID -- Assuming 'packaged' table name
    WHERE pi.Product_ID = 174.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next lot

    v_expiration_date := TIMESTAMP '2024-12-05 11:08:31' + INTERVAL '345' DAY;
    v_quantity_to_create := ROUND(0.4, 1);

    INSERT INTO packaged (Instance_ID, Lot_Number, Expiration_Date, Quantity) -- Assuming 'packaged' table name
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Serialized' THEN
    -- Assign a unique serial number
    -- Using Instance ID guarantees uniqueness within this context
    v_serial_number := 'SN-' || TO_CHAR(174.0) || '-' || TO_CHAR(v_new_child_instance_id) || '-' || SUBSTR(SYS_GUID(),1,8);
    -- Assign a batch number - use Product_ID of the *parent* instance as the batch for simplicity? Or a sequence?
    -- Let's use the Parent_IID itself as a simple batch identifier for this run.
    v_batch_number := 685.0; -- All children created FOR this parent get same batch number

    INSERT INTO serialized (Instance_ID, Serial_Number, Batch_Number)
    VALUES (v_new_child_instance_id, v_serial_number, v_batch_number);

    -- Quantity for usesComponent link for serialized is typically 1
    v_quantity_to_create := 1;

  END IF;

  -- Step 3: Create the usesComponent link
  -- Quantity_Used is the Quantity_Needed from needsComponent (which matches child quantity for non-serialized)
  IF v_child_category IN ('Commodity', 'Packaged', 'Serialized') THEN -- Only insert if subtype was handled
      INSERT INTO usesComponent (Parent_IID, Child_IID, Quantity_Used)
      VALUES (685.0, v_new_child_instance_id, ROUND(0.4, 1)); -- Use rounded quantity needed
  END IF;

EXCEPTION
  WHEN OTHERS THEN
    DBMS_OUTPUT.PUT_LINE('Error processing Parent_IID=' || 685.0 || ', Child_PID=' || 174.0 || ': ' || SQLERRM);
    -- Decide if you want to rollback just this block or let the main exception handler catch it
END;
/
DECLARE
  v_new_child_instance_id productInstance.Instance_ID%TYPE;
  v_child_category        product.Category%TYPE := 'Commodity'; -- Pass category
  v_max_existing_batch_lot NUMBER;
  v_next_batch_lot_num   NUMBER;
  v_serial_number        serialized.Serial_Number%TYPE;
  v_batch_number         serialized.Batch_Number%TYPE; -- Shared batch for serialized children of *this* parent
  v_expiration_date      commodity.Expiration_Date%TYPE;
  v_quantity_to_create   commodity.Quantity%TYPE; -- Quantity for the new child instance

BEGIN
  -- Step 1: Create the new child productInstance
  INSERT INTO productInstance (Product_ID, Date_Manufactured, Is_Recalled)
  VALUES (216.0, TIMESTAMP '2024-10-10 00:45:07', 0)
  RETURNING Instance_ID INTO v_new_child_instance_id;

  -- Step 2: Create the corresponding subtype record
  IF v_child_category = 'Commodity' THEN
    -- Find max existing Batch_Number for this specific Child_PID
    SELECT NVL(MAX(c.Batch_Number), 0) INTO v_max_existing_batch_lot
    FROM commodity c JOIN productInstance pi ON c.Instance_ID = pi.Instance_ID
    WHERE pi.Product_ID = 216.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next batch

    v_expiration_date := TIMESTAMP '2024-10-10 00:45:07' + INTERVAL '365' DAY;
    v_quantity_to_create := ROUND(1.4, 1);

    INSERT INTO commodity (Instance_ID, Batch_Number, Expiration_Date, Quantity)
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Packaged' THEN
    -- Find max existing Lot_Number for this specific Child_PID
    SELECT NVL(MAX(p.Lot_Number), 0) INTO v_max_existing_batch_lot
    FROM packaged p JOIN productInstance pi ON p.Instance_ID = pi.Instance_ID -- Assuming 'packaged' table name
    WHERE pi.Product_ID = 216.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next lot

    v_expiration_date := TIMESTAMP '2024-10-10 00:45:07' + INTERVAL '34' DAY;
    v_quantity_to_create := ROUND(1.4, 1);

    INSERT INTO packaged (Instance_ID, Lot_Number, Expiration_Date, Quantity) -- Assuming 'packaged' table name
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Serialized' THEN
    -- Assign a unique serial number
    -- Using Instance ID guarantees uniqueness within this context
    v_serial_number := 'SN-' || TO_CHAR(216.0) || '-' || TO_CHAR(v_new_child_instance_id) || '-' || SUBSTR(SYS_GUID(),1,8);
    -- Assign a batch number - use Product_ID of the *parent* instance as the batch for simplicity? Or a sequence?
    -- Let's use the Parent_IID itself as a simple batch identifier for this run.
    v_batch_number := 685.0; -- All children created FOR this parent get same batch number

    INSERT INTO serialized (Instance_ID, Serial_Number, Batch_Number)
    VALUES (v_new_child_instance_id, v_serial_number, v_batch_number);

    -- Quantity for usesComponent link for serialized is typically 1
    v_quantity_to_create := 1;

  END IF;

  -- Step 3: Create the usesComponent link
  -- Quantity_Used is the Quantity_Needed from needsComponent (which matches child quantity for non-serialized)
  IF v_child_category IN ('Commodity', 'Packaged', 'Serialized') THEN -- Only insert if subtype was handled
      INSERT INTO usesComponent (Parent_IID, Child_IID, Quantity_Used)
      VALUES (685.0, v_new_child_instance_id, ROUND(1.4, 1)); -- Use rounded quantity needed
  END IF;

EXCEPTION
  WHEN OTHERS THEN
    DBMS_OUTPUT.PUT_LINE('Error processing Parent_IID=' || 685.0 || ', Child_PID=' || 216.0 || ': ' || SQLERRM);
    -- Decide if you want to rollback just this block or let the main exception handler catch it
END;
/
DECLARE
  v_new_child_instance_id productInstance.Instance_ID%TYPE;
  v_child_category        product.Category%TYPE := 'Commodity'; -- Pass category
  v_max_existing_batch_lot NUMBER;
  v_next_batch_lot_num   NUMBER;
  v_serial_number        serialized.Serial_Number%TYPE;
  v_batch_number         serialized.Batch_Number%TYPE; -- Shared batch for serialized children of *this* parent
  v_expiration_date      commodity.Expiration_Date%TYPE;
  v_quantity_to_create   commodity.Quantity%TYPE; -- Quantity for the new child instance

BEGIN
  -- Step 1: Create the new child productInstance
  INSERT INTO productInstance (Product_ID, Date_Manufactured, Is_Recalled)
  VALUES (203.0, TIMESTAMP '2025-02-23 13:11:56', 0)
  RETURNING Instance_ID INTO v_new_child_instance_id;

  -- Step 2: Create the corresponding subtype record
  IF v_child_category = 'Commodity' THEN
    -- Find max existing Batch_Number for this specific Child_PID
    SELECT NVL(MAX(c.Batch_Number), 0) INTO v_max_existing_batch_lot
    FROM commodity c JOIN productInstance pi ON c.Instance_ID = pi.Instance_ID
    WHERE pi.Product_ID = 203.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next batch

    v_expiration_date := TIMESTAMP '2025-02-23 13:11:56' + INTERVAL '50' DAY;
    v_quantity_to_create := ROUND(0.4, 1);

    INSERT INTO commodity (Instance_ID, Batch_Number, Expiration_Date, Quantity)
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Packaged' THEN
    -- Find max existing Lot_Number for this specific Child_PID
    SELECT NVL(MAX(p.Lot_Number), 0) INTO v_max_existing_batch_lot
    FROM packaged p JOIN productInstance pi ON p.Instance_ID = pi.Instance_ID -- Assuming 'packaged' table name
    WHERE pi.Product_ID = 203.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next lot

    v_expiration_date := TIMESTAMP '2025-02-23 13:11:56' + INTERVAL '342' DAY;
    v_quantity_to_create := ROUND(0.4, 1);

    INSERT INTO packaged (Instance_ID, Lot_Number, Expiration_Date, Quantity) -- Assuming 'packaged' table name
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Serialized' THEN
    -- Assign a unique serial number
    -- Using Instance ID guarantees uniqueness within this context
    v_serial_number := 'SN-' || TO_CHAR(203.0) || '-' || TO_CHAR(v_new_child_instance_id) || '-' || SUBSTR(SYS_GUID(),1,8);
    -- Assign a batch number - use Product_ID of the *parent* instance as the batch for simplicity? Or a sequence?
    -- Let's use the Parent_IID itself as a simple batch identifier for this run.
    v_batch_number := 686.0; -- All children created FOR this parent get same batch number

    INSERT INTO serialized (Instance_ID, Serial_Number, Batch_Number)
    VALUES (v_new_child_instance_id, v_serial_number, v_batch_number);

    -- Quantity for usesComponent link for serialized is typically 1
    v_quantity_to_create := 1;

  END IF;

  -- Step 3: Create the usesComponent link
  -- Quantity_Used is the Quantity_Needed from needsComponent (which matches child quantity for non-serialized)
  IF v_child_category IN ('Commodity', 'Packaged', 'Serialized') THEN -- Only insert if subtype was handled
      INSERT INTO usesComponent (Parent_IID, Child_IID, Quantity_Used)
      VALUES (686.0, v_new_child_instance_id, ROUND(0.4, 1)); -- Use rounded quantity needed
  END IF;

EXCEPTION
  WHEN OTHERS THEN
    DBMS_OUTPUT.PUT_LINE('Error processing Parent_IID=' || 686.0 || ', Child_PID=' || 203.0 || ': ' || SQLERRM);
    -- Decide if you want to rollback just this block or let the main exception handler catch it
END;
/
DECLARE
  v_new_child_instance_id productInstance.Instance_ID%TYPE;
  v_child_category        product.Category%TYPE := 'Commodity'; -- Pass category
  v_max_existing_batch_lot NUMBER;
  v_next_batch_lot_num   NUMBER;
  v_serial_number        serialized.Serial_Number%TYPE;
  v_batch_number         serialized.Batch_Number%TYPE; -- Shared batch for serialized children of *this* parent
  v_expiration_date      commodity.Expiration_Date%TYPE;
  v_quantity_to_create   commodity.Quantity%TYPE; -- Quantity for the new child instance

BEGIN
  -- Step 1: Create the new child productInstance
  INSERT INTO productInstance (Product_ID, Date_Manufactured, Is_Recalled)
  VALUES (102.0, TIMESTAMP '2025-03-14 08:29:44', 0)
  RETURNING Instance_ID INTO v_new_child_instance_id;

  -- Step 2: Create the corresponding subtype record
  IF v_child_category = 'Commodity' THEN
    -- Find max existing Batch_Number for this specific Child_PID
    SELECT NVL(MAX(c.Batch_Number), 0) INTO v_max_existing_batch_lot
    FROM commodity c JOIN productInstance pi ON c.Instance_ID = pi.Instance_ID
    WHERE pi.Product_ID = 102.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next batch

    v_expiration_date := TIMESTAMP '2025-03-14 08:29:44' + INTERVAL '660' DAY;
    v_quantity_to_create := ROUND(1.5, 1);

    INSERT INTO commodity (Instance_ID, Batch_Number, Expiration_Date, Quantity)
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Packaged' THEN
    -- Find max existing Lot_Number for this specific Child_PID
    SELECT NVL(MAX(p.Lot_Number), 0) INTO v_max_existing_batch_lot
    FROM packaged p JOIN productInstance pi ON p.Instance_ID = pi.Instance_ID -- Assuming 'packaged' table name
    WHERE pi.Product_ID = 102.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next lot

    v_expiration_date := TIMESTAMP '2025-03-14 08:29:44' + INTERVAL '255' DAY;
    v_quantity_to_create := ROUND(1.5, 1);

    INSERT INTO packaged (Instance_ID, Lot_Number, Expiration_Date, Quantity) -- Assuming 'packaged' table name
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Serialized' THEN
    -- Assign a unique serial number
    -- Using Instance ID guarantees uniqueness within this context
    v_serial_number := 'SN-' || TO_CHAR(102.0) || '-' || TO_CHAR(v_new_child_instance_id) || '-' || SUBSTR(SYS_GUID(),1,8);
    -- Assign a batch number - use Product_ID of the *parent* instance as the batch for simplicity? Or a sequence?
    -- Let's use the Parent_IID itself as a simple batch identifier for this run.
    v_batch_number := 686.0; -- All children created FOR this parent get same batch number

    INSERT INTO serialized (Instance_ID, Serial_Number, Batch_Number)
    VALUES (v_new_child_instance_id, v_serial_number, v_batch_number);

    -- Quantity for usesComponent link for serialized is typically 1
    v_quantity_to_create := 1;

  END IF;

  -- Step 3: Create the usesComponent link
  -- Quantity_Used is the Quantity_Needed from needsComponent (which matches child quantity for non-serialized)
  IF v_child_category IN ('Commodity', 'Packaged', 'Serialized') THEN -- Only insert if subtype was handled
      INSERT INTO usesComponent (Parent_IID, Child_IID, Quantity_Used)
      VALUES (686.0, v_new_child_instance_id, ROUND(1.5, 1)); -- Use rounded quantity needed
  END IF;

EXCEPTION
  WHEN OTHERS THEN
    DBMS_OUTPUT.PUT_LINE('Error processing Parent_IID=' || 686.0 || ', Child_PID=' || 102.0 || ': ' || SQLERRM);
    -- Decide if you want to rollback just this block or let the main exception handler catch it
END;
/
DECLARE
  v_new_child_instance_id productInstance.Instance_ID%TYPE;
  v_child_category        product.Category%TYPE := 'Commodity'; -- Pass category
  v_max_existing_batch_lot NUMBER;
  v_next_batch_lot_num   NUMBER;
  v_serial_number        serialized.Serial_Number%TYPE;
  v_batch_number         serialized.Batch_Number%TYPE; -- Shared batch for serialized children of *this* parent
  v_expiration_date      commodity.Expiration_Date%TYPE;
  v_quantity_to_create   commodity.Quantity%TYPE; -- Quantity for the new child instance

BEGIN
  -- Step 1: Create the new child productInstance
  INSERT INTO productInstance (Product_ID, Date_Manufactured, Is_Recalled)
  VALUES (174.0, TIMESTAMP '2024-05-31 21:10:05', 0)
  RETURNING Instance_ID INTO v_new_child_instance_id;

  -- Step 2: Create the corresponding subtype record
  IF v_child_category = 'Commodity' THEN
    -- Find max existing Batch_Number for this specific Child_PID
    SELECT NVL(MAX(c.Batch_Number), 0) INTO v_max_existing_batch_lot
    FROM commodity c JOIN productInstance pi ON c.Instance_ID = pi.Instance_ID
    WHERE pi.Product_ID = 174.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next batch

    v_expiration_date := TIMESTAMP '2024-05-31 21:10:05' + INTERVAL '259' DAY;
    v_quantity_to_create := ROUND(0.4, 1);

    INSERT INTO commodity (Instance_ID, Batch_Number, Expiration_Date, Quantity)
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Packaged' THEN
    -- Find max existing Lot_Number for this specific Child_PID
    SELECT NVL(MAX(p.Lot_Number), 0) INTO v_max_existing_batch_lot
    FROM packaged p JOIN productInstance pi ON p.Instance_ID = pi.Instance_ID -- Assuming 'packaged' table name
    WHERE pi.Product_ID = 174.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next lot

    v_expiration_date := TIMESTAMP '2024-05-31 21:10:05' + INTERVAL '316' DAY;
    v_quantity_to_create := ROUND(0.4, 1);

    INSERT INTO packaged (Instance_ID, Lot_Number, Expiration_Date, Quantity) -- Assuming 'packaged' table name
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Serialized' THEN
    -- Assign a unique serial number
    -- Using Instance ID guarantees uniqueness within this context
    v_serial_number := 'SN-' || TO_CHAR(174.0) || '-' || TO_CHAR(v_new_child_instance_id) || '-' || SUBSTR(SYS_GUID(),1,8);
    -- Assign a batch number - use Product_ID of the *parent* instance as the batch for simplicity? Or a sequence?
    -- Let's use the Parent_IID itself as a simple batch identifier for this run.
    v_batch_number := 686.0; -- All children created FOR this parent get same batch number

    INSERT INTO serialized (Instance_ID, Serial_Number, Batch_Number)
    VALUES (v_new_child_instance_id, v_serial_number, v_batch_number);

    -- Quantity for usesComponent link for serialized is typically 1
    v_quantity_to_create := 1;

  END IF;

  -- Step 3: Create the usesComponent link
  -- Quantity_Used is the Quantity_Needed from needsComponent (which matches child quantity for non-serialized)
  IF v_child_category IN ('Commodity', 'Packaged', 'Serialized') THEN -- Only insert if subtype was handled
      INSERT INTO usesComponent (Parent_IID, Child_IID, Quantity_Used)
      VALUES (686.0, v_new_child_instance_id, ROUND(0.4, 1)); -- Use rounded quantity needed
  END IF;

EXCEPTION
  WHEN OTHERS THEN
    DBMS_OUTPUT.PUT_LINE('Error processing Parent_IID=' || 686.0 || ', Child_PID=' || 174.0 || ': ' || SQLERRM);
    -- Decide if you want to rollback just this block or let the main exception handler catch it
END;
/
DECLARE
  v_new_child_instance_id productInstance.Instance_ID%TYPE;
  v_child_category        product.Category%TYPE := 'Commodity'; -- Pass category
  v_max_existing_batch_lot NUMBER;
  v_next_batch_lot_num   NUMBER;
  v_serial_number        serialized.Serial_Number%TYPE;
  v_batch_number         serialized.Batch_Number%TYPE; -- Shared batch for serialized children of *this* parent
  v_expiration_date      commodity.Expiration_Date%TYPE;
  v_quantity_to_create   commodity.Quantity%TYPE; -- Quantity for the new child instance

BEGIN
  -- Step 1: Create the new child productInstance
  INSERT INTO productInstance (Product_ID, Date_Manufactured, Is_Recalled)
  VALUES (216.0, TIMESTAMP '2025-01-18 09:27:24', 0)
  RETURNING Instance_ID INTO v_new_child_instance_id;

  -- Step 2: Create the corresponding subtype record
  IF v_child_category = 'Commodity' THEN
    -- Find max existing Batch_Number for this specific Child_PID
    SELECT NVL(MAX(c.Batch_Number), 0) INTO v_max_existing_batch_lot
    FROM commodity c JOIN productInstance pi ON c.Instance_ID = pi.Instance_ID
    WHERE pi.Product_ID = 216.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next batch

    v_expiration_date := TIMESTAMP '2025-01-18 09:27:24' + INTERVAL '670' DAY;
    v_quantity_to_create := ROUND(1.4, 1);

    INSERT INTO commodity (Instance_ID, Batch_Number, Expiration_Date, Quantity)
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Packaged' THEN
    -- Find max existing Lot_Number for this specific Child_PID
    SELECT NVL(MAX(p.Lot_Number), 0) INTO v_max_existing_batch_lot
    FROM packaged p JOIN productInstance pi ON p.Instance_ID = pi.Instance_ID -- Assuming 'packaged' table name
    WHERE pi.Product_ID = 216.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next lot

    v_expiration_date := TIMESTAMP '2025-01-18 09:27:24' + INTERVAL '379' DAY;
    v_quantity_to_create := ROUND(1.4, 1);

    INSERT INTO packaged (Instance_ID, Lot_Number, Expiration_Date, Quantity) -- Assuming 'packaged' table name
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Serialized' THEN
    -- Assign a unique serial number
    -- Using Instance ID guarantees uniqueness within this context
    v_serial_number := 'SN-' || TO_CHAR(216.0) || '-' || TO_CHAR(v_new_child_instance_id) || '-' || SUBSTR(SYS_GUID(),1,8);
    -- Assign a batch number - use Product_ID of the *parent* instance as the batch for simplicity? Or a sequence?
    -- Let's use the Parent_IID itself as a simple batch identifier for this run.
    v_batch_number := 686.0; -- All children created FOR this parent get same batch number

    INSERT INTO serialized (Instance_ID, Serial_Number, Batch_Number)
    VALUES (v_new_child_instance_id, v_serial_number, v_batch_number);

    -- Quantity for usesComponent link for serialized is typically 1
    v_quantity_to_create := 1;

  END IF;

  -- Step 3: Create the usesComponent link
  -- Quantity_Used is the Quantity_Needed from needsComponent (which matches child quantity for non-serialized)
  IF v_child_category IN ('Commodity', 'Packaged', 'Serialized') THEN -- Only insert if subtype was handled
      INSERT INTO usesComponent (Parent_IID, Child_IID, Quantity_Used)
      VALUES (686.0, v_new_child_instance_id, ROUND(1.4, 1)); -- Use rounded quantity needed
  END IF;

EXCEPTION
  WHEN OTHERS THEN
    DBMS_OUTPUT.PUT_LINE('Error processing Parent_IID=' || 686.0 || ', Child_PID=' || 216.0 || ': ' || SQLERRM);
    -- Decide if you want to rollback just this block or let the main exception handler catch it
END;
/
DECLARE
  v_new_child_instance_id productInstance.Instance_ID%TYPE;
  v_child_category        product.Category%TYPE := 'Commodity'; -- Pass category
  v_max_existing_batch_lot NUMBER;
  v_next_batch_lot_num   NUMBER;
  v_serial_number        serialized.Serial_Number%TYPE;
  v_batch_number         serialized.Batch_Number%TYPE; -- Shared batch for serialized children of *this* parent
  v_expiration_date      commodity.Expiration_Date%TYPE;
  v_quantity_to_create   commodity.Quantity%TYPE; -- Quantity for the new child instance

BEGIN
  -- Step 1: Create the new child productInstance
  INSERT INTO productInstance (Product_ID, Date_Manufactured, Is_Recalled)
  VALUES (203.0, TIMESTAMP '2024-08-11 12:54:54', 0)
  RETURNING Instance_ID INTO v_new_child_instance_id;

  -- Step 2: Create the corresponding subtype record
  IF v_child_category = 'Commodity' THEN
    -- Find max existing Batch_Number for this specific Child_PID
    SELECT NVL(MAX(c.Batch_Number), 0) INTO v_max_existing_batch_lot
    FROM commodity c JOIN productInstance pi ON c.Instance_ID = pi.Instance_ID
    WHERE pi.Product_ID = 203.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next batch

    v_expiration_date := TIMESTAMP '2024-08-11 12:54:54' + INTERVAL '645' DAY;
    v_quantity_to_create := ROUND(0.4, 1);

    INSERT INTO commodity (Instance_ID, Batch_Number, Expiration_Date, Quantity)
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Packaged' THEN
    -- Find max existing Lot_Number for this specific Child_PID
    SELECT NVL(MAX(p.Lot_Number), 0) INTO v_max_existing_batch_lot
    FROM packaged p JOIN productInstance pi ON p.Instance_ID = pi.Instance_ID -- Assuming 'packaged' table name
    WHERE pi.Product_ID = 203.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next lot

    v_expiration_date := TIMESTAMP '2024-08-11 12:54:54' + INTERVAL '560' DAY;
    v_quantity_to_create := ROUND(0.4, 1);

    INSERT INTO packaged (Instance_ID, Lot_Number, Expiration_Date, Quantity) -- Assuming 'packaged' table name
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Serialized' THEN
    -- Assign a unique serial number
    -- Using Instance ID guarantees uniqueness within this context
    v_serial_number := 'SN-' || TO_CHAR(203.0) || '-' || TO_CHAR(v_new_child_instance_id) || '-' || SUBSTR(SYS_GUID(),1,8);
    -- Assign a batch number - use Product_ID of the *parent* instance as the batch for simplicity? Or a sequence?
    -- Let's use the Parent_IID itself as a simple batch identifier for this run.
    v_batch_number := 687.0; -- All children created FOR this parent get same batch number

    INSERT INTO serialized (Instance_ID, Serial_Number, Batch_Number)
    VALUES (v_new_child_instance_id, v_serial_number, v_batch_number);

    -- Quantity for usesComponent link for serialized is typically 1
    v_quantity_to_create := 1;

  END IF;

  -- Step 3: Create the usesComponent link
  -- Quantity_Used is the Quantity_Needed from needsComponent (which matches child quantity for non-serialized)
  IF v_child_category IN ('Commodity', 'Packaged', 'Serialized') THEN -- Only insert if subtype was handled
      INSERT INTO usesComponent (Parent_IID, Child_IID, Quantity_Used)
      VALUES (687.0, v_new_child_instance_id, ROUND(0.4, 1)); -- Use rounded quantity needed
  END IF;

EXCEPTION
  WHEN OTHERS THEN
    DBMS_OUTPUT.PUT_LINE('Error processing Parent_IID=' || 687.0 || ', Child_PID=' || 203.0 || ': ' || SQLERRM);
    -- Decide if you want to rollback just this block or let the main exception handler catch it
END;
/
DECLARE
  v_new_child_instance_id productInstance.Instance_ID%TYPE;
  v_child_category        product.Category%TYPE := 'Commodity'; -- Pass category
  v_max_existing_batch_lot NUMBER;
  v_next_batch_lot_num   NUMBER;
  v_serial_number        serialized.Serial_Number%TYPE;
  v_batch_number         serialized.Batch_Number%TYPE; -- Shared batch for serialized children of *this* parent
  v_expiration_date      commodity.Expiration_Date%TYPE;
  v_quantity_to_create   commodity.Quantity%TYPE; -- Quantity for the new child instance

BEGIN
  -- Step 1: Create the new child productInstance
  INSERT INTO productInstance (Product_ID, Date_Manufactured, Is_Recalled)
  VALUES (102.0, TIMESTAMP '2024-09-23 08:04:28', 0)
  RETURNING Instance_ID INTO v_new_child_instance_id;

  -- Step 2: Create the corresponding subtype record
  IF v_child_category = 'Commodity' THEN
    -- Find max existing Batch_Number for this specific Child_PID
    SELECT NVL(MAX(c.Batch_Number), 0) INTO v_max_existing_batch_lot
    FROM commodity c JOIN productInstance pi ON c.Instance_ID = pi.Instance_ID
    WHERE pi.Product_ID = 102.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next batch

    v_expiration_date := TIMESTAMP '2024-09-23 08:04:28' + INTERVAL '53' DAY;
    v_quantity_to_create := ROUND(1.5, 1);

    INSERT INTO commodity (Instance_ID, Batch_Number, Expiration_Date, Quantity)
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Packaged' THEN
    -- Find max existing Lot_Number for this specific Child_PID
    SELECT NVL(MAX(p.Lot_Number), 0) INTO v_max_existing_batch_lot
    FROM packaged p JOIN productInstance pi ON p.Instance_ID = pi.Instance_ID -- Assuming 'packaged' table name
    WHERE pi.Product_ID = 102.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next lot

    v_expiration_date := TIMESTAMP '2024-09-23 08:04:28' + INTERVAL '154' DAY;
    v_quantity_to_create := ROUND(1.5, 1);

    INSERT INTO packaged (Instance_ID, Lot_Number, Expiration_Date, Quantity) -- Assuming 'packaged' table name
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Serialized' THEN
    -- Assign a unique serial number
    -- Using Instance ID guarantees uniqueness within this context
    v_serial_number := 'SN-' || TO_CHAR(102.0) || '-' || TO_CHAR(v_new_child_instance_id) || '-' || SUBSTR(SYS_GUID(),1,8);
    -- Assign a batch number - use Product_ID of the *parent* instance as the batch for simplicity? Or a sequence?
    -- Let's use the Parent_IID itself as a simple batch identifier for this run.
    v_batch_number := 687.0; -- All children created FOR this parent get same batch number

    INSERT INTO serialized (Instance_ID, Serial_Number, Batch_Number)
    VALUES (v_new_child_instance_id, v_serial_number, v_batch_number);

    -- Quantity for usesComponent link for serialized is typically 1
    v_quantity_to_create := 1;

  END IF;

  -- Step 3: Create the usesComponent link
  -- Quantity_Used is the Quantity_Needed from needsComponent (which matches child quantity for non-serialized)
  IF v_child_category IN ('Commodity', 'Packaged', 'Serialized') THEN -- Only insert if subtype was handled
      INSERT INTO usesComponent (Parent_IID, Child_IID, Quantity_Used)
      VALUES (687.0, v_new_child_instance_id, ROUND(1.5, 1)); -- Use rounded quantity needed
  END IF;

EXCEPTION
  WHEN OTHERS THEN
    DBMS_OUTPUT.PUT_LINE('Error processing Parent_IID=' || 687.0 || ', Child_PID=' || 102.0 || ': ' || SQLERRM);
    -- Decide if you want to rollback just this block or let the main exception handler catch it
END;
/
DECLARE
  v_new_child_instance_id productInstance.Instance_ID%TYPE;
  v_child_category        product.Category%TYPE := 'Commodity'; -- Pass category
  v_max_existing_batch_lot NUMBER;
  v_next_batch_lot_num   NUMBER;
  v_serial_number        serialized.Serial_Number%TYPE;
  v_batch_number         serialized.Batch_Number%TYPE; -- Shared batch for serialized children of *this* parent
  v_expiration_date      commodity.Expiration_Date%TYPE;
  v_quantity_to_create   commodity.Quantity%TYPE; -- Quantity for the new child instance

BEGIN
  -- Step 1: Create the new child productInstance
  INSERT INTO productInstance (Product_ID, Date_Manufactured, Is_Recalled)
  VALUES (174.0, TIMESTAMP '2024-09-04 03:14:26', 0)
  RETURNING Instance_ID INTO v_new_child_instance_id;

  -- Step 2: Create the corresponding subtype record
  IF v_child_category = 'Commodity' THEN
    -- Find max existing Batch_Number for this specific Child_PID
    SELECT NVL(MAX(c.Batch_Number), 0) INTO v_max_existing_batch_lot
    FROM commodity c JOIN productInstance pi ON c.Instance_ID = pi.Instance_ID
    WHERE pi.Product_ID = 174.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next batch

    v_expiration_date := TIMESTAMP '2024-09-04 03:14:26' + INTERVAL '385' DAY;
    v_quantity_to_create := ROUND(0.4, 1);

    INSERT INTO commodity (Instance_ID, Batch_Number, Expiration_Date, Quantity)
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Packaged' THEN
    -- Find max existing Lot_Number for this specific Child_PID
    SELECT NVL(MAX(p.Lot_Number), 0) INTO v_max_existing_batch_lot
    FROM packaged p JOIN productInstance pi ON p.Instance_ID = pi.Instance_ID -- Assuming 'packaged' table name
    WHERE pi.Product_ID = 174.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next lot

    v_expiration_date := TIMESTAMP '2024-09-04 03:14:26' + INTERVAL '172' DAY;
    v_quantity_to_create := ROUND(0.4, 1);

    INSERT INTO packaged (Instance_ID, Lot_Number, Expiration_Date, Quantity) -- Assuming 'packaged' table name
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Serialized' THEN
    -- Assign a unique serial number
    -- Using Instance ID guarantees uniqueness within this context
    v_serial_number := 'SN-' || TO_CHAR(174.0) || '-' || TO_CHAR(v_new_child_instance_id) || '-' || SUBSTR(SYS_GUID(),1,8);
    -- Assign a batch number - use Product_ID of the *parent* instance as the batch for simplicity? Or a sequence?
    -- Let's use the Parent_IID itself as a simple batch identifier for this run.
    v_batch_number := 687.0; -- All children created FOR this parent get same batch number

    INSERT INTO serialized (Instance_ID, Serial_Number, Batch_Number)
    VALUES (v_new_child_instance_id, v_serial_number, v_batch_number);

    -- Quantity for usesComponent link for serialized is typically 1
    v_quantity_to_create := 1;

  END IF;

  -- Step 3: Create the usesComponent link
  -- Quantity_Used is the Quantity_Needed from needsComponent (which matches child quantity for non-serialized)
  IF v_child_category IN ('Commodity', 'Packaged', 'Serialized') THEN -- Only insert if subtype was handled
      INSERT INTO usesComponent (Parent_IID, Child_IID, Quantity_Used)
      VALUES (687.0, v_new_child_instance_id, ROUND(0.4, 1)); -- Use rounded quantity needed
  END IF;

EXCEPTION
  WHEN OTHERS THEN
    DBMS_OUTPUT.PUT_LINE('Error processing Parent_IID=' || 687.0 || ', Child_PID=' || 174.0 || ': ' || SQLERRM);
    -- Decide if you want to rollback just this block or let the main exception handler catch it
END;
/
DECLARE
  v_new_child_instance_id productInstance.Instance_ID%TYPE;
  v_child_category        product.Category%TYPE := 'Commodity'; -- Pass category
  v_max_existing_batch_lot NUMBER;
  v_next_batch_lot_num   NUMBER;
  v_serial_number        serialized.Serial_Number%TYPE;
  v_batch_number         serialized.Batch_Number%TYPE; -- Shared batch for serialized children of *this* parent
  v_expiration_date      commodity.Expiration_Date%TYPE;
  v_quantity_to_create   commodity.Quantity%TYPE; -- Quantity for the new child instance

BEGIN
  -- Step 1: Create the new child productInstance
  INSERT INTO productInstance (Product_ID, Date_Manufactured, Is_Recalled)
  VALUES (216.0, TIMESTAMP '2024-06-12 01:55:52', 0)
  RETURNING Instance_ID INTO v_new_child_instance_id;

  -- Step 2: Create the corresponding subtype record
  IF v_child_category = 'Commodity' THEN
    -- Find max existing Batch_Number for this specific Child_PID
    SELECT NVL(MAX(c.Batch_Number), 0) INTO v_max_existing_batch_lot
    FROM commodity c JOIN productInstance pi ON c.Instance_ID = pi.Instance_ID
    WHERE pi.Product_ID = 216.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next batch

    v_expiration_date := TIMESTAMP '2024-06-12 01:55:52' + INTERVAL '286' DAY;
    v_quantity_to_create := ROUND(1.4, 1);

    INSERT INTO commodity (Instance_ID, Batch_Number, Expiration_Date, Quantity)
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Packaged' THEN
    -- Find max existing Lot_Number for this specific Child_PID
    SELECT NVL(MAX(p.Lot_Number), 0) INTO v_max_existing_batch_lot
    FROM packaged p JOIN productInstance pi ON p.Instance_ID = pi.Instance_ID -- Assuming 'packaged' table name
    WHERE pi.Product_ID = 216.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next lot

    v_expiration_date := TIMESTAMP '2024-06-12 01:55:52' + INTERVAL '176' DAY;
    v_quantity_to_create := ROUND(1.4, 1);

    INSERT INTO packaged (Instance_ID, Lot_Number, Expiration_Date, Quantity) -- Assuming 'packaged' table name
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Serialized' THEN
    -- Assign a unique serial number
    -- Using Instance ID guarantees uniqueness within this context
    v_serial_number := 'SN-' || TO_CHAR(216.0) || '-' || TO_CHAR(v_new_child_instance_id) || '-' || SUBSTR(SYS_GUID(),1,8);
    -- Assign a batch number - use Product_ID of the *parent* instance as the batch for simplicity? Or a sequence?
    -- Let's use the Parent_IID itself as a simple batch identifier for this run.
    v_batch_number := 687.0; -- All children created FOR this parent get same batch number

    INSERT INTO serialized (Instance_ID, Serial_Number, Batch_Number)
    VALUES (v_new_child_instance_id, v_serial_number, v_batch_number);

    -- Quantity for usesComponent link for serialized is typically 1
    v_quantity_to_create := 1;

  END IF;

  -- Step 3: Create the usesComponent link
  -- Quantity_Used is the Quantity_Needed from needsComponent (which matches child quantity for non-serialized)
  IF v_child_category IN ('Commodity', 'Packaged', 'Serialized') THEN -- Only insert if subtype was handled
      INSERT INTO usesComponent (Parent_IID, Child_IID, Quantity_Used)
      VALUES (687.0, v_new_child_instance_id, ROUND(1.4, 1)); -- Use rounded quantity needed
  END IF;

EXCEPTION
  WHEN OTHERS THEN
    DBMS_OUTPUT.PUT_LINE('Error processing Parent_IID=' || 687.0 || ', Child_PID=' || 216.0 || ': ' || SQLERRM);
    -- Decide if you want to rollback just this block or let the main exception handler catch it
END;
/
DECLARE
  v_new_child_instance_id productInstance.Instance_ID%TYPE;
  v_child_category        product.Category%TYPE := 'Commodity'; -- Pass category
  v_max_existing_batch_lot NUMBER;
  v_next_batch_lot_num   NUMBER;
  v_serial_number        serialized.Serial_Number%TYPE;
  v_batch_number         serialized.Batch_Number%TYPE; -- Shared batch for serialized children of *this* parent
  v_expiration_date      commodity.Expiration_Date%TYPE;
  v_quantity_to_create   commodity.Quantity%TYPE; -- Quantity for the new child instance

BEGIN
  -- Step 1: Create the new child productInstance
  INSERT INTO productInstance (Product_ID, Date_Manufactured, Is_Recalled)
  VALUES (192.0, TIMESTAMP '2025-01-18 14:13:45', 0)
  RETURNING Instance_ID INTO v_new_child_instance_id;

  -- Step 2: Create the corresponding subtype record
  IF v_child_category = 'Commodity' THEN
    -- Find max existing Batch_Number for this specific Child_PID
    SELECT NVL(MAX(c.Batch_Number), 0) INTO v_max_existing_batch_lot
    FROM commodity c JOIN productInstance pi ON c.Instance_ID = pi.Instance_ID
    WHERE pi.Product_ID = 192.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next batch

    v_expiration_date := TIMESTAMP '2025-01-18 14:13:45' + INTERVAL '617' DAY;
    v_quantity_to_create := ROUND(1.3, 1);

    INSERT INTO commodity (Instance_ID, Batch_Number, Expiration_Date, Quantity)
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Packaged' THEN
    -- Find max existing Lot_Number for this specific Child_PID
    SELECT NVL(MAX(p.Lot_Number), 0) INTO v_max_existing_batch_lot
    FROM packaged p JOIN productInstance pi ON p.Instance_ID = pi.Instance_ID -- Assuming 'packaged' table name
    WHERE pi.Product_ID = 192.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next lot

    v_expiration_date := TIMESTAMP '2025-01-18 14:13:45' + INTERVAL '72' DAY;
    v_quantity_to_create := ROUND(1.3, 1);

    INSERT INTO packaged (Instance_ID, Lot_Number, Expiration_Date, Quantity) -- Assuming 'packaged' table name
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Serialized' THEN
    -- Assign a unique serial number
    -- Using Instance ID guarantees uniqueness within this context
    v_serial_number := 'SN-' || TO_CHAR(192.0) || '-' || TO_CHAR(v_new_child_instance_id) || '-' || SUBSTR(SYS_GUID(),1,8);
    -- Assign a batch number - use Product_ID of the *parent* instance as the batch for simplicity? Or a sequence?
    -- Let's use the Parent_IID itself as a simple batch identifier for this run.
    v_batch_number := 697.0; -- All children created FOR this parent get same batch number

    INSERT INTO serialized (Instance_ID, Serial_Number, Batch_Number)
    VALUES (v_new_child_instance_id, v_serial_number, v_batch_number);

    -- Quantity for usesComponent link for serialized is typically 1
    v_quantity_to_create := 1;

  END IF;

  -- Step 3: Create the usesComponent link
  -- Quantity_Used is the Quantity_Needed from needsComponent (which matches child quantity for non-serialized)
  IF v_child_category IN ('Commodity', 'Packaged', 'Serialized') THEN -- Only insert if subtype was handled
      INSERT INTO usesComponent (Parent_IID, Child_IID, Quantity_Used)
      VALUES (697.0, v_new_child_instance_id, ROUND(1.3, 1)); -- Use rounded quantity needed
  END IF;

EXCEPTION
  WHEN OTHERS THEN
    DBMS_OUTPUT.PUT_LINE('Error processing Parent_IID=' || 697.0 || ', Child_PID=' || 192.0 || ': ' || SQLERRM);
    -- Decide if you want to rollback just this block or let the main exception handler catch it
END;
/
DECLARE
  v_new_child_instance_id productInstance.Instance_ID%TYPE;
  v_child_category        product.Category%TYPE := 'Commodity'; -- Pass category
  v_max_existing_batch_lot NUMBER;
  v_next_batch_lot_num   NUMBER;
  v_serial_number        serialized.Serial_Number%TYPE;
  v_batch_number         serialized.Batch_Number%TYPE; -- Shared batch for serialized children of *this* parent
  v_expiration_date      commodity.Expiration_Date%TYPE;
  v_quantity_to_create   commodity.Quantity%TYPE; -- Quantity for the new child instance

BEGIN
  -- Step 1: Create the new child productInstance
  INSERT INTO productInstance (Product_ID, Date_Manufactured, Is_Recalled)
  VALUES (140.0, TIMESTAMP '2024-09-10 19:15:04', 0)
  RETURNING Instance_ID INTO v_new_child_instance_id;

  -- Step 2: Create the corresponding subtype record
  IF v_child_category = 'Commodity' THEN
    -- Find max existing Batch_Number for this specific Child_PID
    SELECT NVL(MAX(c.Batch_Number), 0) INTO v_max_existing_batch_lot
    FROM commodity c JOIN productInstance pi ON c.Instance_ID = pi.Instance_ID
    WHERE pi.Product_ID = 140.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next batch

    v_expiration_date := TIMESTAMP '2024-09-10 19:15:04' + INTERVAL '109' DAY;
    v_quantity_to_create := ROUND(0.4, 1);

    INSERT INTO commodity (Instance_ID, Batch_Number, Expiration_Date, Quantity)
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Packaged' THEN
    -- Find max existing Lot_Number for this specific Child_PID
    SELECT NVL(MAX(p.Lot_Number), 0) INTO v_max_existing_batch_lot
    FROM packaged p JOIN productInstance pi ON p.Instance_ID = pi.Instance_ID -- Assuming 'packaged' table name
    WHERE pi.Product_ID = 140.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next lot

    v_expiration_date := TIMESTAMP '2024-09-10 19:15:04' + INTERVAL '124' DAY;
    v_quantity_to_create := ROUND(0.4, 1);

    INSERT INTO packaged (Instance_ID, Lot_Number, Expiration_Date, Quantity) -- Assuming 'packaged' table name
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Serialized' THEN
    -- Assign a unique serial number
    -- Using Instance ID guarantees uniqueness within this context
    v_serial_number := 'SN-' || TO_CHAR(140.0) || '-' || TO_CHAR(v_new_child_instance_id) || '-' || SUBSTR(SYS_GUID(),1,8);
    -- Assign a batch number - use Product_ID of the *parent* instance as the batch for simplicity? Or a sequence?
    -- Let's use the Parent_IID itself as a simple batch identifier for this run.
    v_batch_number := 697.0; -- All children created FOR this parent get same batch number

    INSERT INTO serialized (Instance_ID, Serial_Number, Batch_Number)
    VALUES (v_new_child_instance_id, v_serial_number, v_batch_number);

    -- Quantity for usesComponent link for serialized is typically 1
    v_quantity_to_create := 1;

  END IF;

  -- Step 3: Create the usesComponent link
  -- Quantity_Used is the Quantity_Needed from needsComponent (which matches child quantity for non-serialized)
  IF v_child_category IN ('Commodity', 'Packaged', 'Serialized') THEN -- Only insert if subtype was handled
      INSERT INTO usesComponent (Parent_IID, Child_IID, Quantity_Used)
      VALUES (697.0, v_new_child_instance_id, ROUND(0.4, 1)); -- Use rounded quantity needed
  END IF;

EXCEPTION
  WHEN OTHERS THEN
    DBMS_OUTPUT.PUT_LINE('Error processing Parent_IID=' || 697.0 || ', Child_PID=' || 140.0 || ': ' || SQLERRM);
    -- Decide if you want to rollback just this block or let the main exception handler catch it
END;
/
DECLARE
  v_new_child_instance_id productInstance.Instance_ID%TYPE;
  v_child_category        product.Category%TYPE := 'Commodity'; -- Pass category
  v_max_existing_batch_lot NUMBER;
  v_next_batch_lot_num   NUMBER;
  v_serial_number        serialized.Serial_Number%TYPE;
  v_batch_number         serialized.Batch_Number%TYPE; -- Shared batch for serialized children of *this* parent
  v_expiration_date      commodity.Expiration_Date%TYPE;
  v_quantity_to_create   commodity.Quantity%TYPE; -- Quantity for the new child instance

BEGIN
  -- Step 1: Create the new child productInstance
  INSERT INTO productInstance (Product_ID, Date_Manufactured, Is_Recalled)
  VALUES (161.0, TIMESTAMP '2025-02-04 13:47:28', 0)
  RETURNING Instance_ID INTO v_new_child_instance_id;

  -- Step 2: Create the corresponding subtype record
  IF v_child_category = 'Commodity' THEN
    -- Find max existing Batch_Number for this specific Child_PID
    SELECT NVL(MAX(c.Batch_Number), 0) INTO v_max_existing_batch_lot
    FROM commodity c JOIN productInstance pi ON c.Instance_ID = pi.Instance_ID
    WHERE pi.Product_ID = 161.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next batch

    v_expiration_date := TIMESTAMP '2025-02-04 13:47:28' + INTERVAL '135' DAY;
    v_quantity_to_create := ROUND(0.5, 1);

    INSERT INTO commodity (Instance_ID, Batch_Number, Expiration_Date, Quantity)
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Packaged' THEN
    -- Find max existing Lot_Number for this specific Child_PID
    SELECT NVL(MAX(p.Lot_Number), 0) INTO v_max_existing_batch_lot
    FROM packaged p JOIN productInstance pi ON p.Instance_ID = pi.Instance_ID -- Assuming 'packaged' table name
    WHERE pi.Product_ID = 161.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next lot

    v_expiration_date := TIMESTAMP '2025-02-04 13:47:28' + INTERVAL '337' DAY;
    v_quantity_to_create := ROUND(0.5, 1);

    INSERT INTO packaged (Instance_ID, Lot_Number, Expiration_Date, Quantity) -- Assuming 'packaged' table name
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Serialized' THEN
    -- Assign a unique serial number
    -- Using Instance ID guarantees uniqueness within this context
    v_serial_number := 'SN-' || TO_CHAR(161.0) || '-' || TO_CHAR(v_new_child_instance_id) || '-' || SUBSTR(SYS_GUID(),1,8);
    -- Assign a batch number - use Product_ID of the *parent* instance as the batch for simplicity? Or a sequence?
    -- Let's use the Parent_IID itself as a simple batch identifier for this run.
    v_batch_number := 697.0; -- All children created FOR this parent get same batch number

    INSERT INTO serialized (Instance_ID, Serial_Number, Batch_Number)
    VALUES (v_new_child_instance_id, v_serial_number, v_batch_number);

    -- Quantity for usesComponent link for serialized is typically 1
    v_quantity_to_create := 1;

  END IF;

  -- Step 3: Create the usesComponent link
  -- Quantity_Used is the Quantity_Needed from needsComponent (which matches child quantity for non-serialized)
  IF v_child_category IN ('Commodity', 'Packaged', 'Serialized') THEN -- Only insert if subtype was handled
      INSERT INTO usesComponent (Parent_IID, Child_IID, Quantity_Used)
      VALUES (697.0, v_new_child_instance_id, ROUND(0.5, 1)); -- Use rounded quantity needed
  END IF;

EXCEPTION
  WHEN OTHERS THEN
    DBMS_OUTPUT.PUT_LINE('Error processing Parent_IID=' || 697.0 || ', Child_PID=' || 161.0 || ': ' || SQLERRM);
    -- Decide if you want to rollback just this block or let the main exception handler catch it
END;
/
DECLARE
  v_new_child_instance_id productInstance.Instance_ID%TYPE;
  v_child_category        product.Category%TYPE := 'Commodity'; -- Pass category
  v_max_existing_batch_lot NUMBER;
  v_next_batch_lot_num   NUMBER;
  v_serial_number        serialized.Serial_Number%TYPE;
  v_batch_number         serialized.Batch_Number%TYPE; -- Shared batch for serialized children of *this* parent
  v_expiration_date      commodity.Expiration_Date%TYPE;
  v_quantity_to_create   commodity.Quantity%TYPE; -- Quantity for the new child instance

BEGIN
  -- Step 1: Create the new child productInstance
  INSERT INTO productInstance (Product_ID, Date_Manufactured, Is_Recalled)
  VALUES (168.0, TIMESTAMP '2024-08-30 03:48:05', 0)
  RETURNING Instance_ID INTO v_new_child_instance_id;

  -- Step 2: Create the corresponding subtype record
  IF v_child_category = 'Commodity' THEN
    -- Find max existing Batch_Number for this specific Child_PID
    SELECT NVL(MAX(c.Batch_Number), 0) INTO v_max_existing_batch_lot
    FROM commodity c JOIN productInstance pi ON c.Instance_ID = pi.Instance_ID
    WHERE pi.Product_ID = 168.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next batch

    v_expiration_date := TIMESTAMP '2024-08-30 03:48:05' + INTERVAL '284' DAY;
    v_quantity_to_create := ROUND(0.1, 1);

    INSERT INTO commodity (Instance_ID, Batch_Number, Expiration_Date, Quantity)
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Packaged' THEN
    -- Find max existing Lot_Number for this specific Child_PID
    SELECT NVL(MAX(p.Lot_Number), 0) INTO v_max_existing_batch_lot
    FROM packaged p JOIN productInstance pi ON p.Instance_ID = pi.Instance_ID -- Assuming 'packaged' table name
    WHERE pi.Product_ID = 168.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next lot

    v_expiration_date := TIMESTAMP '2024-08-30 03:48:05' + INTERVAL '305' DAY;
    v_quantity_to_create := ROUND(0.1, 1);

    INSERT INTO packaged (Instance_ID, Lot_Number, Expiration_Date, Quantity) -- Assuming 'packaged' table name
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Serialized' THEN
    -- Assign a unique serial number
    -- Using Instance ID guarantees uniqueness within this context
    v_serial_number := 'SN-' || TO_CHAR(168.0) || '-' || TO_CHAR(v_new_child_instance_id) || '-' || SUBSTR(SYS_GUID(),1,8);
    -- Assign a batch number - use Product_ID of the *parent* instance as the batch for simplicity? Or a sequence?
    -- Let's use the Parent_IID itself as a simple batch identifier for this run.
    v_batch_number := 697.0; -- All children created FOR this parent get same batch number

    INSERT INTO serialized (Instance_ID, Serial_Number, Batch_Number)
    VALUES (v_new_child_instance_id, v_serial_number, v_batch_number);

    -- Quantity for usesComponent link for serialized is typically 1
    v_quantity_to_create := 1;

  END IF;

  -- Step 3: Create the usesComponent link
  -- Quantity_Used is the Quantity_Needed from needsComponent (which matches child quantity for non-serialized)
  IF v_child_category IN ('Commodity', 'Packaged', 'Serialized') THEN -- Only insert if subtype was handled
      INSERT INTO usesComponent (Parent_IID, Child_IID, Quantity_Used)
      VALUES (697.0, v_new_child_instance_id, ROUND(0.1, 1)); -- Use rounded quantity needed
  END IF;

EXCEPTION
  WHEN OTHERS THEN
    DBMS_OUTPUT.PUT_LINE('Error processing Parent_IID=' || 697.0 || ', Child_PID=' || 168.0 || ': ' || SQLERRM);
    -- Decide if you want to rollback just this block or let the main exception handler catch it
END;
/
DECLARE
  v_new_child_instance_id productInstance.Instance_ID%TYPE;
  v_child_category        product.Category%TYPE := 'Commodity'; -- Pass category
  v_max_existing_batch_lot NUMBER;
  v_next_batch_lot_num   NUMBER;
  v_serial_number        serialized.Serial_Number%TYPE;
  v_batch_number         serialized.Batch_Number%TYPE; -- Shared batch for serialized children of *this* parent
  v_expiration_date      commodity.Expiration_Date%TYPE;
  v_quantity_to_create   commodity.Quantity%TYPE; -- Quantity for the new child instance

BEGIN
  -- Step 1: Create the new child productInstance
  INSERT INTO productInstance (Product_ID, Date_Manufactured, Is_Recalled)
  VALUES (192.0, TIMESTAMP '2024-11-20 17:26:32', 0)
  RETURNING Instance_ID INTO v_new_child_instance_id;

  -- Step 2: Create the corresponding subtype record
  IF v_child_category = 'Commodity' THEN
    -- Find max existing Batch_Number for this specific Child_PID
    SELECT NVL(MAX(c.Batch_Number), 0) INTO v_max_existing_batch_lot
    FROM commodity c JOIN productInstance pi ON c.Instance_ID = pi.Instance_ID
    WHERE pi.Product_ID = 192.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next batch

    v_expiration_date := TIMESTAMP '2024-11-20 17:26:32' + INTERVAL '80' DAY;
    v_quantity_to_create := ROUND(1.3, 1);

    INSERT INTO commodity (Instance_ID, Batch_Number, Expiration_Date, Quantity)
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Packaged' THEN
    -- Find max existing Lot_Number for this specific Child_PID
    SELECT NVL(MAX(p.Lot_Number), 0) INTO v_max_existing_batch_lot
    FROM packaged p JOIN productInstance pi ON p.Instance_ID = pi.Instance_ID -- Assuming 'packaged' table name
    WHERE pi.Product_ID = 192.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next lot

    v_expiration_date := TIMESTAMP '2024-11-20 17:26:32' + INTERVAL '400' DAY;
    v_quantity_to_create := ROUND(1.3, 1);

    INSERT INTO packaged (Instance_ID, Lot_Number, Expiration_Date, Quantity) -- Assuming 'packaged' table name
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Serialized' THEN
    -- Assign a unique serial number
    -- Using Instance ID guarantees uniqueness within this context
    v_serial_number := 'SN-' || TO_CHAR(192.0) || '-' || TO_CHAR(v_new_child_instance_id) || '-' || SUBSTR(SYS_GUID(),1,8);
    -- Assign a batch number - use Product_ID of the *parent* instance as the batch for simplicity? Or a sequence?
    -- Let's use the Parent_IID itself as a simple batch identifier for this run.
    v_batch_number := 698.0; -- All children created FOR this parent get same batch number

    INSERT INTO serialized (Instance_ID, Serial_Number, Batch_Number)
    VALUES (v_new_child_instance_id, v_serial_number, v_batch_number);

    -- Quantity for usesComponent link for serialized is typically 1
    v_quantity_to_create := 1;

  END IF;

  -- Step 3: Create the usesComponent link
  -- Quantity_Used is the Quantity_Needed from needsComponent (which matches child quantity for non-serialized)
  IF v_child_category IN ('Commodity', 'Packaged', 'Serialized') THEN -- Only insert if subtype was handled
      INSERT INTO usesComponent (Parent_IID, Child_IID, Quantity_Used)
      VALUES (698.0, v_new_child_instance_id, ROUND(1.3, 1)); -- Use rounded quantity needed
  END IF;

EXCEPTION
  WHEN OTHERS THEN
    DBMS_OUTPUT.PUT_LINE('Error processing Parent_IID=' || 698.0 || ', Child_PID=' || 192.0 || ': ' || SQLERRM);
    -- Decide if you want to rollback just this block or let the main exception handler catch it
END;
/
DECLARE
  v_new_child_instance_id productInstance.Instance_ID%TYPE;
  v_child_category        product.Category%TYPE := 'Commodity'; -- Pass category
  v_max_existing_batch_lot NUMBER;
  v_next_batch_lot_num   NUMBER;
  v_serial_number        serialized.Serial_Number%TYPE;
  v_batch_number         serialized.Batch_Number%TYPE; -- Shared batch for serialized children of *this* parent
  v_expiration_date      commodity.Expiration_Date%TYPE;
  v_quantity_to_create   commodity.Quantity%TYPE; -- Quantity for the new child instance

BEGIN
  -- Step 1: Create the new child productInstance
  INSERT INTO productInstance (Product_ID, Date_Manufactured, Is_Recalled)
  VALUES (140.0, TIMESTAMP '2024-05-11 03:29:10', 0)
  RETURNING Instance_ID INTO v_new_child_instance_id;

  -- Step 2: Create the corresponding subtype record
  IF v_child_category = 'Commodity' THEN
    -- Find max existing Batch_Number for this specific Child_PID
    SELECT NVL(MAX(c.Batch_Number), 0) INTO v_max_existing_batch_lot
    FROM commodity c JOIN productInstance pi ON c.Instance_ID = pi.Instance_ID
    WHERE pi.Product_ID = 140.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next batch

    v_expiration_date := TIMESTAMP '2024-05-11 03:29:10' + INTERVAL '110' DAY;
    v_quantity_to_create := ROUND(0.4, 1);

    INSERT INTO commodity (Instance_ID, Batch_Number, Expiration_Date, Quantity)
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Packaged' THEN
    -- Find max existing Lot_Number for this specific Child_PID
    SELECT NVL(MAX(p.Lot_Number), 0) INTO v_max_existing_batch_lot
    FROM packaged p JOIN productInstance pi ON p.Instance_ID = pi.Instance_ID -- Assuming 'packaged' table name
    WHERE pi.Product_ID = 140.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next lot

    v_expiration_date := TIMESTAMP '2024-05-11 03:29:10' + INTERVAL '172' DAY;
    v_quantity_to_create := ROUND(0.4, 1);

    INSERT INTO packaged (Instance_ID, Lot_Number, Expiration_Date, Quantity) -- Assuming 'packaged' table name
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Serialized' THEN
    -- Assign a unique serial number
    -- Using Instance ID guarantees uniqueness within this context
    v_serial_number := 'SN-' || TO_CHAR(140.0) || '-' || TO_CHAR(v_new_child_instance_id) || '-' || SUBSTR(SYS_GUID(),1,8);
    -- Assign a batch number - use Product_ID of the *parent* instance as the batch for simplicity? Or a sequence?
    -- Let's use the Parent_IID itself as a simple batch identifier for this run.
    v_batch_number := 698.0; -- All children created FOR this parent get same batch number

    INSERT INTO serialized (Instance_ID, Serial_Number, Batch_Number)
    VALUES (v_new_child_instance_id, v_serial_number, v_batch_number);

    -- Quantity for usesComponent link for serialized is typically 1
    v_quantity_to_create := 1;

  END IF;

  -- Step 3: Create the usesComponent link
  -- Quantity_Used is the Quantity_Needed from needsComponent (which matches child quantity for non-serialized)
  IF v_child_category IN ('Commodity', 'Packaged', 'Serialized') THEN -- Only insert if subtype was handled
      INSERT INTO usesComponent (Parent_IID, Child_IID, Quantity_Used)
      VALUES (698.0, v_new_child_instance_id, ROUND(0.4, 1)); -- Use rounded quantity needed
  END IF;

EXCEPTION
  WHEN OTHERS THEN
    DBMS_OUTPUT.PUT_LINE('Error processing Parent_IID=' || 698.0 || ', Child_PID=' || 140.0 || ': ' || SQLERRM);
    -- Decide if you want to rollback just this block or let the main exception handler catch it
END;
/
DECLARE
  v_new_child_instance_id productInstance.Instance_ID%TYPE;
  v_child_category        product.Category%TYPE := 'Commodity'; -- Pass category
  v_max_existing_batch_lot NUMBER;
  v_next_batch_lot_num   NUMBER;
  v_serial_number        serialized.Serial_Number%TYPE;
  v_batch_number         serialized.Batch_Number%TYPE; -- Shared batch for serialized children of *this* parent
  v_expiration_date      commodity.Expiration_Date%TYPE;
  v_quantity_to_create   commodity.Quantity%TYPE; -- Quantity for the new child instance

BEGIN
  -- Step 1: Create the new child productInstance
  INSERT INTO productInstance (Product_ID, Date_Manufactured, Is_Recalled)
  VALUES (161.0, TIMESTAMP '2025-04-23 13:41:12', 0)
  RETURNING Instance_ID INTO v_new_child_instance_id;

  -- Step 2: Create the corresponding subtype record
  IF v_child_category = 'Commodity' THEN
    -- Find max existing Batch_Number for this specific Child_PID
    SELECT NVL(MAX(c.Batch_Number), 0) INTO v_max_existing_batch_lot
    FROM commodity c JOIN productInstance pi ON c.Instance_ID = pi.Instance_ID
    WHERE pi.Product_ID = 161.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next batch

    v_expiration_date := TIMESTAMP '2025-04-23 13:41:12' + INTERVAL '438' DAY;
    v_quantity_to_create := ROUND(0.5, 1);

    INSERT INTO commodity (Instance_ID, Batch_Number, Expiration_Date, Quantity)
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Packaged' THEN
    -- Find max existing Lot_Number for this specific Child_PID
    SELECT NVL(MAX(p.Lot_Number), 0) INTO v_max_existing_batch_lot
    FROM packaged p JOIN productInstance pi ON p.Instance_ID = pi.Instance_ID -- Assuming 'packaged' table name
    WHERE pi.Product_ID = 161.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next lot

    v_expiration_date := TIMESTAMP '2025-04-23 13:41:12' + INTERVAL '410' DAY;
    v_quantity_to_create := ROUND(0.5, 1);

    INSERT INTO packaged (Instance_ID, Lot_Number, Expiration_Date, Quantity) -- Assuming 'packaged' table name
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Serialized' THEN
    -- Assign a unique serial number
    -- Using Instance ID guarantees uniqueness within this context
    v_serial_number := 'SN-' || TO_CHAR(161.0) || '-' || TO_CHAR(v_new_child_instance_id) || '-' || SUBSTR(SYS_GUID(),1,8);
    -- Assign a batch number - use Product_ID of the *parent* instance as the batch for simplicity? Or a sequence?
    -- Let's use the Parent_IID itself as a simple batch identifier for this run.
    v_batch_number := 698.0; -- All children created FOR this parent get same batch number

    INSERT INTO serialized (Instance_ID, Serial_Number, Batch_Number)
    VALUES (v_new_child_instance_id, v_serial_number, v_batch_number);

    -- Quantity for usesComponent link for serialized is typically 1
    v_quantity_to_create := 1;

  END IF;

  -- Step 3: Create the usesComponent link
  -- Quantity_Used is the Quantity_Needed from needsComponent (which matches child quantity for non-serialized)
  IF v_child_category IN ('Commodity', 'Packaged', 'Serialized') THEN -- Only insert if subtype was handled
      INSERT INTO usesComponent (Parent_IID, Child_IID, Quantity_Used)
      VALUES (698.0, v_new_child_instance_id, ROUND(0.5, 1)); -- Use rounded quantity needed
  END IF;

EXCEPTION
  WHEN OTHERS THEN
    DBMS_OUTPUT.PUT_LINE('Error processing Parent_IID=' || 698.0 || ', Child_PID=' || 161.0 || ': ' || SQLERRM);
    -- Decide if you want to rollback just this block or let the main exception handler catch it
END;
/
DECLARE
  v_new_child_instance_id productInstance.Instance_ID%TYPE;
  v_child_category        product.Category%TYPE := 'Commodity'; -- Pass category
  v_max_existing_batch_lot NUMBER;
  v_next_batch_lot_num   NUMBER;
  v_serial_number        serialized.Serial_Number%TYPE;
  v_batch_number         serialized.Batch_Number%TYPE; -- Shared batch for serialized children of *this* parent
  v_expiration_date      commodity.Expiration_Date%TYPE;
  v_quantity_to_create   commodity.Quantity%TYPE; -- Quantity for the new child instance

BEGIN
  -- Step 1: Create the new child productInstance
  INSERT INTO productInstance (Product_ID, Date_Manufactured, Is_Recalled)
  VALUES (168.0, TIMESTAMP '2025-04-26 15:43:45', 0)
  RETURNING Instance_ID INTO v_new_child_instance_id;

  -- Step 2: Create the corresponding subtype record
  IF v_child_category = 'Commodity' THEN
    -- Find max existing Batch_Number for this specific Child_PID
    SELECT NVL(MAX(c.Batch_Number), 0) INTO v_max_existing_batch_lot
    FROM commodity c JOIN productInstance pi ON c.Instance_ID = pi.Instance_ID
    WHERE pi.Product_ID = 168.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next batch

    v_expiration_date := TIMESTAMP '2025-04-26 15:43:45' + INTERVAL '683' DAY;
    v_quantity_to_create := ROUND(0.1, 1);

    INSERT INTO commodity (Instance_ID, Batch_Number, Expiration_Date, Quantity)
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Packaged' THEN
    -- Find max existing Lot_Number for this specific Child_PID
    SELECT NVL(MAX(p.Lot_Number), 0) INTO v_max_existing_batch_lot
    FROM packaged p JOIN productInstance pi ON p.Instance_ID = pi.Instance_ID -- Assuming 'packaged' table name
    WHERE pi.Product_ID = 168.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next lot

    v_expiration_date := TIMESTAMP '2025-04-26 15:43:45' + INTERVAL '277' DAY;
    v_quantity_to_create := ROUND(0.1, 1);

    INSERT INTO packaged (Instance_ID, Lot_Number, Expiration_Date, Quantity) -- Assuming 'packaged' table name
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Serialized' THEN
    -- Assign a unique serial number
    -- Using Instance ID guarantees uniqueness within this context
    v_serial_number := 'SN-' || TO_CHAR(168.0) || '-' || TO_CHAR(v_new_child_instance_id) || '-' || SUBSTR(SYS_GUID(),1,8);
    -- Assign a batch number - use Product_ID of the *parent* instance as the batch for simplicity? Or a sequence?
    -- Let's use the Parent_IID itself as a simple batch identifier for this run.
    v_batch_number := 698.0; -- All children created FOR this parent get same batch number

    INSERT INTO serialized (Instance_ID, Serial_Number, Batch_Number)
    VALUES (v_new_child_instance_id, v_serial_number, v_batch_number);

    -- Quantity for usesComponent link for serialized is typically 1
    v_quantity_to_create := 1;

  END IF;

  -- Step 3: Create the usesComponent link
  -- Quantity_Used is the Quantity_Needed from needsComponent (which matches child quantity for non-serialized)
  IF v_child_category IN ('Commodity', 'Packaged', 'Serialized') THEN -- Only insert if subtype was handled
      INSERT INTO usesComponent (Parent_IID, Child_IID, Quantity_Used)
      VALUES (698.0, v_new_child_instance_id, ROUND(0.1, 1)); -- Use rounded quantity needed
  END IF;

EXCEPTION
  WHEN OTHERS THEN
    DBMS_OUTPUT.PUT_LINE('Error processing Parent_IID=' || 698.0 || ', Child_PID=' || 168.0 || ': ' || SQLERRM);
    -- Decide if you want to rollback just this block or let the main exception handler catch it
END;
/
DECLARE
  v_new_child_instance_id productInstance.Instance_ID%TYPE;
  v_child_category        product.Category%TYPE := 'Commodity'; -- Pass category
  v_max_existing_batch_lot NUMBER;
  v_next_batch_lot_num   NUMBER;
  v_serial_number        serialized.Serial_Number%TYPE;
  v_batch_number         serialized.Batch_Number%TYPE; -- Shared batch for serialized children of *this* parent
  v_expiration_date      commodity.Expiration_Date%TYPE;
  v_quantity_to_create   commodity.Quantity%TYPE; -- Quantity for the new child instance

BEGIN
  -- Step 1: Create the new child productInstance
  INSERT INTO productInstance (Product_ID, Date_Manufactured, Is_Recalled)
  VALUES (192.0, TIMESTAMP '2024-06-04 11:48:41', 0)
  RETURNING Instance_ID INTO v_new_child_instance_id;

  -- Step 2: Create the corresponding subtype record
  IF v_child_category = 'Commodity' THEN
    -- Find max existing Batch_Number for this specific Child_PID
    SELECT NVL(MAX(c.Batch_Number), 0) INTO v_max_existing_batch_lot
    FROM commodity c JOIN productInstance pi ON c.Instance_ID = pi.Instance_ID
    WHERE pi.Product_ID = 192.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next batch

    v_expiration_date := TIMESTAMP '2024-06-04 11:48:41' + INTERVAL '725' DAY;
    v_quantity_to_create := ROUND(1.3, 1);

    INSERT INTO commodity (Instance_ID, Batch_Number, Expiration_Date, Quantity)
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Packaged' THEN
    -- Find max existing Lot_Number for this specific Child_PID
    SELECT NVL(MAX(p.Lot_Number), 0) INTO v_max_existing_batch_lot
    FROM packaged p JOIN productInstance pi ON p.Instance_ID = pi.Instance_ID -- Assuming 'packaged' table name
    WHERE pi.Product_ID = 192.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next lot

    v_expiration_date := TIMESTAMP '2024-06-04 11:48:41' + INTERVAL '366' DAY;
    v_quantity_to_create := ROUND(1.3, 1);

    INSERT INTO packaged (Instance_ID, Lot_Number, Expiration_Date, Quantity) -- Assuming 'packaged' table name
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Serialized' THEN
    -- Assign a unique serial number
    -- Using Instance ID guarantees uniqueness within this context
    v_serial_number := 'SN-' || TO_CHAR(192.0) || '-' || TO_CHAR(v_new_child_instance_id) || '-' || SUBSTR(SYS_GUID(),1,8);
    -- Assign a batch number - use Product_ID of the *parent* instance as the batch for simplicity? Or a sequence?
    -- Let's use the Parent_IID itself as a simple batch identifier for this run.
    v_batch_number := 699.0; -- All children created FOR this parent get same batch number

    INSERT INTO serialized (Instance_ID, Serial_Number, Batch_Number)
    VALUES (v_new_child_instance_id, v_serial_number, v_batch_number);

    -- Quantity for usesComponent link for serialized is typically 1
    v_quantity_to_create := 1;

  END IF;

  -- Step 3: Create the usesComponent link
  -- Quantity_Used is the Quantity_Needed from needsComponent (which matches child quantity for non-serialized)
  IF v_child_category IN ('Commodity', 'Packaged', 'Serialized') THEN -- Only insert if subtype was handled
      INSERT INTO usesComponent (Parent_IID, Child_IID, Quantity_Used)
      VALUES (699.0, v_new_child_instance_id, ROUND(1.3, 1)); -- Use rounded quantity needed
  END IF;

EXCEPTION
  WHEN OTHERS THEN
    DBMS_OUTPUT.PUT_LINE('Error processing Parent_IID=' || 699.0 || ', Child_PID=' || 192.0 || ': ' || SQLERRM);
    -- Decide if you want to rollback just this block or let the main exception handler catch it
END;
/
DECLARE
  v_new_child_instance_id productInstance.Instance_ID%TYPE;
  v_child_category        product.Category%TYPE := 'Commodity'; -- Pass category
  v_max_existing_batch_lot NUMBER;
  v_next_batch_lot_num   NUMBER;
  v_serial_number        serialized.Serial_Number%TYPE;
  v_batch_number         serialized.Batch_Number%TYPE; -- Shared batch for serialized children of *this* parent
  v_expiration_date      commodity.Expiration_Date%TYPE;
  v_quantity_to_create   commodity.Quantity%TYPE; -- Quantity for the new child instance

BEGIN
  -- Step 1: Create the new child productInstance
  INSERT INTO productInstance (Product_ID, Date_Manufactured, Is_Recalled)
  VALUES (140.0, TIMESTAMP '2024-08-13 07:24:26', 0)
  RETURNING Instance_ID INTO v_new_child_instance_id;

  -- Step 2: Create the corresponding subtype record
  IF v_child_category = 'Commodity' THEN
    -- Find max existing Batch_Number for this specific Child_PID
    SELECT NVL(MAX(c.Batch_Number), 0) INTO v_max_existing_batch_lot
    FROM commodity c JOIN productInstance pi ON c.Instance_ID = pi.Instance_ID
    WHERE pi.Product_ID = 140.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next batch

    v_expiration_date := TIMESTAMP '2024-08-13 07:24:26' + INTERVAL '38' DAY;
    v_quantity_to_create := ROUND(0.4, 1);

    INSERT INTO commodity (Instance_ID, Batch_Number, Expiration_Date, Quantity)
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Packaged' THEN
    -- Find max existing Lot_Number for this specific Child_PID
    SELECT NVL(MAX(p.Lot_Number), 0) INTO v_max_existing_batch_lot
    FROM packaged p JOIN productInstance pi ON p.Instance_ID = pi.Instance_ID -- Assuming 'packaged' table name
    WHERE pi.Product_ID = 140.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next lot

    v_expiration_date := TIMESTAMP '2024-08-13 07:24:26' + INTERVAL '557' DAY;
    v_quantity_to_create := ROUND(0.4, 1);

    INSERT INTO packaged (Instance_ID, Lot_Number, Expiration_Date, Quantity) -- Assuming 'packaged' table name
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Serialized' THEN
    -- Assign a unique serial number
    -- Using Instance ID guarantees uniqueness within this context
    v_serial_number := 'SN-' || TO_CHAR(140.0) || '-' || TO_CHAR(v_new_child_instance_id) || '-' || SUBSTR(SYS_GUID(),1,8);
    -- Assign a batch number - use Product_ID of the *parent* instance as the batch for simplicity? Or a sequence?
    -- Let's use the Parent_IID itself as a simple batch identifier for this run.
    v_batch_number := 699.0; -- All children created FOR this parent get same batch number

    INSERT INTO serialized (Instance_ID, Serial_Number, Batch_Number)
    VALUES (v_new_child_instance_id, v_serial_number, v_batch_number);

    -- Quantity for usesComponent link for serialized is typically 1
    v_quantity_to_create := 1;

  END IF;

  -- Step 3: Create the usesComponent link
  -- Quantity_Used is the Quantity_Needed from needsComponent (which matches child quantity for non-serialized)
  IF v_child_category IN ('Commodity', 'Packaged', 'Serialized') THEN -- Only insert if subtype was handled
      INSERT INTO usesComponent (Parent_IID, Child_IID, Quantity_Used)
      VALUES (699.0, v_new_child_instance_id, ROUND(0.4, 1)); -- Use rounded quantity needed
  END IF;

EXCEPTION
  WHEN OTHERS THEN
    DBMS_OUTPUT.PUT_LINE('Error processing Parent_IID=' || 699.0 || ', Child_PID=' || 140.0 || ': ' || SQLERRM);
    -- Decide if you want to rollback just this block or let the main exception handler catch it
END;
/
DECLARE
  v_new_child_instance_id productInstance.Instance_ID%TYPE;
  v_child_category        product.Category%TYPE := 'Commodity'; -- Pass category
  v_max_existing_batch_lot NUMBER;
  v_next_batch_lot_num   NUMBER;
  v_serial_number        serialized.Serial_Number%TYPE;
  v_batch_number         serialized.Batch_Number%TYPE; -- Shared batch for serialized children of *this* parent
  v_expiration_date      commodity.Expiration_Date%TYPE;
  v_quantity_to_create   commodity.Quantity%TYPE; -- Quantity for the new child instance

BEGIN
  -- Step 1: Create the new child productInstance
  INSERT INTO productInstance (Product_ID, Date_Manufactured, Is_Recalled)
  VALUES (161.0, TIMESTAMP '2025-04-08 23:30:41', 0)
  RETURNING Instance_ID INTO v_new_child_instance_id;

  -- Step 2: Create the corresponding subtype record
  IF v_child_category = 'Commodity' THEN
    -- Find max existing Batch_Number for this specific Child_PID
    SELECT NVL(MAX(c.Batch_Number), 0) INTO v_max_existing_batch_lot
    FROM commodity c JOIN productInstance pi ON c.Instance_ID = pi.Instance_ID
    WHERE pi.Product_ID = 161.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next batch

    v_expiration_date := TIMESTAMP '2025-04-08 23:30:41' + INTERVAL '359' DAY;
    v_quantity_to_create := ROUND(0.5, 1);

    INSERT INTO commodity (Instance_ID, Batch_Number, Expiration_Date, Quantity)
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Packaged' THEN
    -- Find max existing Lot_Number for this specific Child_PID
    SELECT NVL(MAX(p.Lot_Number), 0) INTO v_max_existing_batch_lot
    FROM packaged p JOIN productInstance pi ON p.Instance_ID = pi.Instance_ID -- Assuming 'packaged' table name
    WHERE pi.Product_ID = 161.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next lot

    v_expiration_date := TIMESTAMP '2025-04-08 23:30:41' + INTERVAL '144' DAY;
    v_quantity_to_create := ROUND(0.5, 1);

    INSERT INTO packaged (Instance_ID, Lot_Number, Expiration_Date, Quantity) -- Assuming 'packaged' table name
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Serialized' THEN
    -- Assign a unique serial number
    -- Using Instance ID guarantees uniqueness within this context
    v_serial_number := 'SN-' || TO_CHAR(161.0) || '-' || TO_CHAR(v_new_child_instance_id) || '-' || SUBSTR(SYS_GUID(),1,8);
    -- Assign a batch number - use Product_ID of the *parent* instance as the batch for simplicity? Or a sequence?
    -- Let's use the Parent_IID itself as a simple batch identifier for this run.
    v_batch_number := 699.0; -- All children created FOR this parent get same batch number

    INSERT INTO serialized (Instance_ID, Serial_Number, Batch_Number)
    VALUES (v_new_child_instance_id, v_serial_number, v_batch_number);

    -- Quantity for usesComponent link for serialized is typically 1
    v_quantity_to_create := 1;

  END IF;

  -- Step 3: Create the usesComponent link
  -- Quantity_Used is the Quantity_Needed from needsComponent (which matches child quantity for non-serialized)
  IF v_child_category IN ('Commodity', 'Packaged', 'Serialized') THEN -- Only insert if subtype was handled
      INSERT INTO usesComponent (Parent_IID, Child_IID, Quantity_Used)
      VALUES (699.0, v_new_child_instance_id, ROUND(0.5, 1)); -- Use rounded quantity needed
  END IF;

EXCEPTION
  WHEN OTHERS THEN
    DBMS_OUTPUT.PUT_LINE('Error processing Parent_IID=' || 699.0 || ', Child_PID=' || 161.0 || ': ' || SQLERRM);
    -- Decide if you want to rollback just this block or let the main exception handler catch it
END;
/
DECLARE
  v_new_child_instance_id productInstance.Instance_ID%TYPE;
  v_child_category        product.Category%TYPE := 'Commodity'; -- Pass category
  v_max_existing_batch_lot NUMBER;
  v_next_batch_lot_num   NUMBER;
  v_serial_number        serialized.Serial_Number%TYPE;
  v_batch_number         serialized.Batch_Number%TYPE; -- Shared batch for serialized children of *this* parent
  v_expiration_date      commodity.Expiration_Date%TYPE;
  v_quantity_to_create   commodity.Quantity%TYPE; -- Quantity for the new child instance

BEGIN
  -- Step 1: Create the new child productInstance
  INSERT INTO productInstance (Product_ID, Date_Manufactured, Is_Recalled)
  VALUES (168.0, TIMESTAMP '2024-09-12 21:13:04', 0)
  RETURNING Instance_ID INTO v_new_child_instance_id;

  -- Step 2: Create the corresponding subtype record
  IF v_child_category = 'Commodity' THEN
    -- Find max existing Batch_Number for this specific Child_PID
    SELECT NVL(MAX(c.Batch_Number), 0) INTO v_max_existing_batch_lot
    FROM commodity c JOIN productInstance pi ON c.Instance_ID = pi.Instance_ID
    WHERE pi.Product_ID = 168.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next batch

    v_expiration_date := TIMESTAMP '2024-09-12 21:13:04' + INTERVAL '686' DAY;
    v_quantity_to_create := ROUND(0.1, 1);

    INSERT INTO commodity (Instance_ID, Batch_Number, Expiration_Date, Quantity)
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Packaged' THEN
    -- Find max existing Lot_Number for this specific Child_PID
    SELECT NVL(MAX(p.Lot_Number), 0) INTO v_max_existing_batch_lot
    FROM packaged p JOIN productInstance pi ON p.Instance_ID = pi.Instance_ID -- Assuming 'packaged' table name
    WHERE pi.Product_ID = 168.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next lot

    v_expiration_date := TIMESTAMP '2024-09-12 21:13:04' + INTERVAL '158' DAY;
    v_quantity_to_create := ROUND(0.1, 1);

    INSERT INTO packaged (Instance_ID, Lot_Number, Expiration_Date, Quantity) -- Assuming 'packaged' table name
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Serialized' THEN
    -- Assign a unique serial number
    -- Using Instance ID guarantees uniqueness within this context
    v_serial_number := 'SN-' || TO_CHAR(168.0) || '-' || TO_CHAR(v_new_child_instance_id) || '-' || SUBSTR(SYS_GUID(),1,8);
    -- Assign a batch number - use Product_ID of the *parent* instance as the batch for simplicity? Or a sequence?
    -- Let's use the Parent_IID itself as a simple batch identifier for this run.
    v_batch_number := 699.0; -- All children created FOR this parent get same batch number

    INSERT INTO serialized (Instance_ID, Serial_Number, Batch_Number)
    VALUES (v_new_child_instance_id, v_serial_number, v_batch_number);

    -- Quantity for usesComponent link for serialized is typically 1
    v_quantity_to_create := 1;

  END IF;

  -- Step 3: Create the usesComponent link
  -- Quantity_Used is the Quantity_Needed from needsComponent (which matches child quantity for non-serialized)
  IF v_child_category IN ('Commodity', 'Packaged', 'Serialized') THEN -- Only insert if subtype was handled
      INSERT INTO usesComponent (Parent_IID, Child_IID, Quantity_Used)
      VALUES (699.0, v_new_child_instance_id, ROUND(0.1, 1)); -- Use rounded quantity needed
  END IF;

EXCEPTION
  WHEN OTHERS THEN
    DBMS_OUTPUT.PUT_LINE('Error processing Parent_IID=' || 699.0 || ', Child_PID=' || 168.0 || ': ' || SQLERRM);
    -- Decide if you want to rollback just this block or let the main exception handler catch it
END;
/
DECLARE
  v_new_child_instance_id productInstance.Instance_ID%TYPE;
  v_child_category        product.Category%TYPE := 'Commodity'; -- Pass category
  v_max_existing_batch_lot NUMBER;
  v_next_batch_lot_num   NUMBER;
  v_serial_number        serialized.Serial_Number%TYPE;
  v_batch_number         serialized.Batch_Number%TYPE; -- Shared batch for serialized children of *this* parent
  v_expiration_date      commodity.Expiration_Date%TYPE;
  v_quantity_to_create   commodity.Quantity%TYPE; -- Quantity for the new child instance

BEGIN
  -- Step 1: Create the new child productInstance
  INSERT INTO productInstance (Product_ID, Date_Manufactured, Is_Recalled)
  VALUES (192.0, TIMESTAMP '2024-12-20 10:47:06', 0)
  RETURNING Instance_ID INTO v_new_child_instance_id;

  -- Step 2: Create the corresponding subtype record
  IF v_child_category = 'Commodity' THEN
    -- Find max existing Batch_Number for this specific Child_PID
    SELECT NVL(MAX(c.Batch_Number), 0) INTO v_max_existing_batch_lot
    FROM commodity c JOIN productInstance pi ON c.Instance_ID = pi.Instance_ID
    WHERE pi.Product_ID = 192.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next batch

    v_expiration_date := TIMESTAMP '2024-12-20 10:47:06' + INTERVAL '307' DAY;
    v_quantity_to_create := ROUND(1.3, 1);

    INSERT INTO commodity (Instance_ID, Batch_Number, Expiration_Date, Quantity)
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Packaged' THEN
    -- Find max existing Lot_Number for this specific Child_PID
    SELECT NVL(MAX(p.Lot_Number), 0) INTO v_max_existing_batch_lot
    FROM packaged p JOIN productInstance pi ON p.Instance_ID = pi.Instance_ID -- Assuming 'packaged' table name
    WHERE pi.Product_ID = 192.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next lot

    v_expiration_date := TIMESTAMP '2024-12-20 10:47:06' + INTERVAL '444' DAY;
    v_quantity_to_create := ROUND(1.3, 1);

    INSERT INTO packaged (Instance_ID, Lot_Number, Expiration_Date, Quantity) -- Assuming 'packaged' table name
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Serialized' THEN
    -- Assign a unique serial number
    -- Using Instance ID guarantees uniqueness within this context
    v_serial_number := 'SN-' || TO_CHAR(192.0) || '-' || TO_CHAR(v_new_child_instance_id) || '-' || SUBSTR(SYS_GUID(),1,8);
    -- Assign a batch number - use Product_ID of the *parent* instance as the batch for simplicity? Or a sequence?
    -- Let's use the Parent_IID itself as a simple batch identifier for this run.
    v_batch_number := 700.0; -- All children created FOR this parent get same batch number

    INSERT INTO serialized (Instance_ID, Serial_Number, Batch_Number)
    VALUES (v_new_child_instance_id, v_serial_number, v_batch_number);

    -- Quantity for usesComponent link for serialized is typically 1
    v_quantity_to_create := 1;

  END IF;

  -- Step 3: Create the usesComponent link
  -- Quantity_Used is the Quantity_Needed from needsComponent (which matches child quantity for non-serialized)
  IF v_child_category IN ('Commodity', 'Packaged', 'Serialized') THEN -- Only insert if subtype was handled
      INSERT INTO usesComponent (Parent_IID, Child_IID, Quantity_Used)
      VALUES (700.0, v_new_child_instance_id, ROUND(1.3, 1)); -- Use rounded quantity needed
  END IF;

EXCEPTION
  WHEN OTHERS THEN
    DBMS_OUTPUT.PUT_LINE('Error processing Parent_IID=' || 700.0 || ', Child_PID=' || 192.0 || ': ' || SQLERRM);
    -- Decide if you want to rollback just this block or let the main exception handler catch it
END;
/
DECLARE
  v_new_child_instance_id productInstance.Instance_ID%TYPE;
  v_child_category        product.Category%TYPE := 'Commodity'; -- Pass category
  v_max_existing_batch_lot NUMBER;
  v_next_batch_lot_num   NUMBER;
  v_serial_number        serialized.Serial_Number%TYPE;
  v_batch_number         serialized.Batch_Number%TYPE; -- Shared batch for serialized children of *this* parent
  v_expiration_date      commodity.Expiration_Date%TYPE;
  v_quantity_to_create   commodity.Quantity%TYPE; -- Quantity for the new child instance

BEGIN
  -- Step 1: Create the new child productInstance
  INSERT INTO productInstance (Product_ID, Date_Manufactured, Is_Recalled)
  VALUES (140.0, TIMESTAMP '2024-06-03 09:49:23', 0)
  RETURNING Instance_ID INTO v_new_child_instance_id;

  -- Step 2: Create the corresponding subtype record
  IF v_child_category = 'Commodity' THEN
    -- Find max existing Batch_Number for this specific Child_PID
    SELECT NVL(MAX(c.Batch_Number), 0) INTO v_max_existing_batch_lot
    FROM commodity c JOIN productInstance pi ON c.Instance_ID = pi.Instance_ID
    WHERE pi.Product_ID = 140.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next batch

    v_expiration_date := TIMESTAMP '2024-06-03 09:49:23' + INTERVAL '725' DAY;
    v_quantity_to_create := ROUND(0.4, 1);

    INSERT INTO commodity (Instance_ID, Batch_Number, Expiration_Date, Quantity)
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Packaged' THEN
    -- Find max existing Lot_Number for this specific Child_PID
    SELECT NVL(MAX(p.Lot_Number), 0) INTO v_max_existing_batch_lot
    FROM packaged p JOIN productInstance pi ON p.Instance_ID = pi.Instance_ID -- Assuming 'packaged' table name
    WHERE pi.Product_ID = 140.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next lot

    v_expiration_date := TIMESTAMP '2024-06-03 09:49:23' + INTERVAL '620' DAY;
    v_quantity_to_create := ROUND(0.4, 1);

    INSERT INTO packaged (Instance_ID, Lot_Number, Expiration_Date, Quantity) -- Assuming 'packaged' table name
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Serialized' THEN
    -- Assign a unique serial number
    -- Using Instance ID guarantees uniqueness within this context
    v_serial_number := 'SN-' || TO_CHAR(140.0) || '-' || TO_CHAR(v_new_child_instance_id) || '-' || SUBSTR(SYS_GUID(),1,8);
    -- Assign a batch number - use Product_ID of the *parent* instance as the batch for simplicity? Or a sequence?
    -- Let's use the Parent_IID itself as a simple batch identifier for this run.
    v_batch_number := 700.0; -- All children created FOR this parent get same batch number

    INSERT INTO serialized (Instance_ID, Serial_Number, Batch_Number)
    VALUES (v_new_child_instance_id, v_serial_number, v_batch_number);

    -- Quantity for usesComponent link for serialized is typically 1
    v_quantity_to_create := 1;

  END IF;

  -- Step 3: Create the usesComponent link
  -- Quantity_Used is the Quantity_Needed from needsComponent (which matches child quantity for non-serialized)
  IF v_child_category IN ('Commodity', 'Packaged', 'Serialized') THEN -- Only insert if subtype was handled
      INSERT INTO usesComponent (Parent_IID, Child_IID, Quantity_Used)
      VALUES (700.0, v_new_child_instance_id, ROUND(0.4, 1)); -- Use rounded quantity needed
  END IF;

EXCEPTION
  WHEN OTHERS THEN
    DBMS_OUTPUT.PUT_LINE('Error processing Parent_IID=' || 700.0 || ', Child_PID=' || 140.0 || ': ' || SQLERRM);
    -- Decide if you want to rollback just this block or let the main exception handler catch it
END;
/
DECLARE
  v_new_child_instance_id productInstance.Instance_ID%TYPE;
  v_child_category        product.Category%TYPE := 'Commodity'; -- Pass category
  v_max_existing_batch_lot NUMBER;
  v_next_batch_lot_num   NUMBER;
  v_serial_number        serialized.Serial_Number%TYPE;
  v_batch_number         serialized.Batch_Number%TYPE; -- Shared batch for serialized children of *this* parent
  v_expiration_date      commodity.Expiration_Date%TYPE;
  v_quantity_to_create   commodity.Quantity%TYPE; -- Quantity for the new child instance

BEGIN
  -- Step 1: Create the new child productInstance
  INSERT INTO productInstance (Product_ID, Date_Manufactured, Is_Recalled)
  VALUES (161.0, TIMESTAMP '2024-12-26 01:43:07', 0)
  RETURNING Instance_ID INTO v_new_child_instance_id;

  -- Step 2: Create the corresponding subtype record
  IF v_child_category = 'Commodity' THEN
    -- Find max existing Batch_Number for this specific Child_PID
    SELECT NVL(MAX(c.Batch_Number), 0) INTO v_max_existing_batch_lot
    FROM commodity c JOIN productInstance pi ON c.Instance_ID = pi.Instance_ID
    WHERE pi.Product_ID = 161.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next batch

    v_expiration_date := TIMESTAMP '2024-12-26 01:43:07' + INTERVAL '570' DAY;
    v_quantity_to_create := ROUND(0.5, 1);

    INSERT INTO commodity (Instance_ID, Batch_Number, Expiration_Date, Quantity)
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Packaged' THEN
    -- Find max existing Lot_Number for this specific Child_PID
    SELECT NVL(MAX(p.Lot_Number), 0) INTO v_max_existing_batch_lot
    FROM packaged p JOIN productInstance pi ON p.Instance_ID = pi.Instance_ID -- Assuming 'packaged' table name
    WHERE pi.Product_ID = 161.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next lot

    v_expiration_date := TIMESTAMP '2024-12-26 01:43:07' + INTERVAL '516' DAY;
    v_quantity_to_create := ROUND(0.5, 1);

    INSERT INTO packaged (Instance_ID, Lot_Number, Expiration_Date, Quantity) -- Assuming 'packaged' table name
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Serialized' THEN
    -- Assign a unique serial number
    -- Using Instance ID guarantees uniqueness within this context
    v_serial_number := 'SN-' || TO_CHAR(161.0) || '-' || TO_CHAR(v_new_child_instance_id) || '-' || SUBSTR(SYS_GUID(),1,8);
    -- Assign a batch number - use Product_ID of the *parent* instance as the batch for simplicity? Or a sequence?
    -- Let's use the Parent_IID itself as a simple batch identifier for this run.
    v_batch_number := 700.0; -- All children created FOR this parent get same batch number

    INSERT INTO serialized (Instance_ID, Serial_Number, Batch_Number)
    VALUES (v_new_child_instance_id, v_serial_number, v_batch_number);

    -- Quantity for usesComponent link for serialized is typically 1
    v_quantity_to_create := 1;

  END IF;

  -- Step 3: Create the usesComponent link
  -- Quantity_Used is the Quantity_Needed from needsComponent (which matches child quantity for non-serialized)
  IF v_child_category IN ('Commodity', 'Packaged', 'Serialized') THEN -- Only insert if subtype was handled
      INSERT INTO usesComponent (Parent_IID, Child_IID, Quantity_Used)
      VALUES (700.0, v_new_child_instance_id, ROUND(0.5, 1)); -- Use rounded quantity needed
  END IF;

EXCEPTION
  WHEN OTHERS THEN
    DBMS_OUTPUT.PUT_LINE('Error processing Parent_IID=' || 700.0 || ', Child_PID=' || 161.0 || ': ' || SQLERRM);
    -- Decide if you want to rollback just this block or let the main exception handler catch it
END;
/
DECLARE
  v_new_child_instance_id productInstance.Instance_ID%TYPE;
  v_child_category        product.Category%TYPE := 'Commodity'; -- Pass category
  v_max_existing_batch_lot NUMBER;
  v_next_batch_lot_num   NUMBER;
  v_serial_number        serialized.Serial_Number%TYPE;
  v_batch_number         serialized.Batch_Number%TYPE; -- Shared batch for serialized children of *this* parent
  v_expiration_date      commodity.Expiration_Date%TYPE;
  v_quantity_to_create   commodity.Quantity%TYPE; -- Quantity for the new child instance

BEGIN
  -- Step 1: Create the new child productInstance
  INSERT INTO productInstance (Product_ID, Date_Manufactured, Is_Recalled)
  VALUES (168.0, TIMESTAMP '2024-12-04 05:55:22', 0)
  RETURNING Instance_ID INTO v_new_child_instance_id;

  -- Step 2: Create the corresponding subtype record
  IF v_child_category = 'Commodity' THEN
    -- Find max existing Batch_Number for this specific Child_PID
    SELECT NVL(MAX(c.Batch_Number), 0) INTO v_max_existing_batch_lot
    FROM commodity c JOIN productInstance pi ON c.Instance_ID = pi.Instance_ID
    WHERE pi.Product_ID = 168.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next batch

    v_expiration_date := TIMESTAMP '2024-12-04 05:55:22' + INTERVAL '458' DAY;
    v_quantity_to_create := ROUND(0.1, 1);

    INSERT INTO commodity (Instance_ID, Batch_Number, Expiration_Date, Quantity)
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Packaged' THEN
    -- Find max existing Lot_Number for this specific Child_PID
    SELECT NVL(MAX(p.Lot_Number), 0) INTO v_max_existing_batch_lot
    FROM packaged p JOIN productInstance pi ON p.Instance_ID = pi.Instance_ID -- Assuming 'packaged' table name
    WHERE pi.Product_ID = 168.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next lot

    v_expiration_date := TIMESTAMP '2024-12-04 05:55:22' + INTERVAL '578' DAY;
    v_quantity_to_create := ROUND(0.1, 1);

    INSERT INTO packaged (Instance_ID, Lot_Number, Expiration_Date, Quantity) -- Assuming 'packaged' table name
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Serialized' THEN
    -- Assign a unique serial number
    -- Using Instance ID guarantees uniqueness within this context
    v_serial_number := 'SN-' || TO_CHAR(168.0) || '-' || TO_CHAR(v_new_child_instance_id) || '-' || SUBSTR(SYS_GUID(),1,8);
    -- Assign a batch number - use Product_ID of the *parent* instance as the batch for simplicity? Or a sequence?
    -- Let's use the Parent_IID itself as a simple batch identifier for this run.
    v_batch_number := 700.0; -- All children created FOR this parent get same batch number

    INSERT INTO serialized (Instance_ID, Serial_Number, Batch_Number)
    VALUES (v_new_child_instance_id, v_serial_number, v_batch_number);

    -- Quantity for usesComponent link for serialized is typically 1
    v_quantity_to_create := 1;

  END IF;

  -- Step 3: Create the usesComponent link
  -- Quantity_Used is the Quantity_Needed from needsComponent (which matches child quantity for non-serialized)
  IF v_child_category IN ('Commodity', 'Packaged', 'Serialized') THEN -- Only insert if subtype was handled
      INSERT INTO usesComponent (Parent_IID, Child_IID, Quantity_Used)
      VALUES (700.0, v_new_child_instance_id, ROUND(0.1, 1)); -- Use rounded quantity needed
  END IF;

EXCEPTION
  WHEN OTHERS THEN
    DBMS_OUTPUT.PUT_LINE('Error processing Parent_IID=' || 700.0 || ', Child_PID=' || 168.0 || ': ' || SQLERRM);
    -- Decide if you want to rollback just this block or let the main exception handler catch it
END;
/
DECLARE
  v_new_child_instance_id productInstance.Instance_ID%TYPE;
  v_child_category        product.Category%TYPE := 'Commodity'; -- Pass category
  v_max_existing_batch_lot NUMBER;
  v_next_batch_lot_num   NUMBER;
  v_serial_number        serialized.Serial_Number%TYPE;
  v_batch_number         serialized.Batch_Number%TYPE; -- Shared batch for serialized children of *this* parent
  v_expiration_date      commodity.Expiration_Date%TYPE;
  v_quantity_to_create   commodity.Quantity%TYPE; -- Quantity for the new child instance

BEGIN
  -- Step 1: Create the new child productInstance
  INSERT INTO productInstance (Product_ID, Date_Manufactured, Is_Recalled)
  VALUES (174.0, TIMESTAMP '2025-04-26 17:30:57', 0)
  RETURNING Instance_ID INTO v_new_child_instance_id;

  -- Step 2: Create the corresponding subtype record
  IF v_child_category = 'Commodity' THEN
    -- Find max existing Batch_Number for this specific Child_PID
    SELECT NVL(MAX(c.Batch_Number), 0) INTO v_max_existing_batch_lot
    FROM commodity c JOIN productInstance pi ON c.Instance_ID = pi.Instance_ID
    WHERE pi.Product_ID = 174.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next batch

    v_expiration_date := TIMESTAMP '2025-04-26 17:30:57' + INTERVAL '433' DAY;
    v_quantity_to_create := ROUND(1.0, 1);

    INSERT INTO commodity (Instance_ID, Batch_Number, Expiration_Date, Quantity)
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Packaged' THEN
    -- Find max existing Lot_Number for this specific Child_PID
    SELECT NVL(MAX(p.Lot_Number), 0) INTO v_max_existing_batch_lot
    FROM packaged p JOIN productInstance pi ON p.Instance_ID = pi.Instance_ID -- Assuming 'packaged' table name
    WHERE pi.Product_ID = 174.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next lot

    v_expiration_date := TIMESTAMP '2025-04-26 17:30:57' + INTERVAL '338' DAY;
    v_quantity_to_create := ROUND(1.0, 1);

    INSERT INTO packaged (Instance_ID, Lot_Number, Expiration_Date, Quantity) -- Assuming 'packaged' table name
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Serialized' THEN
    -- Assign a unique serial number
    -- Using Instance ID guarantees uniqueness within this context
    v_serial_number := 'SN-' || TO_CHAR(174.0) || '-' || TO_CHAR(v_new_child_instance_id) || '-' || SUBSTR(SYS_GUID(),1,8);
    -- Assign a batch number - use Product_ID of the *parent* instance as the batch for simplicity? Or a sequence?
    -- Let's use the Parent_IID itself as a simple batch identifier for this run.
    v_batch_number := 715.0; -- All children created FOR this parent get same batch number

    INSERT INTO serialized (Instance_ID, Serial_Number, Batch_Number)
    VALUES (v_new_child_instance_id, v_serial_number, v_batch_number);

    -- Quantity for usesComponent link for serialized is typically 1
    v_quantity_to_create := 1;

  END IF;

  -- Step 3: Create the usesComponent link
  -- Quantity_Used is the Quantity_Needed from needsComponent (which matches child quantity for non-serialized)
  IF v_child_category IN ('Commodity', 'Packaged', 'Serialized') THEN -- Only insert if subtype was handled
      INSERT INTO usesComponent (Parent_IID, Child_IID, Quantity_Used)
      VALUES (715.0, v_new_child_instance_id, ROUND(1.0, 1)); -- Use rounded quantity needed
  END IF;

EXCEPTION
  WHEN OTHERS THEN
    DBMS_OUTPUT.PUT_LINE('Error processing Parent_IID=' || 715.0 || ', Child_PID=' || 174.0 || ': ' || SQLERRM);
    -- Decide if you want to rollback just this block or let the main exception handler catch it
END;
/
DECLARE
  v_new_child_instance_id productInstance.Instance_ID%TYPE;
  v_child_category        product.Category%TYPE := 'Commodity'; -- Pass category
  v_max_existing_batch_lot NUMBER;
  v_next_batch_lot_num   NUMBER;
  v_serial_number        serialized.Serial_Number%TYPE;
  v_batch_number         serialized.Batch_Number%TYPE; -- Shared batch for serialized children of *this* parent
  v_expiration_date      commodity.Expiration_Date%TYPE;
  v_quantity_to_create   commodity.Quantity%TYPE; -- Quantity for the new child instance

BEGIN
  -- Step 1: Create the new child productInstance
  INSERT INTO productInstance (Product_ID, Date_Manufactured, Is_Recalled)
  VALUES (216.0, TIMESTAMP '2025-04-12 21:54:16', 0)
  RETURNING Instance_ID INTO v_new_child_instance_id;

  -- Step 2: Create the corresponding subtype record
  IF v_child_category = 'Commodity' THEN
    -- Find max existing Batch_Number for this specific Child_PID
    SELECT NVL(MAX(c.Batch_Number), 0) INTO v_max_existing_batch_lot
    FROM commodity c JOIN productInstance pi ON c.Instance_ID = pi.Instance_ID
    WHERE pi.Product_ID = 216.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next batch

    v_expiration_date := TIMESTAMP '2025-04-12 21:54:16' + INTERVAL '254' DAY;
    v_quantity_to_create := ROUND(0.2, 1);

    INSERT INTO commodity (Instance_ID, Batch_Number, Expiration_Date, Quantity)
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Packaged' THEN
    -- Find max existing Lot_Number for this specific Child_PID
    SELECT NVL(MAX(p.Lot_Number), 0) INTO v_max_existing_batch_lot
    FROM packaged p JOIN productInstance pi ON p.Instance_ID = pi.Instance_ID -- Assuming 'packaged' table name
    WHERE pi.Product_ID = 216.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next lot

    v_expiration_date := TIMESTAMP '2025-04-12 21:54:16' + INTERVAL '677' DAY;
    v_quantity_to_create := ROUND(0.2, 1);

    INSERT INTO packaged (Instance_ID, Lot_Number, Expiration_Date, Quantity) -- Assuming 'packaged' table name
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Serialized' THEN
    -- Assign a unique serial number
    -- Using Instance ID guarantees uniqueness within this context
    v_serial_number := 'SN-' || TO_CHAR(216.0) || '-' || TO_CHAR(v_new_child_instance_id) || '-' || SUBSTR(SYS_GUID(),1,8);
    -- Assign a batch number - use Product_ID of the *parent* instance as the batch for simplicity? Or a sequence?
    -- Let's use the Parent_IID itself as a simple batch identifier for this run.
    v_batch_number := 715.0; -- All children created FOR this parent get same batch number

    INSERT INTO serialized (Instance_ID, Serial_Number, Batch_Number)
    VALUES (v_new_child_instance_id, v_serial_number, v_batch_number);

    -- Quantity for usesComponent link for serialized is typically 1
    v_quantity_to_create := 1;

  END IF;

  -- Step 3: Create the usesComponent link
  -- Quantity_Used is the Quantity_Needed from needsComponent (which matches child quantity for non-serialized)
  IF v_child_category IN ('Commodity', 'Packaged', 'Serialized') THEN -- Only insert if subtype was handled
      INSERT INTO usesComponent (Parent_IID, Child_IID, Quantity_Used)
      VALUES (715.0, v_new_child_instance_id, ROUND(0.2, 1)); -- Use rounded quantity needed
  END IF;

EXCEPTION
  WHEN OTHERS THEN
    DBMS_OUTPUT.PUT_LINE('Error processing Parent_IID=' || 715.0 || ', Child_PID=' || 216.0 || ': ' || SQLERRM);
    -- Decide if you want to rollback just this block or let the main exception handler catch it
END;
/
DECLARE
  v_new_child_instance_id productInstance.Instance_ID%TYPE;
  v_child_category        product.Category%TYPE := 'Commodity'; -- Pass category
  v_max_existing_batch_lot NUMBER;
  v_next_batch_lot_num   NUMBER;
  v_serial_number        serialized.Serial_Number%TYPE;
  v_batch_number         serialized.Batch_Number%TYPE; -- Shared batch for serialized children of *this* parent
  v_expiration_date      commodity.Expiration_Date%TYPE;
  v_quantity_to_create   commodity.Quantity%TYPE; -- Quantity for the new child instance

BEGIN
  -- Step 1: Create the new child productInstance
  INSERT INTO productInstance (Product_ID, Date_Manufactured, Is_Recalled)
  VALUES (159.0, TIMESTAMP '2024-08-24 14:03:48', 0)
  RETURNING Instance_ID INTO v_new_child_instance_id;

  -- Step 2: Create the corresponding subtype record
  IF v_child_category = 'Commodity' THEN
    -- Find max existing Batch_Number for this specific Child_PID
    SELECT NVL(MAX(c.Batch_Number), 0) INTO v_max_existing_batch_lot
    FROM commodity c JOIN productInstance pi ON c.Instance_ID = pi.Instance_ID
    WHERE pi.Product_ID = 159.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next batch

    v_expiration_date := TIMESTAMP '2024-08-24 14:03:48' + INTERVAL '592' DAY;
    v_quantity_to_create := ROUND(0.5, 1);

    INSERT INTO commodity (Instance_ID, Batch_Number, Expiration_Date, Quantity)
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Packaged' THEN
    -- Find max existing Lot_Number for this specific Child_PID
    SELECT NVL(MAX(p.Lot_Number), 0) INTO v_max_existing_batch_lot
    FROM packaged p JOIN productInstance pi ON p.Instance_ID = pi.Instance_ID -- Assuming 'packaged' table name
    WHERE pi.Product_ID = 159.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next lot

    v_expiration_date := TIMESTAMP '2024-08-24 14:03:48' + INTERVAL '166' DAY;
    v_quantity_to_create := ROUND(0.5, 1);

    INSERT INTO packaged (Instance_ID, Lot_Number, Expiration_Date, Quantity) -- Assuming 'packaged' table name
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Serialized' THEN
    -- Assign a unique serial number
    -- Using Instance ID guarantees uniqueness within this context
    v_serial_number := 'SN-' || TO_CHAR(159.0) || '-' || TO_CHAR(v_new_child_instance_id) || '-' || SUBSTR(SYS_GUID(),1,8);
    -- Assign a batch number - use Product_ID of the *parent* instance as the batch for simplicity? Or a sequence?
    -- Let's use the Parent_IID itself as a simple batch identifier for this run.
    v_batch_number := 715.0; -- All children created FOR this parent get same batch number

    INSERT INTO serialized (Instance_ID, Serial_Number, Batch_Number)
    VALUES (v_new_child_instance_id, v_serial_number, v_batch_number);

    -- Quantity for usesComponent link for serialized is typically 1
    v_quantity_to_create := 1;

  END IF;

  -- Step 3: Create the usesComponent link
  -- Quantity_Used is the Quantity_Needed from needsComponent (which matches child quantity for non-serialized)
  IF v_child_category IN ('Commodity', 'Packaged', 'Serialized') THEN -- Only insert if subtype was handled
      INSERT INTO usesComponent (Parent_IID, Child_IID, Quantity_Used)
      VALUES (715.0, v_new_child_instance_id, ROUND(0.5, 1)); -- Use rounded quantity needed
  END IF;

EXCEPTION
  WHEN OTHERS THEN
    DBMS_OUTPUT.PUT_LINE('Error processing Parent_IID=' || 715.0 || ', Child_PID=' || 159.0 || ': ' || SQLERRM);
    -- Decide if you want to rollback just this block or let the main exception handler catch it
END;
/
DECLARE
  v_new_child_instance_id productInstance.Instance_ID%TYPE;
  v_child_category        product.Category%TYPE := 'Commodity'; -- Pass category
  v_max_existing_batch_lot NUMBER;
  v_next_batch_lot_num   NUMBER;
  v_serial_number        serialized.Serial_Number%TYPE;
  v_batch_number         serialized.Batch_Number%TYPE; -- Shared batch for serialized children of *this* parent
  v_expiration_date      commodity.Expiration_Date%TYPE;
  v_quantity_to_create   commodity.Quantity%TYPE; -- Quantity for the new child instance

BEGIN
  -- Step 1: Create the new child productInstance
  INSERT INTO productInstance (Product_ID, Date_Manufactured, Is_Recalled)
  VALUES (601.0, TIMESTAMP '2024-05-19 23:42:34', 0)
  RETURNING Instance_ID INTO v_new_child_instance_id;

  -- Step 2: Create the corresponding subtype record
  IF v_child_category = 'Commodity' THEN
    -- Find max existing Batch_Number for this specific Child_PID
    SELECT NVL(MAX(c.Batch_Number), 0) INTO v_max_existing_batch_lot
    FROM commodity c JOIN productInstance pi ON c.Instance_ID = pi.Instance_ID
    WHERE pi.Product_ID = 601.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next batch

    v_expiration_date := TIMESTAMP '2024-05-19 23:42:34' + INTERVAL '644' DAY;
    v_quantity_to_create := ROUND(0.4, 1);

    INSERT INTO commodity (Instance_ID, Batch_Number, Expiration_Date, Quantity)
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Packaged' THEN
    -- Find max existing Lot_Number for this specific Child_PID
    SELECT NVL(MAX(p.Lot_Number), 0) INTO v_max_existing_batch_lot
    FROM packaged p JOIN productInstance pi ON p.Instance_ID = pi.Instance_ID -- Assuming 'packaged' table name
    WHERE pi.Product_ID = 601.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next lot

    v_expiration_date := TIMESTAMP '2024-05-19 23:42:34' + INTERVAL '550' DAY;
    v_quantity_to_create := ROUND(0.4, 1);

    INSERT INTO packaged (Instance_ID, Lot_Number, Expiration_Date, Quantity) -- Assuming 'packaged' table name
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Serialized' THEN
    -- Assign a unique serial number
    -- Using Instance ID guarantees uniqueness within this context
    v_serial_number := 'SN-' || TO_CHAR(601.0) || '-' || TO_CHAR(v_new_child_instance_id) || '-' || SUBSTR(SYS_GUID(),1,8);
    -- Assign a batch number - use Product_ID of the *parent* instance as the batch for simplicity? Or a sequence?
    -- Let's use the Parent_IID itself as a simple batch identifier for this run.
    v_batch_number := 733.0; -- All children created FOR this parent get same batch number

    INSERT INTO serialized (Instance_ID, Serial_Number, Batch_Number)
    VALUES (v_new_child_instance_id, v_serial_number, v_batch_number);

    -- Quantity for usesComponent link for serialized is typically 1
    v_quantity_to_create := 1;

  END IF;

  -- Step 3: Create the usesComponent link
  -- Quantity_Used is the Quantity_Needed from needsComponent (which matches child quantity for non-serialized)
  IF v_child_category IN ('Commodity', 'Packaged', 'Serialized') THEN -- Only insert if subtype was handled
      INSERT INTO usesComponent (Parent_IID, Child_IID, Quantity_Used)
      VALUES (733.0, v_new_child_instance_id, ROUND(0.4, 1)); -- Use rounded quantity needed
  END IF;

EXCEPTION
  WHEN OTHERS THEN
    DBMS_OUTPUT.PUT_LINE('Error processing Parent_IID=' || 733.0 || ', Child_PID=' || 601.0 || ': ' || SQLERRM);
    -- Decide if you want to rollback just this block or let the main exception handler catch it
END;
/
DECLARE
  v_new_child_instance_id productInstance.Instance_ID%TYPE;
  v_child_category        product.Category%TYPE := 'Commodity'; -- Pass category
  v_max_existing_batch_lot NUMBER;
  v_next_batch_lot_num   NUMBER;
  v_serial_number        serialized.Serial_Number%TYPE;
  v_batch_number         serialized.Batch_Number%TYPE; -- Shared batch for serialized children of *this* parent
  v_expiration_date      commodity.Expiration_Date%TYPE;
  v_quantity_to_create   commodity.Quantity%TYPE; -- Quantity for the new child instance

BEGIN
  -- Step 1: Create the new child productInstance
  INSERT INTO productInstance (Product_ID, Date_Manufactured, Is_Recalled)
  VALUES (601.0, TIMESTAMP '2024-06-10 17:00:34', 0)
  RETURNING Instance_ID INTO v_new_child_instance_id;

  -- Step 2: Create the corresponding subtype record
  IF v_child_category = 'Commodity' THEN
    -- Find max existing Batch_Number for this specific Child_PID
    SELECT NVL(MAX(c.Batch_Number), 0) INTO v_max_existing_batch_lot
    FROM commodity c JOIN productInstance pi ON c.Instance_ID = pi.Instance_ID
    WHERE pi.Product_ID = 601.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next batch

    v_expiration_date := TIMESTAMP '2024-06-10 17:00:34' + INTERVAL '209' DAY;
    v_quantity_to_create := ROUND(0.4, 1);

    INSERT INTO commodity (Instance_ID, Batch_Number, Expiration_Date, Quantity)
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Packaged' THEN
    -- Find max existing Lot_Number for this specific Child_PID
    SELECT NVL(MAX(p.Lot_Number), 0) INTO v_max_existing_batch_lot
    FROM packaged p JOIN productInstance pi ON p.Instance_ID = pi.Instance_ID -- Assuming 'packaged' table name
    WHERE pi.Product_ID = 601.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next lot

    v_expiration_date := TIMESTAMP '2024-06-10 17:00:34' + INTERVAL '276' DAY;
    v_quantity_to_create := ROUND(0.4, 1);

    INSERT INTO packaged (Instance_ID, Lot_Number, Expiration_Date, Quantity) -- Assuming 'packaged' table name
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Serialized' THEN
    -- Assign a unique serial number
    -- Using Instance ID guarantees uniqueness within this context
    v_serial_number := 'SN-' || TO_CHAR(601.0) || '-' || TO_CHAR(v_new_child_instance_id) || '-' || SUBSTR(SYS_GUID(),1,8);
    -- Assign a batch number - use Product_ID of the *parent* instance as the batch for simplicity? Or a sequence?
    -- Let's use the Parent_IID itself as a simple batch identifier for this run.
    v_batch_number := 734.0; -- All children created FOR this parent get same batch number

    INSERT INTO serialized (Instance_ID, Serial_Number, Batch_Number)
    VALUES (v_new_child_instance_id, v_serial_number, v_batch_number);

    -- Quantity for usesComponent link for serialized is typically 1
    v_quantity_to_create := 1;

  END IF;

  -- Step 3: Create the usesComponent link
  -- Quantity_Used is the Quantity_Needed from needsComponent (which matches child quantity for non-serialized)
  IF v_child_category IN ('Commodity', 'Packaged', 'Serialized') THEN -- Only insert if subtype was handled
      INSERT INTO usesComponent (Parent_IID, Child_IID, Quantity_Used)
      VALUES (734.0, v_new_child_instance_id, ROUND(0.4, 1)); -- Use rounded quantity needed
  END IF;

EXCEPTION
  WHEN OTHERS THEN
    DBMS_OUTPUT.PUT_LINE('Error processing Parent_IID=' || 734.0 || ', Child_PID=' || 601.0 || ': ' || SQLERRM);
    -- Decide if you want to rollback just this block or let the main exception handler catch it
END;
/
DECLARE
  v_new_child_instance_id productInstance.Instance_ID%TYPE;
  v_child_category        product.Category%TYPE := 'Commodity'; -- Pass category
  v_max_existing_batch_lot NUMBER;
  v_next_batch_lot_num   NUMBER;
  v_serial_number        serialized.Serial_Number%TYPE;
  v_batch_number         serialized.Batch_Number%TYPE; -- Shared batch for serialized children of *this* parent
  v_expiration_date      commodity.Expiration_Date%TYPE;
  v_quantity_to_create   commodity.Quantity%TYPE; -- Quantity for the new child instance

BEGIN
  -- Step 1: Create the new child productInstance
  INSERT INTO productInstance (Product_ID, Date_Manufactured, Is_Recalled)
  VALUES (601.0, TIMESTAMP '2024-07-21 13:07:21', 0)
  RETURNING Instance_ID INTO v_new_child_instance_id;

  -- Step 2: Create the corresponding subtype record
  IF v_child_category = 'Commodity' THEN
    -- Find max existing Batch_Number for this specific Child_PID
    SELECT NVL(MAX(c.Batch_Number), 0) INTO v_max_existing_batch_lot
    FROM commodity c JOIN productInstance pi ON c.Instance_ID = pi.Instance_ID
    WHERE pi.Product_ID = 601.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next batch

    v_expiration_date := TIMESTAMP '2024-07-21 13:07:21' + INTERVAL '475' DAY;
    v_quantity_to_create := ROUND(0.4, 1);

    INSERT INTO commodity (Instance_ID, Batch_Number, Expiration_Date, Quantity)
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Packaged' THEN
    -- Find max existing Lot_Number for this specific Child_PID
    SELECT NVL(MAX(p.Lot_Number), 0) INTO v_max_existing_batch_lot
    FROM packaged p JOIN productInstance pi ON p.Instance_ID = pi.Instance_ID -- Assuming 'packaged' table name
    WHERE pi.Product_ID = 601.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next lot

    v_expiration_date := TIMESTAMP '2024-07-21 13:07:21' + INTERVAL '311' DAY;
    v_quantity_to_create := ROUND(0.4, 1);

    INSERT INTO packaged (Instance_ID, Lot_Number, Expiration_Date, Quantity) -- Assuming 'packaged' table name
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Serialized' THEN
    -- Assign a unique serial number
    -- Using Instance ID guarantees uniqueness within this context
    v_serial_number := 'SN-' || TO_CHAR(601.0) || '-' || TO_CHAR(v_new_child_instance_id) || '-' || SUBSTR(SYS_GUID(),1,8);
    -- Assign a batch number - use Product_ID of the *parent* instance as the batch for simplicity? Or a sequence?
    -- Let's use the Parent_IID itself as a simple batch identifier for this run.
    v_batch_number := 735.0; -- All children created FOR this parent get same batch number

    INSERT INTO serialized (Instance_ID, Serial_Number, Batch_Number)
    VALUES (v_new_child_instance_id, v_serial_number, v_batch_number);

    -- Quantity for usesComponent link for serialized is typically 1
    v_quantity_to_create := 1;

  END IF;

  -- Step 3: Create the usesComponent link
  -- Quantity_Used is the Quantity_Needed from needsComponent (which matches child quantity for non-serialized)
  IF v_child_category IN ('Commodity', 'Packaged', 'Serialized') THEN -- Only insert if subtype was handled
      INSERT INTO usesComponent (Parent_IID, Child_IID, Quantity_Used)
      VALUES (735.0, v_new_child_instance_id, ROUND(0.4, 1)); -- Use rounded quantity needed
  END IF;

EXCEPTION
  WHEN OTHERS THEN
    DBMS_OUTPUT.PUT_LINE('Error processing Parent_IID=' || 735.0 || ', Child_PID=' || 601.0 || ': ' || SQLERRM);
    -- Decide if you want to rollback just this block or let the main exception handler catch it
END;
/
DECLARE
  v_new_child_instance_id productInstance.Instance_ID%TYPE;
  v_child_category        product.Category%TYPE := 'Commodity'; -- Pass category
  v_max_existing_batch_lot NUMBER;
  v_next_batch_lot_num   NUMBER;
  v_serial_number        serialized.Serial_Number%TYPE;
  v_batch_number         serialized.Batch_Number%TYPE; -- Shared batch for serialized children of *this* parent
  v_expiration_date      commodity.Expiration_Date%TYPE;
  v_quantity_to_create   commodity.Quantity%TYPE; -- Quantity for the new child instance

BEGIN
  -- Step 1: Create the new child productInstance
  INSERT INTO productInstance (Product_ID, Date_Manufactured, Is_Recalled)
  VALUES (191.0, TIMESTAMP '2024-11-27 01:38:51', 0)
  RETURNING Instance_ID INTO v_new_child_instance_id;

  -- Step 2: Create the corresponding subtype record
  IF v_child_category = 'Commodity' THEN
    -- Find max existing Batch_Number for this specific Child_PID
    SELECT NVL(MAX(c.Batch_Number), 0) INTO v_max_existing_batch_lot
    FROM commodity c JOIN productInstance pi ON c.Instance_ID = pi.Instance_ID
    WHERE pi.Product_ID = 191.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next batch

    v_expiration_date := TIMESTAMP '2024-11-27 01:38:51' + INTERVAL '50' DAY;
    v_quantity_to_create := ROUND(1.6, 1);

    INSERT INTO commodity (Instance_ID, Batch_Number, Expiration_Date, Quantity)
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Packaged' THEN
    -- Find max existing Lot_Number for this specific Child_PID
    SELECT NVL(MAX(p.Lot_Number), 0) INTO v_max_existing_batch_lot
    FROM packaged p JOIN productInstance pi ON p.Instance_ID = pi.Instance_ID -- Assuming 'packaged' table name
    WHERE pi.Product_ID = 191.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next lot

    v_expiration_date := TIMESTAMP '2024-11-27 01:38:51' + INTERVAL '286' DAY;
    v_quantity_to_create := ROUND(1.6, 1);

    INSERT INTO packaged (Instance_ID, Lot_Number, Expiration_Date, Quantity) -- Assuming 'packaged' table name
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Serialized' THEN
    -- Assign a unique serial number
    -- Using Instance ID guarantees uniqueness within this context
    v_serial_number := 'SN-' || TO_CHAR(191.0) || '-' || TO_CHAR(v_new_child_instance_id) || '-' || SUBSTR(SYS_GUID(),1,8);
    -- Assign a batch number - use Product_ID of the *parent* instance as the batch for simplicity? Or a sequence?
    -- Let's use the Parent_IID itself as a simple batch identifier for this run.
    v_batch_number := 736.0; -- All children created FOR this parent get same batch number

    INSERT INTO serialized (Instance_ID, Serial_Number, Batch_Number)
    VALUES (v_new_child_instance_id, v_serial_number, v_batch_number);

    -- Quantity for usesComponent link for serialized is typically 1
    v_quantity_to_create := 1;

  END IF;

  -- Step 3: Create the usesComponent link
  -- Quantity_Used is the Quantity_Needed from needsComponent (which matches child quantity for non-serialized)
  IF v_child_category IN ('Commodity', 'Packaged', 'Serialized') THEN -- Only insert if subtype was handled
      INSERT INTO usesComponent (Parent_IID, Child_IID, Quantity_Used)
      VALUES (736.0, v_new_child_instance_id, ROUND(1.6, 1)); -- Use rounded quantity needed
  END IF;

EXCEPTION
  WHEN OTHERS THEN
    DBMS_OUTPUT.PUT_LINE('Error processing Parent_IID=' || 736.0 || ', Child_PID=' || 191.0 || ': ' || SQLERRM);
    -- Decide if you want to rollback just this block or let the main exception handler catch it
END;
/
DECLARE
  v_new_child_instance_id productInstance.Instance_ID%TYPE;
  v_child_category        product.Category%TYPE := 'Commodity'; -- Pass category
  v_max_existing_batch_lot NUMBER;
  v_next_batch_lot_num   NUMBER;
  v_serial_number        serialized.Serial_Number%TYPE;
  v_batch_number         serialized.Batch_Number%TYPE; -- Shared batch for serialized children of *this* parent
  v_expiration_date      commodity.Expiration_Date%TYPE;
  v_quantity_to_create   commodity.Quantity%TYPE; -- Quantity for the new child instance

BEGIN
  -- Step 1: Create the new child productInstance
  INSERT INTO productInstance (Product_ID, Date_Manufactured, Is_Recalled)
  VALUES (191.0, TIMESTAMP '2024-11-24 07:14:53', 0)
  RETURNING Instance_ID INTO v_new_child_instance_id;

  -- Step 2: Create the corresponding subtype record
  IF v_child_category = 'Commodity' THEN
    -- Find max existing Batch_Number for this specific Child_PID
    SELECT NVL(MAX(c.Batch_Number), 0) INTO v_max_existing_batch_lot
    FROM commodity c JOIN productInstance pi ON c.Instance_ID = pi.Instance_ID
    WHERE pi.Product_ID = 191.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next batch

    v_expiration_date := TIMESTAMP '2024-11-24 07:14:53' + INTERVAL '307' DAY;
    v_quantity_to_create := ROUND(1.6, 1);

    INSERT INTO commodity (Instance_ID, Batch_Number, Expiration_Date, Quantity)
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Packaged' THEN
    -- Find max existing Lot_Number for this specific Child_PID
    SELECT NVL(MAX(p.Lot_Number), 0) INTO v_max_existing_batch_lot
    FROM packaged p JOIN productInstance pi ON p.Instance_ID = pi.Instance_ID -- Assuming 'packaged' table name
    WHERE pi.Product_ID = 191.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next lot

    v_expiration_date := TIMESTAMP '2024-11-24 07:14:53' + INTERVAL '572' DAY;
    v_quantity_to_create := ROUND(1.6, 1);

    INSERT INTO packaged (Instance_ID, Lot_Number, Expiration_Date, Quantity) -- Assuming 'packaged' table name
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Serialized' THEN
    -- Assign a unique serial number
    -- Using Instance ID guarantees uniqueness within this context
    v_serial_number := 'SN-' || TO_CHAR(191.0) || '-' || TO_CHAR(v_new_child_instance_id) || '-' || SUBSTR(SYS_GUID(),1,8);
    -- Assign a batch number - use Product_ID of the *parent* instance as the batch for simplicity? Or a sequence?
    -- Let's use the Parent_IID itself as a simple batch identifier for this run.
    v_batch_number := 737.0; -- All children created FOR this parent get same batch number

    INSERT INTO serialized (Instance_ID, Serial_Number, Batch_Number)
    VALUES (v_new_child_instance_id, v_serial_number, v_batch_number);

    -- Quantity for usesComponent link for serialized is typically 1
    v_quantity_to_create := 1;

  END IF;

  -- Step 3: Create the usesComponent link
  -- Quantity_Used is the Quantity_Needed from needsComponent (which matches child quantity for non-serialized)
  IF v_child_category IN ('Commodity', 'Packaged', 'Serialized') THEN -- Only insert if subtype was handled
      INSERT INTO usesComponent (Parent_IID, Child_IID, Quantity_Used)
      VALUES (737.0, v_new_child_instance_id, ROUND(1.6, 1)); -- Use rounded quantity needed
  END IF;

EXCEPTION
  WHEN OTHERS THEN
    DBMS_OUTPUT.PUT_LINE('Error processing Parent_IID=' || 737.0 || ', Child_PID=' || 191.0 || ': ' || SQLERRM);
    -- Decide if you want to rollback just this block or let the main exception handler catch it
END;
/
DECLARE
  v_new_child_instance_id productInstance.Instance_ID%TYPE;
  v_child_category        product.Category%TYPE := 'Commodity'; -- Pass category
  v_max_existing_batch_lot NUMBER;
  v_next_batch_lot_num   NUMBER;
  v_serial_number        serialized.Serial_Number%TYPE;
  v_batch_number         serialized.Batch_Number%TYPE; -- Shared batch for serialized children of *this* parent
  v_expiration_date      commodity.Expiration_Date%TYPE;
  v_quantity_to_create   commodity.Quantity%TYPE; -- Quantity for the new child instance

BEGIN
  -- Step 1: Create the new child productInstance
  INSERT INTO productInstance (Product_ID, Date_Manufactured, Is_Recalled)
  VALUES (191.0, TIMESTAMP '2024-08-08 16:36:00', 0)
  RETURNING Instance_ID INTO v_new_child_instance_id;

  -- Step 2: Create the corresponding subtype record
  IF v_child_category = 'Commodity' THEN
    -- Find max existing Batch_Number for this specific Child_PID
    SELECT NVL(MAX(c.Batch_Number), 0) INTO v_max_existing_batch_lot
    FROM commodity c JOIN productInstance pi ON c.Instance_ID = pi.Instance_ID
    WHERE pi.Product_ID = 191.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next batch

    v_expiration_date := TIMESTAMP '2024-08-08 16:36:00' + INTERVAL '514' DAY;
    v_quantity_to_create := ROUND(1.6, 1);

    INSERT INTO commodity (Instance_ID, Batch_Number, Expiration_Date, Quantity)
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Packaged' THEN
    -- Find max existing Lot_Number for this specific Child_PID
    SELECT NVL(MAX(p.Lot_Number), 0) INTO v_max_existing_batch_lot
    FROM packaged p JOIN productInstance pi ON p.Instance_ID = pi.Instance_ID -- Assuming 'packaged' table name
    WHERE pi.Product_ID = 191.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next lot

    v_expiration_date := TIMESTAMP '2024-08-08 16:36:00' + INTERVAL '159' DAY;
    v_quantity_to_create := ROUND(1.6, 1);

    INSERT INTO packaged (Instance_ID, Lot_Number, Expiration_Date, Quantity) -- Assuming 'packaged' table name
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Serialized' THEN
    -- Assign a unique serial number
    -- Using Instance ID guarantees uniqueness within this context
    v_serial_number := 'SN-' || TO_CHAR(191.0) || '-' || TO_CHAR(v_new_child_instance_id) || '-' || SUBSTR(SYS_GUID(),1,8);
    -- Assign a batch number - use Product_ID of the *parent* instance as the batch for simplicity? Or a sequence?
    -- Let's use the Parent_IID itself as a simple batch identifier for this run.
    v_batch_number := 738.0; -- All children created FOR this parent get same batch number

    INSERT INTO serialized (Instance_ID, Serial_Number, Batch_Number)
    VALUES (v_new_child_instance_id, v_serial_number, v_batch_number);

    -- Quantity for usesComponent link for serialized is typically 1
    v_quantity_to_create := 1;

  END IF;

  -- Step 3: Create the usesComponent link
  -- Quantity_Used is the Quantity_Needed from needsComponent (which matches child quantity for non-serialized)
  IF v_child_category IN ('Commodity', 'Packaged', 'Serialized') THEN -- Only insert if subtype was handled
      INSERT INTO usesComponent (Parent_IID, Child_IID, Quantity_Used)
      VALUES (738.0, v_new_child_instance_id, ROUND(1.6, 1)); -- Use rounded quantity needed
  END IF;

EXCEPTION
  WHEN OTHERS THEN
    DBMS_OUTPUT.PUT_LINE('Error processing Parent_IID=' || 738.0 || ', Child_PID=' || 191.0 || ': ' || SQLERRM);
    -- Decide if you want to rollback just this block or let the main exception handler catch it
END;
/
DECLARE
  v_new_child_instance_id productInstance.Instance_ID%TYPE;
  v_child_category        product.Category%TYPE := 'Commodity'; -- Pass category
  v_max_existing_batch_lot NUMBER;
  v_next_batch_lot_num   NUMBER;
  v_serial_number        serialized.Serial_Number%TYPE;
  v_batch_number         serialized.Batch_Number%TYPE; -- Shared batch for serialized children of *this* parent
  v_expiration_date      commodity.Expiration_Date%TYPE;
  v_quantity_to_create   commodity.Quantity%TYPE; -- Quantity for the new child instance

BEGIN
  -- Step 1: Create the new child productInstance
  INSERT INTO productInstance (Product_ID, Date_Manufactured, Is_Recalled)
  VALUES (127.0, TIMESTAMP '2024-10-02 15:52:22', 0)
  RETURNING Instance_ID INTO v_new_child_instance_id;

  -- Step 2: Create the corresponding subtype record
  IF v_child_category = 'Commodity' THEN
    -- Find max existing Batch_Number for this specific Child_PID
    SELECT NVL(MAX(c.Batch_Number), 0) INTO v_max_existing_batch_lot
    FROM commodity c JOIN productInstance pi ON c.Instance_ID = pi.Instance_ID
    WHERE pi.Product_ID = 127.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next batch

    v_expiration_date := TIMESTAMP '2024-10-02 15:52:22' + INTERVAL '136' DAY;
    v_quantity_to_create := ROUND(1.1, 1);

    INSERT INTO commodity (Instance_ID, Batch_Number, Expiration_Date, Quantity)
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Packaged' THEN
    -- Find max existing Lot_Number for this specific Child_PID
    SELECT NVL(MAX(p.Lot_Number), 0) INTO v_max_existing_batch_lot
    FROM packaged p JOIN productInstance pi ON p.Instance_ID = pi.Instance_ID -- Assuming 'packaged' table name
    WHERE pi.Product_ID = 127.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next lot

    v_expiration_date := TIMESTAMP '2024-10-02 15:52:22' + INTERVAL '412' DAY;
    v_quantity_to_create := ROUND(1.1, 1);

    INSERT INTO packaged (Instance_ID, Lot_Number, Expiration_Date, Quantity) -- Assuming 'packaged' table name
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Serialized' THEN
    -- Assign a unique serial number
    -- Using Instance ID guarantees uniqueness within this context
    v_serial_number := 'SN-' || TO_CHAR(127.0) || '-' || TO_CHAR(v_new_child_instance_id) || '-' || SUBSTR(SYS_GUID(),1,8);
    -- Assign a batch number - use Product_ID of the *parent* instance as the batch for simplicity? Or a sequence?
    -- Let's use the Parent_IID itself as a simple batch identifier for this run.
    v_batch_number := 740.0; -- All children created FOR this parent get same batch number

    INSERT INTO serialized (Instance_ID, Serial_Number, Batch_Number)
    VALUES (v_new_child_instance_id, v_serial_number, v_batch_number);

    -- Quantity for usesComponent link for serialized is typically 1
    v_quantity_to_create := 1;

  END IF;

  -- Step 3: Create the usesComponent link
  -- Quantity_Used is the Quantity_Needed from needsComponent (which matches child quantity for non-serialized)
  IF v_child_category IN ('Commodity', 'Packaged', 'Serialized') THEN -- Only insert if subtype was handled
      INSERT INTO usesComponent (Parent_IID, Child_IID, Quantity_Used)
      VALUES (740.0, v_new_child_instance_id, ROUND(1.1, 1)); -- Use rounded quantity needed
  END IF;

EXCEPTION
  WHEN OTHERS THEN
    DBMS_OUTPUT.PUT_LINE('Error processing Parent_IID=' || 740.0 || ', Child_PID=' || 127.0 || ': ' || SQLERRM);
    -- Decide if you want to rollback just this block or let the main exception handler catch it
END;
/
DECLARE
  v_new_child_instance_id productInstance.Instance_ID%TYPE;
  v_child_category        product.Category%TYPE := 'Commodity'; -- Pass category
  v_max_existing_batch_lot NUMBER;
  v_next_batch_lot_num   NUMBER;
  v_serial_number        serialized.Serial_Number%TYPE;
  v_batch_number         serialized.Batch_Number%TYPE; -- Shared batch for serialized children of *this* parent
  v_expiration_date      commodity.Expiration_Date%TYPE;
  v_quantity_to_create   commodity.Quantity%TYPE; -- Quantity for the new child instance

BEGIN
  -- Step 1: Create the new child productInstance
  INSERT INTO productInstance (Product_ID, Date_Manufactured, Is_Recalled)
  VALUES (217.0, TIMESTAMP '2024-05-25 20:47:05', 0)
  RETURNING Instance_ID INTO v_new_child_instance_id;

  -- Step 2: Create the corresponding subtype record
  IF v_child_category = 'Commodity' THEN
    -- Find max existing Batch_Number for this specific Child_PID
    SELECT NVL(MAX(c.Batch_Number), 0) INTO v_max_existing_batch_lot
    FROM commodity c JOIN productInstance pi ON c.Instance_ID = pi.Instance_ID
    WHERE pi.Product_ID = 217.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next batch

    v_expiration_date := TIMESTAMP '2024-05-25 20:47:05' + INTERVAL '700' DAY;
    v_quantity_to_create := ROUND(1.8, 1);

    INSERT INTO commodity (Instance_ID, Batch_Number, Expiration_Date, Quantity)
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Packaged' THEN
    -- Find max existing Lot_Number for this specific Child_PID
    SELECT NVL(MAX(p.Lot_Number), 0) INTO v_max_existing_batch_lot
    FROM packaged p JOIN productInstance pi ON p.Instance_ID = pi.Instance_ID -- Assuming 'packaged' table name
    WHERE pi.Product_ID = 217.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next lot

    v_expiration_date := TIMESTAMP '2024-05-25 20:47:05' + INTERVAL '587' DAY;
    v_quantity_to_create := ROUND(1.8, 1);

    INSERT INTO packaged (Instance_ID, Lot_Number, Expiration_Date, Quantity) -- Assuming 'packaged' table name
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Serialized' THEN
    -- Assign a unique serial number
    -- Using Instance ID guarantees uniqueness within this context
    v_serial_number := 'SN-' || TO_CHAR(217.0) || '-' || TO_CHAR(v_new_child_instance_id) || '-' || SUBSTR(SYS_GUID(),1,8);
    -- Assign a batch number - use Product_ID of the *parent* instance as the batch for simplicity? Or a sequence?
    -- Let's use the Parent_IID itself as a simple batch identifier for this run.
    v_batch_number := 740.0; -- All children created FOR this parent get same batch number

    INSERT INTO serialized (Instance_ID, Serial_Number, Batch_Number)
    VALUES (v_new_child_instance_id, v_serial_number, v_batch_number);

    -- Quantity for usesComponent link for serialized is typically 1
    v_quantity_to_create := 1;

  END IF;

  -- Step 3: Create the usesComponent link
  -- Quantity_Used is the Quantity_Needed from needsComponent (which matches child quantity for non-serialized)
  IF v_child_category IN ('Commodity', 'Packaged', 'Serialized') THEN -- Only insert if subtype was handled
      INSERT INTO usesComponent (Parent_IID, Child_IID, Quantity_Used)
      VALUES (740.0, v_new_child_instance_id, ROUND(1.8, 1)); -- Use rounded quantity needed
  END IF;

EXCEPTION
  WHEN OTHERS THEN
    DBMS_OUTPUT.PUT_LINE('Error processing Parent_IID=' || 740.0 || ', Child_PID=' || 217.0 || ': ' || SQLERRM);
    -- Decide if you want to rollback just this block or let the main exception handler catch it
END;
/
DECLARE
  v_new_child_instance_id productInstance.Instance_ID%TYPE;
  v_child_category        product.Category%TYPE := 'Commodity'; -- Pass category
  v_max_existing_batch_lot NUMBER;
  v_next_batch_lot_num   NUMBER;
  v_serial_number        serialized.Serial_Number%TYPE;
  v_batch_number         serialized.Batch_Number%TYPE; -- Shared batch for serialized children of *this* parent
  v_expiration_date      commodity.Expiration_Date%TYPE;
  v_quantity_to_create   commodity.Quantity%TYPE; -- Quantity for the new child instance

BEGIN
  -- Step 1: Create the new child productInstance
  INSERT INTO productInstance (Product_ID, Date_Manufactured, Is_Recalled)
  VALUES (209.0, TIMESTAMP '2024-09-17 01:41:38', 0)
  RETURNING Instance_ID INTO v_new_child_instance_id;

  -- Step 2: Create the corresponding subtype record
  IF v_child_category = 'Commodity' THEN
    -- Find max existing Batch_Number for this specific Child_PID
    SELECT NVL(MAX(c.Batch_Number), 0) INTO v_max_existing_batch_lot
    FROM commodity c JOIN productInstance pi ON c.Instance_ID = pi.Instance_ID
    WHERE pi.Product_ID = 209.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next batch

    v_expiration_date := TIMESTAMP '2024-09-17 01:41:38' + INTERVAL '587' DAY;
    v_quantity_to_create := ROUND(0.5, 1);

    INSERT INTO commodity (Instance_ID, Batch_Number, Expiration_Date, Quantity)
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Packaged' THEN
    -- Find max existing Lot_Number for this specific Child_PID
    SELECT NVL(MAX(p.Lot_Number), 0) INTO v_max_existing_batch_lot
    FROM packaged p JOIN productInstance pi ON p.Instance_ID = pi.Instance_ID -- Assuming 'packaged' table name
    WHERE pi.Product_ID = 209.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next lot

    v_expiration_date := TIMESTAMP '2024-09-17 01:41:38' + INTERVAL '598' DAY;
    v_quantity_to_create := ROUND(0.5, 1);

    INSERT INTO packaged (Instance_ID, Lot_Number, Expiration_Date, Quantity) -- Assuming 'packaged' table name
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Serialized' THEN
    -- Assign a unique serial number
    -- Using Instance ID guarantees uniqueness within this context
    v_serial_number := 'SN-' || TO_CHAR(209.0) || '-' || TO_CHAR(v_new_child_instance_id) || '-' || SUBSTR(SYS_GUID(),1,8);
    -- Assign a batch number - use Product_ID of the *parent* instance as the batch for simplicity? Or a sequence?
    -- Let's use the Parent_IID itself as a simple batch identifier for this run.
    v_batch_number := 740.0; -- All children created FOR this parent get same batch number

    INSERT INTO serialized (Instance_ID, Serial_Number, Batch_Number)
    VALUES (v_new_child_instance_id, v_serial_number, v_batch_number);

    -- Quantity for usesComponent link for serialized is typically 1
    v_quantity_to_create := 1;

  END IF;

  -- Step 3: Create the usesComponent link
  -- Quantity_Used is the Quantity_Needed from needsComponent (which matches child quantity for non-serialized)
  IF v_child_category IN ('Commodity', 'Packaged', 'Serialized') THEN -- Only insert if subtype was handled
      INSERT INTO usesComponent (Parent_IID, Child_IID, Quantity_Used)
      VALUES (740.0, v_new_child_instance_id, ROUND(0.5, 1)); -- Use rounded quantity needed
  END IF;

EXCEPTION
  WHEN OTHERS THEN
    DBMS_OUTPUT.PUT_LINE('Error processing Parent_IID=' || 740.0 || ', Child_PID=' || 209.0 || ': ' || SQLERRM);
    -- Decide if you want to rollback just this block or let the main exception handler catch it
END;
/
DECLARE
  v_new_child_instance_id productInstance.Instance_ID%TYPE;
  v_child_category        product.Category%TYPE := 'Commodity'; -- Pass category
  v_max_existing_batch_lot NUMBER;
  v_next_batch_lot_num   NUMBER;
  v_serial_number        serialized.Serial_Number%TYPE;
  v_batch_number         serialized.Batch_Number%TYPE; -- Shared batch for serialized children of *this* parent
  v_expiration_date      commodity.Expiration_Date%TYPE;
  v_quantity_to_create   commodity.Quantity%TYPE; -- Quantity for the new child instance

BEGIN
  -- Step 1: Create the new child productInstance
  INSERT INTO productInstance (Product_ID, Date_Manufactured, Is_Recalled)
  VALUES (119.0, TIMESTAMP '2025-03-22 17:54:57', 0)
  RETURNING Instance_ID INTO v_new_child_instance_id;

  -- Step 2: Create the corresponding subtype record
  IF v_child_category = 'Commodity' THEN
    -- Find max existing Batch_Number for this specific Child_PID
    SELECT NVL(MAX(c.Batch_Number), 0) INTO v_max_existing_batch_lot
    FROM commodity c JOIN productInstance pi ON c.Instance_ID = pi.Instance_ID
    WHERE pi.Product_ID = 119.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next batch

    v_expiration_date := TIMESTAMP '2025-03-22 17:54:57' + INTERVAL '549' DAY;
    v_quantity_to_create := ROUND(0.6, 1);

    INSERT INTO commodity (Instance_ID, Batch_Number, Expiration_Date, Quantity)
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Packaged' THEN
    -- Find max existing Lot_Number for this specific Child_PID
    SELECT NVL(MAX(p.Lot_Number), 0) INTO v_max_existing_batch_lot
    FROM packaged p JOIN productInstance pi ON p.Instance_ID = pi.Instance_ID -- Assuming 'packaged' table name
    WHERE pi.Product_ID = 119.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next lot

    v_expiration_date := TIMESTAMP '2025-03-22 17:54:57' + INTERVAL '624' DAY;
    v_quantity_to_create := ROUND(0.6, 1);

    INSERT INTO packaged (Instance_ID, Lot_Number, Expiration_Date, Quantity) -- Assuming 'packaged' table name
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Serialized' THEN
    -- Assign a unique serial number
    -- Using Instance ID guarantees uniqueness within this context
    v_serial_number := 'SN-' || TO_CHAR(119.0) || '-' || TO_CHAR(v_new_child_instance_id) || '-' || SUBSTR(SYS_GUID(),1,8);
    -- Assign a batch number - use Product_ID of the *parent* instance as the batch for simplicity? Or a sequence?
    -- Let's use the Parent_IID itself as a simple batch identifier for this run.
    v_batch_number := 740.0; -- All children created FOR this parent get same batch number

    INSERT INTO serialized (Instance_ID, Serial_Number, Batch_Number)
    VALUES (v_new_child_instance_id, v_serial_number, v_batch_number);

    -- Quantity for usesComponent link for serialized is typically 1
    v_quantity_to_create := 1;

  END IF;

  -- Step 3: Create the usesComponent link
  -- Quantity_Used is the Quantity_Needed from needsComponent (which matches child quantity for non-serialized)
  IF v_child_category IN ('Commodity', 'Packaged', 'Serialized') THEN -- Only insert if subtype was handled
      INSERT INTO usesComponent (Parent_IID, Child_IID, Quantity_Used)
      VALUES (740.0, v_new_child_instance_id, ROUND(0.6, 1)); -- Use rounded quantity needed
  END IF;

EXCEPTION
  WHEN OTHERS THEN
    DBMS_OUTPUT.PUT_LINE('Error processing Parent_IID=' || 740.0 || ', Child_PID=' || 119.0 || ': ' || SQLERRM);
    -- Decide if you want to rollback just this block or let the main exception handler catch it
END;
/
DECLARE
  v_new_child_instance_id productInstance.Instance_ID%TYPE;
  v_child_category        product.Category%TYPE := 'Commodity'; -- Pass category
  v_max_existing_batch_lot NUMBER;
  v_next_batch_lot_num   NUMBER;
  v_serial_number        serialized.Serial_Number%TYPE;
  v_batch_number         serialized.Batch_Number%TYPE; -- Shared batch for serialized children of *this* parent
  v_expiration_date      commodity.Expiration_Date%TYPE;
  v_quantity_to_create   commodity.Quantity%TYPE; -- Quantity for the new child instance

BEGIN
  -- Step 1: Create the new child productInstance
  INSERT INTO productInstance (Product_ID, Date_Manufactured, Is_Recalled)
  VALUES (150.0, TIMESTAMP '2024-05-10 20:26:13', 0)
  RETURNING Instance_ID INTO v_new_child_instance_id;

  -- Step 2: Create the corresponding subtype record
  IF v_child_category = 'Commodity' THEN
    -- Find max existing Batch_Number for this specific Child_PID
    SELECT NVL(MAX(c.Batch_Number), 0) INTO v_max_existing_batch_lot
    FROM commodity c JOIN productInstance pi ON c.Instance_ID = pi.Instance_ID
    WHERE pi.Product_ID = 150.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next batch

    v_expiration_date := TIMESTAMP '2024-05-10 20:26:13' + INTERVAL '663' DAY;
    v_quantity_to_create := ROUND(1.2, 1);

    INSERT INTO commodity (Instance_ID, Batch_Number, Expiration_Date, Quantity)
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Packaged' THEN
    -- Find max existing Lot_Number for this specific Child_PID
    SELECT NVL(MAX(p.Lot_Number), 0) INTO v_max_existing_batch_lot
    FROM packaged p JOIN productInstance pi ON p.Instance_ID = pi.Instance_ID -- Assuming 'packaged' table name
    WHERE pi.Product_ID = 150.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next lot

    v_expiration_date := TIMESTAMP '2024-05-10 20:26:13' + INTERVAL '345' DAY;
    v_quantity_to_create := ROUND(1.2, 1);

    INSERT INTO packaged (Instance_ID, Lot_Number, Expiration_Date, Quantity) -- Assuming 'packaged' table name
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Serialized' THEN
    -- Assign a unique serial number
    -- Using Instance ID guarantees uniqueness within this context
    v_serial_number := 'SN-' || TO_CHAR(150.0) || '-' || TO_CHAR(v_new_child_instance_id) || '-' || SUBSTR(SYS_GUID(),1,8);
    -- Assign a batch number - use Product_ID of the *parent* instance as the batch for simplicity? Or a sequence?
    -- Let's use the Parent_IID itself as a simple batch identifier for this run.
    v_batch_number := 775.0; -- All children created FOR this parent get same batch number

    INSERT INTO serialized (Instance_ID, Serial_Number, Batch_Number)
    VALUES (v_new_child_instance_id, v_serial_number, v_batch_number);

    -- Quantity for usesComponent link for serialized is typically 1
    v_quantity_to_create := 1;

  END IF;

  -- Step 3: Create the usesComponent link
  -- Quantity_Used is the Quantity_Needed from needsComponent (which matches child quantity for non-serialized)
  IF v_child_category IN ('Commodity', 'Packaged', 'Serialized') THEN -- Only insert if subtype was handled
      INSERT INTO usesComponent (Parent_IID, Child_IID, Quantity_Used)
      VALUES (775.0, v_new_child_instance_id, ROUND(1.2, 1)); -- Use rounded quantity needed
  END IF;

EXCEPTION
  WHEN OTHERS THEN
    DBMS_OUTPUT.PUT_LINE('Error processing Parent_IID=' || 775.0 || ', Child_PID=' || 150.0 || ': ' || SQLERRM);
    -- Decide if you want to rollback just this block or let the main exception handler catch it
END;
/
DECLARE
  v_new_child_instance_id productInstance.Instance_ID%TYPE;
  v_child_category        product.Category%TYPE := 'Commodity'; -- Pass category
  v_max_existing_batch_lot NUMBER;
  v_next_batch_lot_num   NUMBER;
  v_serial_number        serialized.Serial_Number%TYPE;
  v_batch_number         serialized.Batch_Number%TYPE; -- Shared batch for serialized children of *this* parent
  v_expiration_date      commodity.Expiration_Date%TYPE;
  v_quantity_to_create   commodity.Quantity%TYPE; -- Quantity for the new child instance

BEGIN
  -- Step 1: Create the new child productInstance
  INSERT INTO productInstance (Product_ID, Date_Manufactured, Is_Recalled)
  VALUES (229.0, TIMESTAMP '2024-10-19 01:12:02', 0)
  RETURNING Instance_ID INTO v_new_child_instance_id;

  -- Step 2: Create the corresponding subtype record
  IF v_child_category = 'Commodity' THEN
    -- Find max existing Batch_Number for this specific Child_PID
    SELECT NVL(MAX(c.Batch_Number), 0) INTO v_max_existing_batch_lot
    FROM commodity c JOIN productInstance pi ON c.Instance_ID = pi.Instance_ID
    WHERE pi.Product_ID = 229.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next batch

    v_expiration_date := TIMESTAMP '2024-10-19 01:12:02' + INTERVAL '728' DAY;
    v_quantity_to_create := ROUND(0.3, 1);

    INSERT INTO commodity (Instance_ID, Batch_Number, Expiration_Date, Quantity)
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Packaged' THEN
    -- Find max existing Lot_Number for this specific Child_PID
    SELECT NVL(MAX(p.Lot_Number), 0) INTO v_max_existing_batch_lot
    FROM packaged p JOIN productInstance pi ON p.Instance_ID = pi.Instance_ID -- Assuming 'packaged' table name
    WHERE pi.Product_ID = 229.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next lot

    v_expiration_date := TIMESTAMP '2024-10-19 01:12:02' + INTERVAL '165' DAY;
    v_quantity_to_create := ROUND(0.3, 1);

    INSERT INTO packaged (Instance_ID, Lot_Number, Expiration_Date, Quantity) -- Assuming 'packaged' table name
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Serialized' THEN
    -- Assign a unique serial number
    -- Using Instance ID guarantees uniqueness within this context
    v_serial_number := 'SN-' || TO_CHAR(229.0) || '-' || TO_CHAR(v_new_child_instance_id) || '-' || SUBSTR(SYS_GUID(),1,8);
    -- Assign a batch number - use Product_ID of the *parent* instance as the batch for simplicity? Or a sequence?
    -- Let's use the Parent_IID itself as a simple batch identifier for this run.
    v_batch_number := 775.0; -- All children created FOR this parent get same batch number

    INSERT INTO serialized (Instance_ID, Serial_Number, Batch_Number)
    VALUES (v_new_child_instance_id, v_serial_number, v_batch_number);

    -- Quantity for usesComponent link for serialized is typically 1
    v_quantity_to_create := 1;

  END IF;

  -- Step 3: Create the usesComponent link
  -- Quantity_Used is the Quantity_Needed from needsComponent (which matches child quantity for non-serialized)
  IF v_child_category IN ('Commodity', 'Packaged', 'Serialized') THEN -- Only insert if subtype was handled
      INSERT INTO usesComponent (Parent_IID, Child_IID, Quantity_Used)
      VALUES (775.0, v_new_child_instance_id, ROUND(0.3, 1)); -- Use rounded quantity needed
  END IF;

EXCEPTION
  WHEN OTHERS THEN
    DBMS_OUTPUT.PUT_LINE('Error processing Parent_IID=' || 775.0 || ', Child_PID=' || 229.0 || ': ' || SQLERRM);
    -- Decide if you want to rollback just this block or let the main exception handler catch it
END;
/
DECLARE
  v_new_child_instance_id productInstance.Instance_ID%TYPE;
  v_child_category        product.Category%TYPE := 'Commodity'; -- Pass category
  v_max_existing_batch_lot NUMBER;
  v_next_batch_lot_num   NUMBER;
  v_serial_number        serialized.Serial_Number%TYPE;
  v_batch_number         serialized.Batch_Number%TYPE; -- Shared batch for serialized children of *this* parent
  v_expiration_date      commodity.Expiration_Date%TYPE;
  v_quantity_to_create   commodity.Quantity%TYPE; -- Quantity for the new child instance

BEGIN
  -- Step 1: Create the new child productInstance
  INSERT INTO productInstance (Product_ID, Date_Manufactured, Is_Recalled)
  VALUES (150.0, TIMESTAMP '2024-06-28 12:52:07', 0)
  RETURNING Instance_ID INTO v_new_child_instance_id;

  -- Step 2: Create the corresponding subtype record
  IF v_child_category = 'Commodity' THEN
    -- Find max existing Batch_Number for this specific Child_PID
    SELECT NVL(MAX(c.Batch_Number), 0) INTO v_max_existing_batch_lot
    FROM commodity c JOIN productInstance pi ON c.Instance_ID = pi.Instance_ID
    WHERE pi.Product_ID = 150.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next batch

    v_expiration_date := TIMESTAMP '2024-06-28 12:52:07' + INTERVAL '106' DAY;
    v_quantity_to_create := ROUND(1.2, 1);

    INSERT INTO commodity (Instance_ID, Batch_Number, Expiration_Date, Quantity)
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Packaged' THEN
    -- Find max existing Lot_Number for this specific Child_PID
    SELECT NVL(MAX(p.Lot_Number), 0) INTO v_max_existing_batch_lot
    FROM packaged p JOIN productInstance pi ON p.Instance_ID = pi.Instance_ID -- Assuming 'packaged' table name
    WHERE pi.Product_ID = 150.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next lot

    v_expiration_date := TIMESTAMP '2024-06-28 12:52:07' + INTERVAL '623' DAY;
    v_quantity_to_create := ROUND(1.2, 1);

    INSERT INTO packaged (Instance_ID, Lot_Number, Expiration_Date, Quantity) -- Assuming 'packaged' table name
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Serialized' THEN
    -- Assign a unique serial number
    -- Using Instance ID guarantees uniqueness within this context
    v_serial_number := 'SN-' || TO_CHAR(150.0) || '-' || TO_CHAR(v_new_child_instance_id) || '-' || SUBSTR(SYS_GUID(),1,8);
    -- Assign a batch number - use Product_ID of the *parent* instance as the batch for simplicity? Or a sequence?
    -- Let's use the Parent_IID itself as a simple batch identifier for this run.
    v_batch_number := 776.0; -- All children created FOR this parent get same batch number

    INSERT INTO serialized (Instance_ID, Serial_Number, Batch_Number)
    VALUES (v_new_child_instance_id, v_serial_number, v_batch_number);

    -- Quantity for usesComponent link for serialized is typically 1
    v_quantity_to_create := 1;

  END IF;

  -- Step 3: Create the usesComponent link
  -- Quantity_Used is the Quantity_Needed from needsComponent (which matches child quantity for non-serialized)
  IF v_child_category IN ('Commodity', 'Packaged', 'Serialized') THEN -- Only insert if subtype was handled
      INSERT INTO usesComponent (Parent_IID, Child_IID, Quantity_Used)
      VALUES (776.0, v_new_child_instance_id, ROUND(1.2, 1)); -- Use rounded quantity needed
  END IF;

EXCEPTION
  WHEN OTHERS THEN
    DBMS_OUTPUT.PUT_LINE('Error processing Parent_IID=' || 776.0 || ', Child_PID=' || 150.0 || ': ' || SQLERRM);
    -- Decide if you want to rollback just this block or let the main exception handler catch it
END;
/
DECLARE
  v_new_child_instance_id productInstance.Instance_ID%TYPE;
  v_child_category        product.Category%TYPE := 'Commodity'; -- Pass category
  v_max_existing_batch_lot NUMBER;
  v_next_batch_lot_num   NUMBER;
  v_serial_number        serialized.Serial_Number%TYPE;
  v_batch_number         serialized.Batch_Number%TYPE; -- Shared batch for serialized children of *this* parent
  v_expiration_date      commodity.Expiration_Date%TYPE;
  v_quantity_to_create   commodity.Quantity%TYPE; -- Quantity for the new child instance

BEGIN
  -- Step 1: Create the new child productInstance
  INSERT INTO productInstance (Product_ID, Date_Manufactured, Is_Recalled)
  VALUES (229.0, TIMESTAMP '2024-06-23 03:48:44', 0)
  RETURNING Instance_ID INTO v_new_child_instance_id;

  -- Step 2: Create the corresponding subtype record
  IF v_child_category = 'Commodity' THEN
    -- Find max existing Batch_Number for this specific Child_PID
    SELECT NVL(MAX(c.Batch_Number), 0) INTO v_max_existing_batch_lot
    FROM commodity c JOIN productInstance pi ON c.Instance_ID = pi.Instance_ID
    WHERE pi.Product_ID = 229.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next batch

    v_expiration_date := TIMESTAMP '2024-06-23 03:48:44' + INTERVAL '722' DAY;
    v_quantity_to_create := ROUND(0.3, 1);

    INSERT INTO commodity (Instance_ID, Batch_Number, Expiration_Date, Quantity)
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Packaged' THEN
    -- Find max existing Lot_Number for this specific Child_PID
    SELECT NVL(MAX(p.Lot_Number), 0) INTO v_max_existing_batch_lot
    FROM packaged p JOIN productInstance pi ON p.Instance_ID = pi.Instance_ID -- Assuming 'packaged' table name
    WHERE pi.Product_ID = 229.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next lot

    v_expiration_date := TIMESTAMP '2024-06-23 03:48:44' + INTERVAL '251' DAY;
    v_quantity_to_create := ROUND(0.3, 1);

    INSERT INTO packaged (Instance_ID, Lot_Number, Expiration_Date, Quantity) -- Assuming 'packaged' table name
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Serialized' THEN
    -- Assign a unique serial number
    -- Using Instance ID guarantees uniqueness within this context
    v_serial_number := 'SN-' || TO_CHAR(229.0) || '-' || TO_CHAR(v_new_child_instance_id) || '-' || SUBSTR(SYS_GUID(),1,8);
    -- Assign a batch number - use Product_ID of the *parent* instance as the batch for simplicity? Or a sequence?
    -- Let's use the Parent_IID itself as a simple batch identifier for this run.
    v_batch_number := 776.0; -- All children created FOR this parent get same batch number

    INSERT INTO serialized (Instance_ID, Serial_Number, Batch_Number)
    VALUES (v_new_child_instance_id, v_serial_number, v_batch_number);

    -- Quantity for usesComponent link for serialized is typically 1
    v_quantity_to_create := 1;

  END IF;

  -- Step 3: Create the usesComponent link
  -- Quantity_Used is the Quantity_Needed from needsComponent (which matches child quantity for non-serialized)
  IF v_child_category IN ('Commodity', 'Packaged', 'Serialized') THEN -- Only insert if subtype was handled
      INSERT INTO usesComponent (Parent_IID, Child_IID, Quantity_Used)
      VALUES (776.0, v_new_child_instance_id, ROUND(0.3, 1)); -- Use rounded quantity needed
  END IF;

EXCEPTION
  WHEN OTHERS THEN
    DBMS_OUTPUT.PUT_LINE('Error processing Parent_IID=' || 776.0 || ', Child_PID=' || 229.0 || ': ' || SQLERRM);
    -- Decide if you want to rollback just this block or let the main exception handler catch it
END;
/
DECLARE
  v_new_child_instance_id productInstance.Instance_ID%TYPE;
  v_child_category        product.Category%TYPE := 'Commodity'; -- Pass category
  v_max_existing_batch_lot NUMBER;
  v_next_batch_lot_num   NUMBER;
  v_serial_number        serialized.Serial_Number%TYPE;
  v_batch_number         serialized.Batch_Number%TYPE; -- Shared batch for serialized children of *this* parent
  v_expiration_date      commodity.Expiration_Date%TYPE;
  v_quantity_to_create   commodity.Quantity%TYPE; -- Quantity for the new child instance

BEGIN
  -- Step 1: Create the new child productInstance
  INSERT INTO productInstance (Product_ID, Date_Manufactured, Is_Recalled)
  VALUES (172.0, TIMESTAMP '2024-11-03 00:50:03', 0)
  RETURNING Instance_ID INTO v_new_child_instance_id;

  -- Step 2: Create the corresponding subtype record
  IF v_child_category = 'Commodity' THEN
    -- Find max existing Batch_Number for this specific Child_PID
    SELECT NVL(MAX(c.Batch_Number), 0) INTO v_max_existing_batch_lot
    FROM commodity c JOIN productInstance pi ON c.Instance_ID = pi.Instance_ID
    WHERE pi.Product_ID = 172.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next batch

    v_expiration_date := TIMESTAMP '2024-11-03 00:50:03' + INTERVAL '373' DAY;
    v_quantity_to_create := ROUND(1.0, 1);

    INSERT INTO commodity (Instance_ID, Batch_Number, Expiration_Date, Quantity)
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Packaged' THEN
    -- Find max existing Lot_Number for this specific Child_PID
    SELECT NVL(MAX(p.Lot_Number), 0) INTO v_max_existing_batch_lot
    FROM packaged p JOIN productInstance pi ON p.Instance_ID = pi.Instance_ID -- Assuming 'packaged' table name
    WHERE pi.Product_ID = 172.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next lot

    v_expiration_date := TIMESTAMP '2024-11-03 00:50:03' + INTERVAL '403' DAY;
    v_quantity_to_create := ROUND(1.0, 1);

    INSERT INTO packaged (Instance_ID, Lot_Number, Expiration_Date, Quantity) -- Assuming 'packaged' table name
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Serialized' THEN
    -- Assign a unique serial number
    -- Using Instance ID guarantees uniqueness within this context
    v_serial_number := 'SN-' || TO_CHAR(172.0) || '-' || TO_CHAR(v_new_child_instance_id) || '-' || SUBSTR(SYS_GUID(),1,8);
    -- Assign a batch number - use Product_ID of the *parent* instance as the batch for simplicity? Or a sequence?
    -- Let's use the Parent_IID itself as a simple batch identifier for this run.
    v_batch_number := 783.0; -- All children created FOR this parent get same batch number

    INSERT INTO serialized (Instance_ID, Serial_Number, Batch_Number)
    VALUES (v_new_child_instance_id, v_serial_number, v_batch_number);

    -- Quantity for usesComponent link for serialized is typically 1
    v_quantity_to_create := 1;

  END IF;

  -- Step 3: Create the usesComponent link
  -- Quantity_Used is the Quantity_Needed from needsComponent (which matches child quantity for non-serialized)
  IF v_child_category IN ('Commodity', 'Packaged', 'Serialized') THEN -- Only insert if subtype was handled
      INSERT INTO usesComponent (Parent_IID, Child_IID, Quantity_Used)
      VALUES (783.0, v_new_child_instance_id, ROUND(1.0, 1)); -- Use rounded quantity needed
  END IF;

EXCEPTION
  WHEN OTHERS THEN
    DBMS_OUTPUT.PUT_LINE('Error processing Parent_IID=' || 783.0 || ', Child_PID=' || 172.0 || ': ' || SQLERRM);
    -- Decide if you want to rollback just this block or let the main exception handler catch it
END;
/
DECLARE
  v_new_child_instance_id productInstance.Instance_ID%TYPE;
  v_child_category        product.Category%TYPE := 'Commodity'; -- Pass category
  v_max_existing_batch_lot NUMBER;
  v_next_batch_lot_num   NUMBER;
  v_serial_number        serialized.Serial_Number%TYPE;
  v_batch_number         serialized.Batch_Number%TYPE; -- Shared batch for serialized children of *this* parent
  v_expiration_date      commodity.Expiration_Date%TYPE;
  v_quantity_to_create   commodity.Quantity%TYPE; -- Quantity for the new child instance

BEGIN
  -- Step 1: Create the new child productInstance
  INSERT INTO productInstance (Product_ID, Date_Manufactured, Is_Recalled)
  VALUES (229.0, TIMESTAMP '2025-04-09 03:14:32', 0)
  RETURNING Instance_ID INTO v_new_child_instance_id;

  -- Step 2: Create the corresponding subtype record
  IF v_child_category = 'Commodity' THEN
    -- Find max existing Batch_Number for this specific Child_PID
    SELECT NVL(MAX(c.Batch_Number), 0) INTO v_max_existing_batch_lot
    FROM commodity c JOIN productInstance pi ON c.Instance_ID = pi.Instance_ID
    WHERE pi.Product_ID = 229.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next batch

    v_expiration_date := TIMESTAMP '2025-04-09 03:14:32' + INTERVAL '329' DAY;
    v_quantity_to_create := ROUND(0.6, 1);

    INSERT INTO commodity (Instance_ID, Batch_Number, Expiration_Date, Quantity)
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Packaged' THEN
    -- Find max existing Lot_Number for this specific Child_PID
    SELECT NVL(MAX(p.Lot_Number), 0) INTO v_max_existing_batch_lot
    FROM packaged p JOIN productInstance pi ON p.Instance_ID = pi.Instance_ID -- Assuming 'packaged' table name
    WHERE pi.Product_ID = 229.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next lot

    v_expiration_date := TIMESTAMP '2025-04-09 03:14:32' + INTERVAL '193' DAY;
    v_quantity_to_create := ROUND(0.6, 1);

    INSERT INTO packaged (Instance_ID, Lot_Number, Expiration_Date, Quantity) -- Assuming 'packaged' table name
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Serialized' THEN
    -- Assign a unique serial number
    -- Using Instance ID guarantees uniqueness within this context
    v_serial_number := 'SN-' || TO_CHAR(229.0) || '-' || TO_CHAR(v_new_child_instance_id) || '-' || SUBSTR(SYS_GUID(),1,8);
    -- Assign a batch number - use Product_ID of the *parent* instance as the batch for simplicity? Or a sequence?
    -- Let's use the Parent_IID itself as a simple batch identifier for this run.
    v_batch_number := 783.0; -- All children created FOR this parent get same batch number

    INSERT INTO serialized (Instance_ID, Serial_Number, Batch_Number)
    VALUES (v_new_child_instance_id, v_serial_number, v_batch_number);

    -- Quantity for usesComponent link for serialized is typically 1
    v_quantity_to_create := 1;

  END IF;

  -- Step 3: Create the usesComponent link
  -- Quantity_Used is the Quantity_Needed from needsComponent (which matches child quantity for non-serialized)
  IF v_child_category IN ('Commodity', 'Packaged', 'Serialized') THEN -- Only insert if subtype was handled
      INSERT INTO usesComponent (Parent_IID, Child_IID, Quantity_Used)
      VALUES (783.0, v_new_child_instance_id, ROUND(0.6, 1)); -- Use rounded quantity needed
  END IF;

EXCEPTION
  WHEN OTHERS THEN
    DBMS_OUTPUT.PUT_LINE('Error processing Parent_IID=' || 783.0 || ', Child_PID=' || 229.0 || ': ' || SQLERRM);
    -- Decide if you want to rollback just this block or let the main exception handler catch it
END;
/
DECLARE
  v_new_child_instance_id productInstance.Instance_ID%TYPE;
  v_child_category        product.Category%TYPE := 'Commodity'; -- Pass category
  v_max_existing_batch_lot NUMBER;
  v_next_batch_lot_num   NUMBER;
  v_serial_number        serialized.Serial_Number%TYPE;
  v_batch_number         serialized.Batch_Number%TYPE; -- Shared batch for serialized children of *this* parent
  v_expiration_date      commodity.Expiration_Date%TYPE;
  v_quantity_to_create   commodity.Quantity%TYPE; -- Quantity for the new child instance

BEGIN
  -- Step 1: Create the new child productInstance
  INSERT INTO productInstance (Product_ID, Date_Manufactured, Is_Recalled)
  VALUES (181.0, TIMESTAMP '2024-06-28 11:18:03', 0)
  RETURNING Instance_ID INTO v_new_child_instance_id;

  -- Step 2: Create the corresponding subtype record
  IF v_child_category = 'Commodity' THEN
    -- Find max existing Batch_Number for this specific Child_PID
    SELECT NVL(MAX(c.Batch_Number), 0) INTO v_max_existing_batch_lot
    FROM commodity c JOIN productInstance pi ON c.Instance_ID = pi.Instance_ID
    WHERE pi.Product_ID = 181.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next batch

    v_expiration_date := TIMESTAMP '2024-06-28 11:18:03' + INTERVAL '420' DAY;
    v_quantity_to_create := ROUND(1.1, 1);

    INSERT INTO commodity (Instance_ID, Batch_Number, Expiration_Date, Quantity)
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Packaged' THEN
    -- Find max existing Lot_Number for this specific Child_PID
    SELECT NVL(MAX(p.Lot_Number), 0) INTO v_max_existing_batch_lot
    FROM packaged p JOIN productInstance pi ON p.Instance_ID = pi.Instance_ID -- Assuming 'packaged' table name
    WHERE pi.Product_ID = 181.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next lot

    v_expiration_date := TIMESTAMP '2024-06-28 11:18:03' + INTERVAL '480' DAY;
    v_quantity_to_create := ROUND(1.1, 1);

    INSERT INTO packaged (Instance_ID, Lot_Number, Expiration_Date, Quantity) -- Assuming 'packaged' table name
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Serialized' THEN
    -- Assign a unique serial number
    -- Using Instance ID guarantees uniqueness within this context
    v_serial_number := 'SN-' || TO_CHAR(181.0) || '-' || TO_CHAR(v_new_child_instance_id) || '-' || SUBSTR(SYS_GUID(),1,8);
    -- Assign a batch number - use Product_ID of the *parent* instance as the batch for simplicity? Or a sequence?
    -- Let's use the Parent_IID itself as a simple batch identifier for this run.
    v_batch_number := 783.0; -- All children created FOR this parent get same batch number

    INSERT INTO serialized (Instance_ID, Serial_Number, Batch_Number)
    VALUES (v_new_child_instance_id, v_serial_number, v_batch_number);

    -- Quantity for usesComponent link for serialized is typically 1
    v_quantity_to_create := 1;

  END IF;

  -- Step 3: Create the usesComponent link
  -- Quantity_Used is the Quantity_Needed from needsComponent (which matches child quantity for non-serialized)
  IF v_child_category IN ('Commodity', 'Packaged', 'Serialized') THEN -- Only insert if subtype was handled
      INSERT INTO usesComponent (Parent_IID, Child_IID, Quantity_Used)
      VALUES (783.0, v_new_child_instance_id, ROUND(1.1, 1)); -- Use rounded quantity needed
  END IF;

EXCEPTION
  WHEN OTHERS THEN
    DBMS_OUTPUT.PUT_LINE('Error processing Parent_IID=' || 783.0 || ', Child_PID=' || 181.0 || ': ' || SQLERRM);
    -- Decide if you want to rollback just this block or let the main exception handler catch it
END;
/
DECLARE
  v_new_child_instance_id productInstance.Instance_ID%TYPE;
  v_child_category        product.Category%TYPE := 'Commodity'; -- Pass category
  v_max_existing_batch_lot NUMBER;
  v_next_batch_lot_num   NUMBER;
  v_serial_number        serialized.Serial_Number%TYPE;
  v_batch_number         serialized.Batch_Number%TYPE; -- Shared batch for serialized children of *this* parent
  v_expiration_date      commodity.Expiration_Date%TYPE;
  v_quantity_to_create   commodity.Quantity%TYPE; -- Quantity for the new child instance

BEGIN
  -- Step 1: Create the new child productInstance
  INSERT INTO productInstance (Product_ID, Date_Manufactured, Is_Recalled)
  VALUES (172.0, TIMESTAMP '2024-10-03 13:48:02', 0)
  RETURNING Instance_ID INTO v_new_child_instance_id;

  -- Step 2: Create the corresponding subtype record
  IF v_child_category = 'Commodity' THEN
    -- Find max existing Batch_Number for this specific Child_PID
    SELECT NVL(MAX(c.Batch_Number), 0) INTO v_max_existing_batch_lot
    FROM commodity c JOIN productInstance pi ON c.Instance_ID = pi.Instance_ID
    WHERE pi.Product_ID = 172.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next batch

    v_expiration_date := TIMESTAMP '2024-10-03 13:48:02' + INTERVAL '150' DAY;
    v_quantity_to_create := ROUND(1.0, 1);

    INSERT INTO commodity (Instance_ID, Batch_Number, Expiration_Date, Quantity)
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Packaged' THEN
    -- Find max existing Lot_Number for this specific Child_PID
    SELECT NVL(MAX(p.Lot_Number), 0) INTO v_max_existing_batch_lot
    FROM packaged p JOIN productInstance pi ON p.Instance_ID = pi.Instance_ID -- Assuming 'packaged' table name
    WHERE pi.Product_ID = 172.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next lot

    v_expiration_date := TIMESTAMP '2024-10-03 13:48:02' + INTERVAL '645' DAY;
    v_quantity_to_create := ROUND(1.0, 1);

    INSERT INTO packaged (Instance_ID, Lot_Number, Expiration_Date, Quantity) -- Assuming 'packaged' table name
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Serialized' THEN
    -- Assign a unique serial number
    -- Using Instance ID guarantees uniqueness within this context
    v_serial_number := 'SN-' || TO_CHAR(172.0) || '-' || TO_CHAR(v_new_child_instance_id) || '-' || SUBSTR(SYS_GUID(),1,8);
    -- Assign a batch number - use Product_ID of the *parent* instance as the batch for simplicity? Or a sequence?
    -- Let's use the Parent_IID itself as a simple batch identifier for this run.
    v_batch_number := 784.0; -- All children created FOR this parent get same batch number

    INSERT INTO serialized (Instance_ID, Serial_Number, Batch_Number)
    VALUES (v_new_child_instance_id, v_serial_number, v_batch_number);

    -- Quantity for usesComponent link for serialized is typically 1
    v_quantity_to_create := 1;

  END IF;

  -- Step 3: Create the usesComponent link
  -- Quantity_Used is the Quantity_Needed from needsComponent (which matches child quantity for non-serialized)
  IF v_child_category IN ('Commodity', 'Packaged', 'Serialized') THEN -- Only insert if subtype was handled
      INSERT INTO usesComponent (Parent_IID, Child_IID, Quantity_Used)
      VALUES (784.0, v_new_child_instance_id, ROUND(1.0, 1)); -- Use rounded quantity needed
  END IF;

EXCEPTION
  WHEN OTHERS THEN
    DBMS_OUTPUT.PUT_LINE('Error processing Parent_IID=' || 784.0 || ', Child_PID=' || 172.0 || ': ' || SQLERRM);
    -- Decide if you want to rollback just this block or let the main exception handler catch it
END;
/
DECLARE
  v_new_child_instance_id productInstance.Instance_ID%TYPE;
  v_child_category        product.Category%TYPE := 'Commodity'; -- Pass category
  v_max_existing_batch_lot NUMBER;
  v_next_batch_lot_num   NUMBER;
  v_serial_number        serialized.Serial_Number%TYPE;
  v_batch_number         serialized.Batch_Number%TYPE; -- Shared batch for serialized children of *this* parent
  v_expiration_date      commodity.Expiration_Date%TYPE;
  v_quantity_to_create   commodity.Quantity%TYPE; -- Quantity for the new child instance

BEGIN
  -- Step 1: Create the new child productInstance
  INSERT INTO productInstance (Product_ID, Date_Manufactured, Is_Recalled)
  VALUES (229.0, TIMESTAMP '2024-06-24 09:47:49', 0)
  RETURNING Instance_ID INTO v_new_child_instance_id;

  -- Step 2: Create the corresponding subtype record
  IF v_child_category = 'Commodity' THEN
    -- Find max existing Batch_Number for this specific Child_PID
    SELECT NVL(MAX(c.Batch_Number), 0) INTO v_max_existing_batch_lot
    FROM commodity c JOIN productInstance pi ON c.Instance_ID = pi.Instance_ID
    WHERE pi.Product_ID = 229.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next batch

    v_expiration_date := TIMESTAMP '2024-06-24 09:47:49' + INTERVAL '306' DAY;
    v_quantity_to_create := ROUND(0.6, 1);

    INSERT INTO commodity (Instance_ID, Batch_Number, Expiration_Date, Quantity)
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Packaged' THEN
    -- Find max existing Lot_Number for this specific Child_PID
    SELECT NVL(MAX(p.Lot_Number), 0) INTO v_max_existing_batch_lot
    FROM packaged p JOIN productInstance pi ON p.Instance_ID = pi.Instance_ID -- Assuming 'packaged' table name
    WHERE pi.Product_ID = 229.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next lot

    v_expiration_date := TIMESTAMP '2024-06-24 09:47:49' + INTERVAL '332' DAY;
    v_quantity_to_create := ROUND(0.6, 1);

    INSERT INTO packaged (Instance_ID, Lot_Number, Expiration_Date, Quantity) -- Assuming 'packaged' table name
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Serialized' THEN
    -- Assign a unique serial number
    -- Using Instance ID guarantees uniqueness within this context
    v_serial_number := 'SN-' || TO_CHAR(229.0) || '-' || TO_CHAR(v_new_child_instance_id) || '-' || SUBSTR(SYS_GUID(),1,8);
    -- Assign a batch number - use Product_ID of the *parent* instance as the batch for simplicity? Or a sequence?
    -- Let's use the Parent_IID itself as a simple batch identifier for this run.
    v_batch_number := 784.0; -- All children created FOR this parent get same batch number

    INSERT INTO serialized (Instance_ID, Serial_Number, Batch_Number)
    VALUES (v_new_child_instance_id, v_serial_number, v_batch_number);

    -- Quantity for usesComponent link for serialized is typically 1
    v_quantity_to_create := 1;

  END IF;

  -- Step 3: Create the usesComponent link
  -- Quantity_Used is the Quantity_Needed from needsComponent (which matches child quantity for non-serialized)
  IF v_child_category IN ('Commodity', 'Packaged', 'Serialized') THEN -- Only insert if subtype was handled
      INSERT INTO usesComponent (Parent_IID, Child_IID, Quantity_Used)
      VALUES (784.0, v_new_child_instance_id, ROUND(0.6, 1)); -- Use rounded quantity needed
  END IF;

EXCEPTION
  WHEN OTHERS THEN
    DBMS_OUTPUT.PUT_LINE('Error processing Parent_IID=' || 784.0 || ', Child_PID=' || 229.0 || ': ' || SQLERRM);
    -- Decide if you want to rollback just this block or let the main exception handler catch it
END;
/
DECLARE
  v_new_child_instance_id productInstance.Instance_ID%TYPE;
  v_child_category        product.Category%TYPE := 'Commodity'; -- Pass category
  v_max_existing_batch_lot NUMBER;
  v_next_batch_lot_num   NUMBER;
  v_serial_number        serialized.Serial_Number%TYPE;
  v_batch_number         serialized.Batch_Number%TYPE; -- Shared batch for serialized children of *this* parent
  v_expiration_date      commodity.Expiration_Date%TYPE;
  v_quantity_to_create   commodity.Quantity%TYPE; -- Quantity for the new child instance

BEGIN
  -- Step 1: Create the new child productInstance
  INSERT INTO productInstance (Product_ID, Date_Manufactured, Is_Recalled)
  VALUES (181.0, TIMESTAMP '2025-01-13 00:43:36', 0)
  RETURNING Instance_ID INTO v_new_child_instance_id;

  -- Step 2: Create the corresponding subtype record
  IF v_child_category = 'Commodity' THEN
    -- Find max existing Batch_Number for this specific Child_PID
    SELECT NVL(MAX(c.Batch_Number), 0) INTO v_max_existing_batch_lot
    FROM commodity c JOIN productInstance pi ON c.Instance_ID = pi.Instance_ID
    WHERE pi.Product_ID = 181.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next batch

    v_expiration_date := TIMESTAMP '2025-01-13 00:43:36' + INTERVAL '684' DAY;
    v_quantity_to_create := ROUND(1.1, 1);

    INSERT INTO commodity (Instance_ID, Batch_Number, Expiration_Date, Quantity)
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Packaged' THEN
    -- Find max existing Lot_Number for this specific Child_PID
    SELECT NVL(MAX(p.Lot_Number), 0) INTO v_max_existing_batch_lot
    FROM packaged p JOIN productInstance pi ON p.Instance_ID = pi.Instance_ID -- Assuming 'packaged' table name
    WHERE pi.Product_ID = 181.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next lot

    v_expiration_date := TIMESTAMP '2025-01-13 00:43:36' + INTERVAL '648' DAY;
    v_quantity_to_create := ROUND(1.1, 1);

    INSERT INTO packaged (Instance_ID, Lot_Number, Expiration_Date, Quantity) -- Assuming 'packaged' table name
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Serialized' THEN
    -- Assign a unique serial number
    -- Using Instance ID guarantees uniqueness within this context
    v_serial_number := 'SN-' || TO_CHAR(181.0) || '-' || TO_CHAR(v_new_child_instance_id) || '-' || SUBSTR(SYS_GUID(),1,8);
    -- Assign a batch number - use Product_ID of the *parent* instance as the batch for simplicity? Or a sequence?
    -- Let's use the Parent_IID itself as a simple batch identifier for this run.
    v_batch_number := 784.0; -- All children created FOR this parent get same batch number

    INSERT INTO serialized (Instance_ID, Serial_Number, Batch_Number)
    VALUES (v_new_child_instance_id, v_serial_number, v_batch_number);

    -- Quantity for usesComponent link for serialized is typically 1
    v_quantity_to_create := 1;

  END IF;

  -- Step 3: Create the usesComponent link
  -- Quantity_Used is the Quantity_Needed from needsComponent (which matches child quantity for non-serialized)
  IF v_child_category IN ('Commodity', 'Packaged', 'Serialized') THEN -- Only insert if subtype was handled
      INSERT INTO usesComponent (Parent_IID, Child_IID, Quantity_Used)
      VALUES (784.0, v_new_child_instance_id, ROUND(1.1, 1)); -- Use rounded quantity needed
  END IF;

EXCEPTION
  WHEN OTHERS THEN
    DBMS_OUTPUT.PUT_LINE('Error processing Parent_IID=' || 784.0 || ', Child_PID=' || 181.0 || ': ' || SQLERRM);
    -- Decide if you want to rollback just this block or let the main exception handler catch it
END;
/
DECLARE
  v_new_child_instance_id productInstance.Instance_ID%TYPE;
  v_child_category        product.Category%TYPE := 'Commodity'; -- Pass category
  v_max_existing_batch_lot NUMBER;
  v_next_batch_lot_num   NUMBER;
  v_serial_number        serialized.Serial_Number%TYPE;
  v_batch_number         serialized.Batch_Number%TYPE; -- Shared batch for serialized children of *this* parent
  v_expiration_date      commodity.Expiration_Date%TYPE;
  v_quantity_to_create   commodity.Quantity%TYPE; -- Quantity for the new child instance

BEGIN
  -- Step 1: Create the new child productInstance
  INSERT INTO productInstance (Product_ID, Date_Manufactured, Is_Recalled)
  VALUES (172.0, TIMESTAMP '2024-05-02 05:14:56', 0)
  RETURNING Instance_ID INTO v_new_child_instance_id;

  -- Step 2: Create the corresponding subtype record
  IF v_child_category = 'Commodity' THEN
    -- Find max existing Batch_Number for this specific Child_PID
    SELECT NVL(MAX(c.Batch_Number), 0) INTO v_max_existing_batch_lot
    FROM commodity c JOIN productInstance pi ON c.Instance_ID = pi.Instance_ID
    WHERE pi.Product_ID = 172.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next batch

    v_expiration_date := TIMESTAMP '2024-05-02 05:14:56' + INTERVAL '580' DAY;
    v_quantity_to_create := ROUND(1.0, 1);

    INSERT INTO commodity (Instance_ID, Batch_Number, Expiration_Date, Quantity)
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Packaged' THEN
    -- Find max existing Lot_Number for this specific Child_PID
    SELECT NVL(MAX(p.Lot_Number), 0) INTO v_max_existing_batch_lot
    FROM packaged p JOIN productInstance pi ON p.Instance_ID = pi.Instance_ID -- Assuming 'packaged' table name
    WHERE pi.Product_ID = 172.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next lot

    v_expiration_date := TIMESTAMP '2024-05-02 05:14:56' + INTERVAL '39' DAY;
    v_quantity_to_create := ROUND(1.0, 1);

    INSERT INTO packaged (Instance_ID, Lot_Number, Expiration_Date, Quantity) -- Assuming 'packaged' table name
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Serialized' THEN
    -- Assign a unique serial number
    -- Using Instance ID guarantees uniqueness within this context
    v_serial_number := 'SN-' || TO_CHAR(172.0) || '-' || TO_CHAR(v_new_child_instance_id) || '-' || SUBSTR(SYS_GUID(),1,8);
    -- Assign a batch number - use Product_ID of the *parent* instance as the batch for simplicity? Or a sequence?
    -- Let's use the Parent_IID itself as a simple batch identifier for this run.
    v_batch_number := 785.0; -- All children created FOR this parent get same batch number

    INSERT INTO serialized (Instance_ID, Serial_Number, Batch_Number)
    VALUES (v_new_child_instance_id, v_serial_number, v_batch_number);

    -- Quantity for usesComponent link for serialized is typically 1
    v_quantity_to_create := 1;

  END IF;

  -- Step 3: Create the usesComponent link
  -- Quantity_Used is the Quantity_Needed from needsComponent (which matches child quantity for non-serialized)
  IF v_child_category IN ('Commodity', 'Packaged', 'Serialized') THEN -- Only insert if subtype was handled
      INSERT INTO usesComponent (Parent_IID, Child_IID, Quantity_Used)
      VALUES (785.0, v_new_child_instance_id, ROUND(1.0, 1)); -- Use rounded quantity needed
  END IF;

EXCEPTION
  WHEN OTHERS THEN
    DBMS_OUTPUT.PUT_LINE('Error processing Parent_IID=' || 785.0 || ', Child_PID=' || 172.0 || ': ' || SQLERRM);
    -- Decide if you want to rollback just this block or let the main exception handler catch it
END;
/
DECLARE
  v_new_child_instance_id productInstance.Instance_ID%TYPE;
  v_child_category        product.Category%TYPE := 'Commodity'; -- Pass category
  v_max_existing_batch_lot NUMBER;
  v_next_batch_lot_num   NUMBER;
  v_serial_number        serialized.Serial_Number%TYPE;
  v_batch_number         serialized.Batch_Number%TYPE; -- Shared batch for serialized children of *this* parent
  v_expiration_date      commodity.Expiration_Date%TYPE;
  v_quantity_to_create   commodity.Quantity%TYPE; -- Quantity for the new child instance

BEGIN
  -- Step 1: Create the new child productInstance
  INSERT INTO productInstance (Product_ID, Date_Manufactured, Is_Recalled)
  VALUES (229.0, TIMESTAMP '2025-04-21 05:00:39', 0)
  RETURNING Instance_ID INTO v_new_child_instance_id;

  -- Step 2: Create the corresponding subtype record
  IF v_child_category = 'Commodity' THEN
    -- Find max existing Batch_Number for this specific Child_PID
    SELECT NVL(MAX(c.Batch_Number), 0) INTO v_max_existing_batch_lot
    FROM commodity c JOIN productInstance pi ON c.Instance_ID = pi.Instance_ID
    WHERE pi.Product_ID = 229.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next batch

    v_expiration_date := TIMESTAMP '2025-04-21 05:00:39' + INTERVAL '688' DAY;
    v_quantity_to_create := ROUND(0.6, 1);

    INSERT INTO commodity (Instance_ID, Batch_Number, Expiration_Date, Quantity)
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Packaged' THEN
    -- Find max existing Lot_Number for this specific Child_PID
    SELECT NVL(MAX(p.Lot_Number), 0) INTO v_max_existing_batch_lot
    FROM packaged p JOIN productInstance pi ON p.Instance_ID = pi.Instance_ID -- Assuming 'packaged' table name
    WHERE pi.Product_ID = 229.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next lot

    v_expiration_date := TIMESTAMP '2025-04-21 05:00:39' + INTERVAL '165' DAY;
    v_quantity_to_create := ROUND(0.6, 1);

    INSERT INTO packaged (Instance_ID, Lot_Number, Expiration_Date, Quantity) -- Assuming 'packaged' table name
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Serialized' THEN
    -- Assign a unique serial number
    -- Using Instance ID guarantees uniqueness within this context
    v_serial_number := 'SN-' || TO_CHAR(229.0) || '-' || TO_CHAR(v_new_child_instance_id) || '-' || SUBSTR(SYS_GUID(),1,8);
    -- Assign a batch number - use Product_ID of the *parent* instance as the batch for simplicity? Or a sequence?
    -- Let's use the Parent_IID itself as a simple batch identifier for this run.
    v_batch_number := 785.0; -- All children created FOR this parent get same batch number

    INSERT INTO serialized (Instance_ID, Serial_Number, Batch_Number)
    VALUES (v_new_child_instance_id, v_serial_number, v_batch_number);

    -- Quantity for usesComponent link for serialized is typically 1
    v_quantity_to_create := 1;

  END IF;

  -- Step 3: Create the usesComponent link
  -- Quantity_Used is the Quantity_Needed from needsComponent (which matches child quantity for non-serialized)
  IF v_child_category IN ('Commodity', 'Packaged', 'Serialized') THEN -- Only insert if subtype was handled
      INSERT INTO usesComponent (Parent_IID, Child_IID, Quantity_Used)
      VALUES (785.0, v_new_child_instance_id, ROUND(0.6, 1)); -- Use rounded quantity needed
  END IF;

EXCEPTION
  WHEN OTHERS THEN
    DBMS_OUTPUT.PUT_LINE('Error processing Parent_IID=' || 785.0 || ', Child_PID=' || 229.0 || ': ' || SQLERRM);
    -- Decide if you want to rollback just this block or let the main exception handler catch it
END;
/
DECLARE
  v_new_child_instance_id productInstance.Instance_ID%TYPE;
  v_child_category        product.Category%TYPE := 'Commodity'; -- Pass category
  v_max_existing_batch_lot NUMBER;
  v_next_batch_lot_num   NUMBER;
  v_serial_number        serialized.Serial_Number%TYPE;
  v_batch_number         serialized.Batch_Number%TYPE; -- Shared batch for serialized children of *this* parent
  v_expiration_date      commodity.Expiration_Date%TYPE;
  v_quantity_to_create   commodity.Quantity%TYPE; -- Quantity for the new child instance

BEGIN
  -- Step 1: Create the new child productInstance
  INSERT INTO productInstance (Product_ID, Date_Manufactured, Is_Recalled)
  VALUES (181.0, TIMESTAMP '2024-09-23 10:12:59', 0)
  RETURNING Instance_ID INTO v_new_child_instance_id;

  -- Step 2: Create the corresponding subtype record
  IF v_child_category = 'Commodity' THEN
    -- Find max existing Batch_Number for this specific Child_PID
    SELECT NVL(MAX(c.Batch_Number), 0) INTO v_max_existing_batch_lot
    FROM commodity c JOIN productInstance pi ON c.Instance_ID = pi.Instance_ID
    WHERE pi.Product_ID = 181.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next batch

    v_expiration_date := TIMESTAMP '2024-09-23 10:12:59' + INTERVAL '605' DAY;
    v_quantity_to_create := ROUND(1.1, 1);

    INSERT INTO commodity (Instance_ID, Batch_Number, Expiration_Date, Quantity)
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Packaged' THEN
    -- Find max existing Lot_Number for this specific Child_PID
    SELECT NVL(MAX(p.Lot_Number), 0) INTO v_max_existing_batch_lot
    FROM packaged p JOIN productInstance pi ON p.Instance_ID = pi.Instance_ID -- Assuming 'packaged' table name
    WHERE pi.Product_ID = 181.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next lot

    v_expiration_date := TIMESTAMP '2024-09-23 10:12:59' + INTERVAL '133' DAY;
    v_quantity_to_create := ROUND(1.1, 1);

    INSERT INTO packaged (Instance_ID, Lot_Number, Expiration_Date, Quantity) -- Assuming 'packaged' table name
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Serialized' THEN
    -- Assign a unique serial number
    -- Using Instance ID guarantees uniqueness within this context
    v_serial_number := 'SN-' || TO_CHAR(181.0) || '-' || TO_CHAR(v_new_child_instance_id) || '-' || SUBSTR(SYS_GUID(),1,8);
    -- Assign a batch number - use Product_ID of the *parent* instance as the batch for simplicity? Or a sequence?
    -- Let's use the Parent_IID itself as a simple batch identifier for this run.
    v_batch_number := 785.0; -- All children created FOR this parent get same batch number

    INSERT INTO serialized (Instance_ID, Serial_Number, Batch_Number)
    VALUES (v_new_child_instance_id, v_serial_number, v_batch_number);

    -- Quantity for usesComponent link for serialized is typically 1
    v_quantity_to_create := 1;

  END IF;

  -- Step 3: Create the usesComponent link
  -- Quantity_Used is the Quantity_Needed from needsComponent (which matches child quantity for non-serialized)
  IF v_child_category IN ('Commodity', 'Packaged', 'Serialized') THEN -- Only insert if subtype was handled
      INSERT INTO usesComponent (Parent_IID, Child_IID, Quantity_Used)
      VALUES (785.0, v_new_child_instance_id, ROUND(1.1, 1)); -- Use rounded quantity needed
  END IF;

EXCEPTION
  WHEN OTHERS THEN
    DBMS_OUTPUT.PUT_LINE('Error processing Parent_IID=' || 785.0 || ', Child_PID=' || 181.0 || ': ' || SQLERRM);
    -- Decide if you want to rollback just this block or let the main exception handler catch it
END;
/
DECLARE
  v_new_child_instance_id productInstance.Instance_ID%TYPE;
  v_child_category        product.Category%TYPE := 'Commodity'; -- Pass category
  v_max_existing_batch_lot NUMBER;
  v_next_batch_lot_num   NUMBER;
  v_serial_number        serialized.Serial_Number%TYPE;
  v_batch_number         serialized.Batch_Number%TYPE; -- Shared batch for serialized children of *this* parent
  v_expiration_date      commodity.Expiration_Date%TYPE;
  v_quantity_to_create   commodity.Quantity%TYPE; -- Quantity for the new child instance

BEGIN
  -- Step 1: Create the new child productInstance
  INSERT INTO productInstance (Product_ID, Date_Manufactured, Is_Recalled)
  VALUES (172.0, TIMESTAMP '2024-10-24 12:04:48', 0)
  RETURNING Instance_ID INTO v_new_child_instance_id;

  -- Step 2: Create the corresponding subtype record
  IF v_child_category = 'Commodity' THEN
    -- Find max existing Batch_Number for this specific Child_PID
    SELECT NVL(MAX(c.Batch_Number), 0) INTO v_max_existing_batch_lot
    FROM commodity c JOIN productInstance pi ON c.Instance_ID = pi.Instance_ID
    WHERE pi.Product_ID = 172.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next batch

    v_expiration_date := TIMESTAMP '2024-10-24 12:04:48' + INTERVAL '61' DAY;
    v_quantity_to_create := ROUND(1.0, 1);

    INSERT INTO commodity (Instance_ID, Batch_Number, Expiration_Date, Quantity)
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Packaged' THEN
    -- Find max existing Lot_Number for this specific Child_PID
    SELECT NVL(MAX(p.Lot_Number), 0) INTO v_max_existing_batch_lot
    FROM packaged p JOIN productInstance pi ON p.Instance_ID = pi.Instance_ID -- Assuming 'packaged' table name
    WHERE pi.Product_ID = 172.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next lot

    v_expiration_date := TIMESTAMP '2024-10-24 12:04:48' + INTERVAL '472' DAY;
    v_quantity_to_create := ROUND(1.0, 1);

    INSERT INTO packaged (Instance_ID, Lot_Number, Expiration_Date, Quantity) -- Assuming 'packaged' table name
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Serialized' THEN
    -- Assign a unique serial number
    -- Using Instance ID guarantees uniqueness within this context
    v_serial_number := 'SN-' || TO_CHAR(172.0) || '-' || TO_CHAR(v_new_child_instance_id) || '-' || SUBSTR(SYS_GUID(),1,8);
    -- Assign a batch number - use Product_ID of the *parent* instance as the batch for simplicity? Or a sequence?
    -- Let's use the Parent_IID itself as a simple batch identifier for this run.
    v_batch_number := 786.0; -- All children created FOR this parent get same batch number

    INSERT INTO serialized (Instance_ID, Serial_Number, Batch_Number)
    VALUES (v_new_child_instance_id, v_serial_number, v_batch_number);

    -- Quantity for usesComponent link for serialized is typically 1
    v_quantity_to_create := 1;

  END IF;

  -- Step 3: Create the usesComponent link
  -- Quantity_Used is the Quantity_Needed from needsComponent (which matches child quantity for non-serialized)
  IF v_child_category IN ('Commodity', 'Packaged', 'Serialized') THEN -- Only insert if subtype was handled
      INSERT INTO usesComponent (Parent_IID, Child_IID, Quantity_Used)
      VALUES (786.0, v_new_child_instance_id, ROUND(1.0, 1)); -- Use rounded quantity needed
  END IF;

EXCEPTION
  WHEN OTHERS THEN
    DBMS_OUTPUT.PUT_LINE('Error processing Parent_IID=' || 786.0 || ', Child_PID=' || 172.0 || ': ' || SQLERRM);
    -- Decide if you want to rollback just this block or let the main exception handler catch it
END;
/
DECLARE
  v_new_child_instance_id productInstance.Instance_ID%TYPE;
  v_child_category        product.Category%TYPE := 'Commodity'; -- Pass category
  v_max_existing_batch_lot NUMBER;
  v_next_batch_lot_num   NUMBER;
  v_serial_number        serialized.Serial_Number%TYPE;
  v_batch_number         serialized.Batch_Number%TYPE; -- Shared batch for serialized children of *this* parent
  v_expiration_date      commodity.Expiration_Date%TYPE;
  v_quantity_to_create   commodity.Quantity%TYPE; -- Quantity for the new child instance

BEGIN
  -- Step 1: Create the new child productInstance
  INSERT INTO productInstance (Product_ID, Date_Manufactured, Is_Recalled)
  VALUES (229.0, TIMESTAMP '2024-12-17 11:56:03', 0)
  RETURNING Instance_ID INTO v_new_child_instance_id;

  -- Step 2: Create the corresponding subtype record
  IF v_child_category = 'Commodity' THEN
    -- Find max existing Batch_Number for this specific Child_PID
    SELECT NVL(MAX(c.Batch_Number), 0) INTO v_max_existing_batch_lot
    FROM commodity c JOIN productInstance pi ON c.Instance_ID = pi.Instance_ID
    WHERE pi.Product_ID = 229.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next batch

    v_expiration_date := TIMESTAMP '2024-12-17 11:56:03' + INTERVAL '725' DAY;
    v_quantity_to_create := ROUND(0.6, 1);

    INSERT INTO commodity (Instance_ID, Batch_Number, Expiration_Date, Quantity)
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Packaged' THEN
    -- Find max existing Lot_Number for this specific Child_PID
    SELECT NVL(MAX(p.Lot_Number), 0) INTO v_max_existing_batch_lot
    FROM packaged p JOIN productInstance pi ON p.Instance_ID = pi.Instance_ID -- Assuming 'packaged' table name
    WHERE pi.Product_ID = 229.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next lot

    v_expiration_date := TIMESTAMP '2024-12-17 11:56:03' + INTERVAL '462' DAY;
    v_quantity_to_create := ROUND(0.6, 1);

    INSERT INTO packaged (Instance_ID, Lot_Number, Expiration_Date, Quantity) -- Assuming 'packaged' table name
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Serialized' THEN
    -- Assign a unique serial number
    -- Using Instance ID guarantees uniqueness within this context
    v_serial_number := 'SN-' || TO_CHAR(229.0) || '-' || TO_CHAR(v_new_child_instance_id) || '-' || SUBSTR(SYS_GUID(),1,8);
    -- Assign a batch number - use Product_ID of the *parent* instance as the batch for simplicity? Or a sequence?
    -- Let's use the Parent_IID itself as a simple batch identifier for this run.
    v_batch_number := 786.0; -- All children created FOR this parent get same batch number

    INSERT INTO serialized (Instance_ID, Serial_Number, Batch_Number)
    VALUES (v_new_child_instance_id, v_serial_number, v_batch_number);

    -- Quantity for usesComponent link for serialized is typically 1
    v_quantity_to_create := 1;

  END IF;

  -- Step 3: Create the usesComponent link
  -- Quantity_Used is the Quantity_Needed from needsComponent (which matches child quantity for non-serialized)
  IF v_child_category IN ('Commodity', 'Packaged', 'Serialized') THEN -- Only insert if subtype was handled
      INSERT INTO usesComponent (Parent_IID, Child_IID, Quantity_Used)
      VALUES (786.0, v_new_child_instance_id, ROUND(0.6, 1)); -- Use rounded quantity needed
  END IF;

EXCEPTION
  WHEN OTHERS THEN
    DBMS_OUTPUT.PUT_LINE('Error processing Parent_IID=' || 786.0 || ', Child_PID=' || 229.0 || ': ' || SQLERRM);
    -- Decide if you want to rollback just this block or let the main exception handler catch it
END;
/
DECLARE
  v_new_child_instance_id productInstance.Instance_ID%TYPE;
  v_child_category        product.Category%TYPE := 'Commodity'; -- Pass category
  v_max_existing_batch_lot NUMBER;
  v_next_batch_lot_num   NUMBER;
  v_serial_number        serialized.Serial_Number%TYPE;
  v_batch_number         serialized.Batch_Number%TYPE; -- Shared batch for serialized children of *this* parent
  v_expiration_date      commodity.Expiration_Date%TYPE;
  v_quantity_to_create   commodity.Quantity%TYPE; -- Quantity for the new child instance

BEGIN
  -- Step 1: Create the new child productInstance
  INSERT INTO productInstance (Product_ID, Date_Manufactured, Is_Recalled)
  VALUES (181.0, TIMESTAMP '2024-08-14 06:03:09', 0)
  RETURNING Instance_ID INTO v_new_child_instance_id;

  -- Step 2: Create the corresponding subtype record
  IF v_child_category = 'Commodity' THEN
    -- Find max existing Batch_Number for this specific Child_PID
    SELECT NVL(MAX(c.Batch_Number), 0) INTO v_max_existing_batch_lot
    FROM commodity c JOIN productInstance pi ON c.Instance_ID = pi.Instance_ID
    WHERE pi.Product_ID = 181.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next batch

    v_expiration_date := TIMESTAMP '2024-08-14 06:03:09' + INTERVAL '409' DAY;
    v_quantity_to_create := ROUND(1.1, 1);

    INSERT INTO commodity (Instance_ID, Batch_Number, Expiration_Date, Quantity)
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Packaged' THEN
    -- Find max existing Lot_Number for this specific Child_PID
    SELECT NVL(MAX(p.Lot_Number), 0) INTO v_max_existing_batch_lot
    FROM packaged p JOIN productInstance pi ON p.Instance_ID = pi.Instance_ID -- Assuming 'packaged' table name
    WHERE pi.Product_ID = 181.0;
    v_next_batch_lot_num := v_max_existing_batch_lot + 1; -- Assign next lot

    v_expiration_date := TIMESTAMP '2024-08-14 06:03:09' + INTERVAL '448' DAY;
    v_quantity_to_create := ROUND(1.1, 1);

    INSERT INTO packaged (Instance_ID, Lot_Number, Expiration_Date, Quantity) -- Assuming 'packaged' table name
    VALUES (v_new_child_instance_id, v_next_batch_lot_num, v_expiration_date, v_quantity_to_create);

  ELSIF v_child_category = 'Serialized' THEN
    -- Assign a unique serial number
    -- Using Instance ID guarantees uniqueness within this context
    v_serial_number := 'SN-' || TO_CHAR(181.0) || '-' || TO_CHAR(v_new_child_instance_id) || '-' || SUBSTR(SYS_GUID(),1,8);
    -- Assign a batch number - use Product_ID of the *parent* instance as the batch for simplicity? Or a sequence?
    -- Let's use the Parent_IID itself as a simple batch identifier for this run.
    v_batch_number := 786.0; -- All children created FOR this parent get same batch number

    INSERT INTO serialized (Instance_ID, Serial_Number, Batch_Number)
    VALUES (v_new_child_instance_id, v_serial_number, v_batch_number);

    -- Quantity for usesComponent link for serialized is typically 1
    v_quantity_to_create := 1;

  END IF;

  -- Step 3: Create the usesComponent link
  -- Quantity_Used is the Quantity_Needed from needsComponent (which matches child quantity for non-serialized)
  IF v_child_category IN ('Commodity', 'Packaged', 'Serialized') THEN -- Only insert if subtype was handled
      INSERT INTO usesComponent (Parent_IID, Child_IID, Quantity_Used)
      VALUES (786.0, v_new_child_instance_id, ROUND(1.1, 1)); -- Use rounded quantity needed
  END IF;

EXCEPTION
  WHEN OTHERS THEN
    DBMS_OUTPUT.PUT_LINE('Error processing Parent_IID=' || 786.0 || ', Child_PID=' || 181.0 || ': ' || SQLERRM);
    -- Decide if you want to rollback just this block or let the main exception handler catch it
END;
/